;
; ======================================================================
;          TRS-80 Model I Level II BASIC ROM
;              "Modernised" Revision 1.4
;
;     Source Code Created By : kiwisincebirth - 2025
;     [https://github.com/kiwisincebirth/TRS-80]
;
; ======================================================================
;     NOTE: this code has been formatted with 8 spaces per tab
; ----------------------------------------------------------------------
;
; BASED OFF LEVEL 2 ROMS
; Version 1.3 - 80/02
; Date: 01/07/80-01/13/80
; CRC-32: A8E60D9A
;
; Rom Hardware Support
; #DEFINE EACA80  ; Uncomment to enable System-80 (EACA) hardware support
;
; Rom Bug Fixes
#DEFINE BUGFIX5 ; Fix Error 5 - 08A7H - INT(DoubleValue) rounding
#DEFINE BUGFIX8 ; Fix Error 8 - 1009H - PRINT USING, - sign at end of field
;
; Rom Additional Features
#DEFINE LOWCASE ; Disable Alpha Character Translation (0471h)
#DEFINE FREHDBT ; Enable FreHD Auto boot at startup (069Ch)
#DEFINE NMIHARD ; Set NMI Reset as always hard reset. (0066h)
;
; Rom 1.3 Features (can be disabled to save space)
#DEFINE KEYBOUNCE ; Enable 1.3 Keyboard Debounce (03FBh)
;
; Build Features
; #DEFINE SIZE16K ; Uncomment to build a $FF padded 16K Image for banked ROM
; #DEFINE DONTEND ; Uncomment to Disable END directive, use if #include
;
; ======================================================================
;     INFORMATION
; ----------------------------------------------------------------------
;
; Code was based off the Model 1 Rev 1.3 source code, provided in the GIT Repo
; and enhanced modernised, with new features removing support for cassette
; based operations.
;
; ======================================================================
;      ERRORS - "TRS-80 ROM Errors - Vernon Hester"
;      https://www.trs-80.com/sub-rom-bugs.htm
; ----------------------------------------------------------------------
;
; Error 5 - 08A7 - INT(DoubleValue) rounding issue
;
; EXPECTATION: INT(value) should produce a result equal to or less than value.
; However, if the value is double-precision (by definition), the ROM rounds value
; to single-precision first, then performs the INT function. e.g.
;
; PRINT INT(2.9999999) -> produces 3 instead of 2.
;
; Error 8 - 1099 - PRINT USING, sign at end of field
;
; RULE: A PRINT USING statement with a negative sign at the end of the field prints
; a negative sign after negative numbers and prints a space for positive numbers.
; However, if the field specifiers in the string also has two asterisks at the
; beginning of the field, the ROM prints an asterisk instead of a space after a
; positive number.
;
; PRINT USING "**####-";1234 -> produces '**1234*' instead of '**1234-'
;
; ======================================================================
;      REFERENCES
; ----------------------------------------------------------------------
;   • Git Hub Repository - [https://github.com/kiwisincebirth/TRS-80]
;   • Ira Goldlang, TRS-80 ROM Information - [https://www.trs-80.com/wordpress/roms/]
;   • TRS-80 ROM Errors - Vernon Hester - [https://www.trs-80.com/sub-rom-bugs.htm]
;   • Telemark Assembler - [https://www.cpcalive.com/docs/TASMMAN.HTM]
;   • Microsoft BASIC Decoded & Other Mysteries - James Farvour
;   • TRS-80 Rom Routines Documented (The Alternate Source) - Jack Decker
;
; ======================================================================
;
#IFDEF EACA80
	.ECHO	" EACA80 - EACA hardware support enabled \n"
#ENDIF

#IFDEF FREHDBT
	.ECHO	" FREHDBT - FreHD autoboot support enabled \n"
#ENDIF

;
; ----------------------------------------------------------------------
;   BASIC TOKENS IDS
;   (note: this is not complete, just constants used in code)
; ----------------------------------------------------------------------
TKOFF	.EQU	$80	; Offset - The first Token, Token Offset.
TKEND	.EQU	$80	; END
TKFOR:	.EQU	$81	; FOR
TKNEXT:	.EQU	$87	; NEXT
TKDATA:	.EQU	$88	; DATA
TKGOTO:	.EQU	$8D	; GOTO
TKIF:	.EQU	$8F	; IF
TKGOSU:	.EQU	$91	; GOSUB
TKREM:	.EQU	$93	; REM
TKELSE:	.EQU	$95	; ELSE
TKERRO:	.EQU	$9E	; ERROR
TKPRNT:	.EQU	$B2	; PRINT
TKTAB:	.EQU	$BC	; TAB(
TKTO:	.EQU	$BD	; TO
TKFN:	.EQU	$BE	; FN
TKUSNG:	.EQU	$BF	; USING
TKVARP:	.EQU	$C0	; VARPTR
TKUSR:	.EQU	$C1	; USR
TKERL:	.EQU	$C2	; ERL
TKERR:	.EQU	$C3	; ERR
TKSTRG:	.EQU	$C4	; STRING$
TKINST:	.EQU	$C5	; INSTR
TKPOIN:	.EQU	$C6	; POINT
TKTIME:	.EQU	$C7	; TIME$
TKMEM:	.EQU	$C8	; MEM
TKINKY:	.EQU	$C9	; INKEY$
TKTHEN:	.EQU	$CA	; THEN
TKNOT:	.EQU	$CB	; NOT
TKSTEP:	.EQU	$CC	; STEP
TKPLUS:	.EQU	$CD	; +
TKMNUS:	.EQU	$CE	; -
TKGT:	.EQU	$D4	; >
TKEQL:	.EQU	$D5	; =
TKLT:	.EQU	$D6	; <
TKSGN:	.EQU	$D7	; SGN
ONEFUN: .EQU	$D7	; SGN - Called ONEFUN in TRS-80.COM disassembly.
TKSQR:	.EQU	$DD	; SQR
TKATN:	.EQU	$E4	; ATN
TKMID:	.EQU	$FA	; MID
TKSNQT:	.EQU	$FB	; '
;
; ----------------------------------------------------------------------
;   ERROR CODES - in format ERRnn where "nn" is the basic Error
;       SEE table at 18C9 for the associated Text descriptions
; ----------------------------------------------------------------------
ERRNF:	.EQU	00H   	; NEXT without FOR
ERRSN:	.EQU	02H	; Syntax Error
ERRRG:	.EQU	04H	; RETURN without GOSUB
ERROD:	.EQU	06H	; Out of DATA
ERRFC:	.EQU	08H	; Illegal Function Call
ERROV:	.EQU	0AH	; Overflow
ERROM:	.EQU	0CH	; Out of Memory
ERRUL:	.EQU	0EH	; Underfined Line Number
ERRBS:	.EQU	10H	; Subscript out of Range
ERRDD:	.EQU	12H	; Redimensioned Array
ERRD0:	.EQU	14H	; Division by Zero
ERRID:	.EQU	16H	; Illegal Direct Operation
ERRTM:	.EQU	18H	; Type Mismatch
ERROS:	.EQU	1AH	; Out of String Message
ERRLS:	.EQU	1CH	; Out of Memory
ERRST:	.EQU	1EH	; String Too Long
ERRCN:	.EQU	20H	; Can’t Continue
ERRNR:	.EQU	22H	; No RESUME
ERRRW:	.EQU	24H	; RESUME Without Error
ERRUE:	.EQU	26H	; Unprintable Error
ERRMO:	.EQU	28H	; Missing Operand
ERRFD:	.EQU	2AH	; Bad file Data
ERRL3:	.EQU	2CH	; Disk BASIC Command
;
; ----------------------------------------------------------------------
; Device Code Types. See PRTFLG
; ----------------------------------------------------------------------
DEV0VID:	.EQU	$00	; 0 - VIDEO DEVICE (Z Flag) - uses XOR A to set
DEV1PRT:	.EQU	$01	; 1 - PRINTER DEVICE (NZ Flag - positive number)
DEVTAPE:	.EQU	$80	; $80 - TAPE DEVICE (M Flag - negative number)
;
; ----------------------------------------------------------------------
;   Z-80 TRICKS - these are 1 byte opcode for multibyte instructions
;		- used in Z-80 trick code.
;
;   https://rosettacode.org/wiki/Category:Z80_Assembly#Inlined_bytecode
;   https://wikiti.brandonw.net/index.php?title=Z80_Optimization#Better_else
; ----------------------------------------------------------------------
LDBCNN:	.EQU 	$01	; LD BC,nnnn - skip 2 bytes
LDBNN:	.EQU 	$06	; LD B,nn - skip next byte
LDCNN:	.EQU 	$0E	; LD C,nn - skipping next byte
LDDENN:	.EQU 	$11	; LD DE,nnnn - skip next 2 bytes
LDDNN:	.EQU 	$16	; LD D,nn - skipping next byte
LDHLNN:	.EQU 	$21	; LD HL,nnnn - skip 2 bytes
LDLNN:	.EQU 	$2E	; LD L,nn - skip 1 byte
LDANN:	.EQU 	$3E	; LD A,nn - skip 1 byte
OPJPNN:	.EQU 	$C3	; JP nnnn (Opcode)
OPRET:	.EQU	$C9	; RET (Opcode)
JPZNN:	.EQU 	$CA	; JP Z,nnnn - skip 2 bytes
JPNCNN:	.EQU 	$D2	; JP NC,nnnn - skip 2 bytes
JPCNN:	.EQU 	$DA	; JP C,nnnn - skips 2 bytes
ORNN:	.EQU 	$F6	; OR nn - skip 1 byte
JPMNN:	.EQU 	$FA	; JP M,nnnn - skip 2 bytes
CPNN:	.EQU 	$FE	; CP nn - skip next bytye
;
; ----------------------------------------------------------------------
;   ASCII Codes for Keyboard and Display
; Comments (In Brackets) are the Keyboard mappings,
; ----------------------------------------------------------------------
BREAK:	.EQU	$01	; (BREAK Key)
ETX:	.EQU	$03	; End Of Text (Ascii)
;
BACKS:	.EQU 	$08	; (LEFT  Arrow) - Backspace
TAB:	.EQU 	$09	; (RIGHT Arrow) - Tab
LINEF:	.EQU 	$0A	; (DOWN  Arrow)
VERTAB:	.EQU 	$0B	; Vertical Tab (Ascii)
FORMF:	.EQU 	$0C	; Form Feed (Ascii)
ENTER:	.EQU 	$0D	; (ENTER Key) - Return
;
; Following are special meaning CHR codes, not ASCII standard
CURON:	.EQU	$0E	; turn on cursor.
CUROFF:	.EQU	$0F 	; turn off cursor.
MODE32:	.EQU	$17	; select line size of 32 char/line.
ARLEFT:	.EQU	$18	; (Shift-LEFT Arrow) backspace one character
ARIGHT:	.EQU	$19	; (Shift-RIGHT Arrow) skip forward one character
ARDOWN:	.EQU	$1A	; (Shift-DOWN Arrow) skip down one line
ARUP:	.EQU	$1B	; (Shift-UP  Arrow) skip up one line
CHOME:	.EQU	$1C	; home cursor. select 64 char/line.
CLINE:	.EQU	$1D	; position cursor to Start of current line
ELINE:	.EQU	$1E	; erase from cursor to end of line
CLRKEY:	.EQU	$1F	; (CLEAR Key) erase from Cursor to end of frame
;
SPACE:	.EQU 	$20	; A space character
DQUOTE	.EQU	$22	; A Double Quote ( " )
SQUOTE	.EQU	$27	; A Single Quote ( ' )
SEMICO	.EQU	$3B	; Note ';' in code; was breaking some assemblers
UPARRW	.EQU	$5B	; (UP Arrow) Special Up Arrow ↑ Character in TRS Charset
BQUOTE	.EQU	$60	; A Back Quote ( ` )
CURCHR  .EQU	$5F	; _ cursor character
;
; ======================================================================
; MACROS
; ======================================================================
;
#DEFINE	SYNTAX(char)	rst 08h\ .DB char
#DEFINE	GETCHR		rst 10h
#DEFINE	CPDEHL		rst 18h
#DEFINE	TSTDAT		rst 20h
#DEFINE NOP2		nop\ nop
#DEFINE NOP3		nop\ nop\ nop
;
; ----------------------------------------------------------------------
; Constants used by FreHD
; ----------------------------------------------------------------------
#IFDEF FREHDBT
;
ROM_MODEL_1	.EQU	1	; TRS model : passed by the patched rom
ROM_MODEL_3	.EQU 	3	; TRS model : passed by the patched rom
READROM:	.EQU 	$C4	; read only
WRITEROM	.EQU 	$C5	; write only
ROM_LOAD	.EQU 	$5000	; where the extra "rom is loaded
;
#ENDIF
;
; ======================================================================
;   START OF PROGRAM CODE
; ======================================================================
;
;
	.ORG	$0000	; Start of ROM Code Base
RAM:	.EQU	$4000	; Start of RAM Communications area
;
; ----------------------------------------------------------------------
; 0000H-0004H – POWER UP ROUTINE – "_START"
; ----------------------------------------------------------------------
_START:
rst00:	di			;0000
	xor	a		;0001
	jp	INIT		;0002
;
; The BDOS (Basic Disk Operating System) entry point address in most CP/M systems
; Having this here may be coincidental, and may be UNUSED
	jp	mRST1		;0005
;
; ======================================================================
; 0008H (RST 8H) - Compare Symbol - SYMBOL
;
;   Jumps to 4000H. 4000H passes control to 1C96H.
;   Compares the symbol in the input string pointed to by HL
;   register to the value in the location following the RST 08
;   call. If there is a match, control is returned to address of the
;   RST 08 instruction 2 with the next symbol in the A-register
;   and HL incremented by one. If the two characters do not
;   match, a syntax error message is given and control returns
;   to the Input Phase.
; ----------------------------------------------------------------------
rst08:	jp	mRST1		;0008
;
; ----------------------------------------------------------------------
; 000BH-000CH – DISK ROUTINE – "_WHERE" ( RESOLVE RELOCATION ADDRESS )
;   Same as a RET instruction except leaves return address in HL
;    A relocatable program can CALL 000BH and upon return the HL register
;    will contain hte current address of PC, thus can find itself in memory
; ----------------------------------------------------------------------
_WHERE:	pop	hl		;000b
	jp	(hl)		;000c
;
; ----------------------------------------------------------------------
; 000DH-000FH – DISK BOOTSTRAP – "_BOOT"
;   Does a "warm" system reboot, in that it reloads and executes the Disk
;    Operating System but does not re-initialize all system pointers, etc.
; ----------------------------------------------------------------------
_BOOT:	jp	BOOT		;000d - Jump to Disk Bootstrap loader (069Fh)
;
; ======================================================================
; 0010H (RST 10) – GET A CHARACTER FROM THE BUFFER - GETCHR
;
;   Loads the next character from the string pointed to by the
;   HL register set into the A-register and clears the CARRY
;   flag if it is alphabetic, or sets it if is alphanumeric. Blanks
;   and control codes 09 and 0B are ignored causing the
;   following character to be loaded and tested. The HL
;   register will be incremented before loading any character
;   therefore on the first call the HL register should contain the
;   string address minus one. The string must be terminated by
;   a byte of zeros.
; ----------------------------------------------------------------------
rst10:	jp	mRST2		;0010
;
; ----------------------------------------------------------------------
; 0013H-0017H – INPUT ROUTINE – _GET
; ----------------------------------------------------------------------
_GET:	push	bc		;0013
	ld	b,$01		;0014 - device type entry code
	jr	CIOJ		;0016 - BASIC driver entry routine at 0046H
;
; ======================================================================
; 0018H (RST 18H) Compare DE:HL - CPDEHL
;
;   This routine can be called by using RST 18H or CALL 1C90H.
;   Numerically compares DE and HL. Will not work for
;   signed integers (except positive ones). Uses the A-register
;   only. Sets the S and Z flags accordingly
;   (they are set in the same way as for a normal 8 bit CP).
;   All registers are unchanged except for A
;   Jumps to lC90H through 4006H.
; ----------------------------------------------------------------------
rst18:	jp	mRST3		;0018
;
; ----------------------------------------------------------------------
; 001BH-001EH – DRIVER ENTRY ROUTINE – Part 1 – "_PUT"
; ----------------------------------------------------------------------
_PUT:	push	bc		;001b
	ld	b,$02		;001c - device type entry code
	jr	CIOJ		;001e - BASIC driver entry routine at 0046H
;
; ======================================================================
; 0020H (RST 20H) - Test Data Mode - TSTDAT
;
;   This routine jumps to 25D9H through 4009H.
;   If the NTF=8 then C=RESET or else C=SET, Z flag will be SET if NTF=3
;   (S flag is valid also.). After execution of RST 20H or CALL 25D9H,
;   A will contain the value NTF-3, all other registers are unchanged.
; ----------------------------------------------------------------------
rst20:	jp	mRST4		;0020
;
; ----------------------------------------------------------------------
; 0023H-0027H – DISK ROUTINE – "_CTL"
;   Outputs a control byte to a logical device or FCB.
;   DE = FCB and A = control byte
; ----------------------------------------------------------------------
_CTL:	push	bc		;0023
	ld	b,$04		;0024 - device type entry code
	jr	CIOJ		;0026- BASIC driver entry routine at 0046H
;
; ======================================================================
; 0028H (RST 28H) - DOS Function CALL - DOSCAL
;
;   Jumps to 400CH which contains C9H (RET) under Level II BASIC.
;   This vector is only used by Disk BASIC. It is called by the BREAK key routine,
;   and can be used to intercept the BREAK key logic
; ----------------------------------------------------------------------
_DOSCAL:
rst28:	jp	mRST5		;0028
;
; ======================================================================
; 002BH – KEYBOARD ROUTINE – "_KBD" - Scan Keyboard
;
;   This Routine Performs an instantaneous scan of the keyboard.
;   After CALLing 2BH, the A Register will contain
;   the ASCII value for the key that was pressed, or ZERO if no key pressed.
;
;   Apart from the AF Register Pair the DE Register Pair is also used by the routine.
;   If you want to wait for a key to be pressed, you would use CALL 0049
; ----------------------------------------------------------------------
_KBD:	ld	de,mKDCB	;002b
	jr	_GET		;002e
;
; ======================================================================
; 0030 (RST 30H) - Load DEBUG - LDEBUG
;
;   This CALL loads the DEBUG program and transfers
;   control to it. When DEBUG processing is complete, control
;   is returned to the original caller. For non-disk systems
;   control is returned immediately
;   This location passes control to 400FH which contains a RET (C9H)
;   under Level II. This location is only used by a Disk system
; ----------------------------------------------------------------------
rst30:	jp	mRST6		;0030
;
; ======================================================================
; 0033H – VIDEO ROUTINE – "_DSP" - Character print routine.
;
;  Print a character at the current cursor position.
;  The A Register must contain the ASCII code for the character or graphics
;  figure that is to be printed before CALLing this routine.
;  The DE Register Pair is used by the routine.
; ----------------------------------------------------------------------
VDCHAR:
_DSP:	ld	de,mDDCB	;0033 - video device control block.
	jr	_PUT		;0036
;
; ======================================================================
; 0038 (RST 38H) - Interrupt Entry Point - INTERR
;
;  This is the system entry point for all interrupts. It contains a
;  jump to section of code in the Communications Region
;  designed to field interrupts. That section of code consists
;  of a DI (disables further interrupts) followed by a RET
;  (returns to the point of interrupt) for non-disk systems
; ----------------------------------------------------------------------
rst38:	jp	mRST7		;0038
;
; ======================================================================
; 003BH – PRINTER ROUTINE – "$PRT"
;  Waits until printer is ready then prints charatcter.
;  A = ASCII character. If BREAK is pressed, a return to caller is made
;  Character LPRINT routine. Same as 33H but outputs to line printer.
;  (Contents of A Register will be printed).
; ----------------------------------------------------------------------
PRCHAR:
_PRT:	ld	de,mPDCB	;003b
	jr	_PUT		;003e
;
; ----------------------------------------------------------------------
; 0040H – INPUT ROUTINE – "$KEYIN" - GET A LINE FROM THE KEYBOARD
;  takes keyboard entry until a carriage return, a break, or buffer overrun occurs.
; ----------------------------------------------------------------------
KBLINE:
_KEYIN:	jp	KEYIN		;0040
	ret			;0043 - UNUSED
	nop			;0044 - UNUSED
	nop			;0045 - UNUSED
;
; ----------------------------------------------------------------------
; 0046H-0048H – DRIVER ENTRY ROUTINE – Part 2 – "CIOJ"
; ----------------------------------------------------------------------
CIOJ:	jp	CIO		;0046
;
; ======================================================================
; 0049H – KEYBOARD ROUTINE – "$KEY" -  Wait For Keyboard Input
;
;   Returns as soon as any key on keyboard is pressed. ASCII
;   value for character entered is returned in A- register. Uses
;   A, status and DE registers.
; ----------------------------------------------------------------------
KBWAIT:
_KEY:	call	_KBD		;0049
	or	a		;004c
	ret	nz		;004d
	jr	_KEY		;004e
;
; ----------------------------------------------------------------------
; 0050H-005FH – KEYBOARD LOOKUP TABLE – "KEYTAB"
;   XXX in 1.3, Shift-↓ is $00 to act as a Ctrl key
;                Std    Shifted
; ----------------------------------------------------------------------
KEYTAB:	.DB	ENTER,	ENTER	; ENTER
	.DB	CLRKEY,	CLRKEY	; CLEAR
	.DB	BREAK,	BREAK	; BREAK
	.DB	UPARRW,	ARUP	; ↑ Up Arrow
	.DB	LINEF,	$00	; ↓ Down Arrow
				; to permit Shift-Down-Arrow to act as a control key
	; Previously in V1.2 it was
	; .DB	LINEF,	ARDOWN	; LF, ↓ Down Arrow

	.DB	BACKS,	ARLEFT	; BS, ← Left arrow
	.DB	TAB,	ARIGHT	; Tab, -> right arrow
	.DB	SPACE,	SPACE	; Space
;
; ----------------------------------------------------------------------
; 0060H-0065H – DELAY ROUTINE – "$DELAY"
;  This is a delay loop. The BC Register Pair is used as the loop counter.
;  The duration of the delay, in microseconds, is the value of BC times 14.66.
;  Register A is used.
; ----------------------------------------------------------------------
DELAY:	dec	bc		;0060
	ld	a,b		;0061
	or	c		;0062
	jr	nz,DELAY	;0063
	ret			;0065
;
; ----------------------------------------------------------------------
; 0066 - NMI RESET
; the location to which program control jumps when the RESET button
; is pressed (Non Maskable Interrupt address)
; The RESET button generates an NMI, not an actual reset.
; ----------------------------------------------------------------------
#IFDEF NMIHARD
;
NMI:	jp	_START		;0066 - wrong Stack Pointer.
;
	.ECHO	" NMIHARD - NMI full system reset enabled \n"
	.FILL	$0072 - $ ,0	;UNUSED fill the space to next routine with ZERO's
;
#ELSE
;
NMI:	ld	sp,$0600	;0066 - wrong Stack Pointer. Replaced latter
	ld	a,(diskstat)	;0069 - $FF if no expansion interface present
	inc	a		;006C
	cp	$02		;006D - did we detect a disk controller
	jp	nc,_START	;006F - If a disk is present START as if power-up
;
#ENDIF
;
; ----------------------------------------------------------------------
; Alternative entry point to BASIC. See 06CCH or 1A19 for more details
; ----------------------------------------------------------------------
	jp	RESETR		;0072 - NO - jump to Level II BASIC READY routine
;
; ----------------------------------------------------------------------
; 0075H-0104H – INITIALIZATION ROUTINE – "INIT2"
;  This is part of the Level II initialization procedure. It moves
;  several support routine from 18F7H to 191EH up to 4080H to 40A7H.
; ----------------------------------------------------------------------
INIT2:	ld	de,FDIVC	;0075 - Ram location - of Level II BASIC support routines.
	ld	hl,CONSTR	;0078 - Rom Location - of Level II BASIC support routines.
	ld  bc,CONSTR2-CONSTR+1 ;007b - Size of the Routine(s) to move
	ldir			;007e - Move the routines
;
;  Initialises String Buffer
	ld	hl,BUFINI	;0080 - String Buffer Area in RAM (41E5H)
	ld	(hl),':'	;0083 - save a colon
	inc	hl		;0085 - next location
	ld	(hl),b		;0086 - write a 0, B reg should be zero
	inc	hl		;0087 - next location
	ld	(hl),','	;0088 - save a comma
	inc	hl		;008a - next location
;
; This loads 40A7H with the I/O buffer location address 41E8H.
; (40A7H is the I/O buffer pointer and contents be changed to relocate the buffer.)
	ld	(BUFPNT),hl	;008b
;
; Fills the RAM locations pointing to all 28 DOS BASIC commands,
; set them to point to ?L3 ERROR, (4152-41A5)
	ld	de,L3ERR	;008e - address of L3 error code
	ld	b,28		;0091 - there are 28 DOS BASIC commands
	ld	hl,ERCALL	;0093 - address in RAM of lookup table
ERLOPS:	ld	(hl),OPJPNN	;0096 - opcode (1st byte) for JP nnnn
	inc	hl		;0098
	ld	(hl),e		;0099 - address low order
	inc	hl		;009a
	ld	(hl),d		;009b - address high order
	inc	hl		;009c
	djnz	ERLOPS		;009d - and loop bas as required
;
; Set DOS Exit links to RET instructions (41A6-41E2)
	ld	b,21		;009f - 21 DOS Exits
LOPRTS:	ld	(hl),OPRET	;00a1 - Store RET OpCode
	inc	hl		;00a3 - and advance to the next location (3 bytes)
	inc	hl		;00a4
	inc	hl		;00a5
	djnz	LOPRTS		;00a6 - and loop if required
;
; The rest of the initialization routine. Asks MEMORY SIZE ?,
; sets the memory pointers accordingly and prints RADIO SHACK LEVEL II BASIC ,
	ld	hl,MEMEND+$E8	;00a8 - starting address of user RAM (which is 42E8H)
	ld	(hl),b		;00ab
	ld	sp,SMPSTK	;00ac - STACK pointer to 41F8H, temporary until call STKINI
	call	STKINI		;00af - Go initialize the Level II BASIC variables and pointers
	call	CLS		;00b2 - clears the screen, changes to 64 characters, and homes the screen)
;
MEMGET:	ld	hl,MEMMSG	;00b5 - MEMORY SIZE? message
	call	STROUT		;00b8 - print it
	call	QINLIN		;00bb - Print a “?” and get input from the keyboard
	jr	c,MEMGET	;00be - If the BREAK key was pressed, ask again.
	GETCHR			;00c0 - rst 10h
	or	a		;00c1
	jr	nz,TYPMEM	;00c2 - was a response to the MEMORY SIZE?
;
; start testing RAM at 434CH towards FFFFH
	ld	hl,MEMEND+$14C	;00c4 - starting address for the memory size check (434C)
LOOPMM:	inc	hl		;00c7 - next ram location
	ld	a,h		;00c8 - MSB of ram location
	or	l		;00c9 - combine with LSB of ram location
	jr	z,USEDEF	;00ca - if the current memory pointer HL is equal to zero
	ld	a,(hl)		;00cc - get byte at memory location
	ld	b,a		;00cd - save it
	cpl			;00ce - and invert it (A) for test
	ld	(hl),a		;00cf - write it back to ram
	cp	(hl)		;00d0 - retrieve and compare test value
	ld	(hl),b		;00d1 - and save original value back
	jr	z,LOOPMM	;00d2 - loop back until the end of memory is found
	jr	USEDEF		;00d4 - If the address didn’t exist, have reached HIMEM
;
; process the users input to MEMORY SIZE ?
TYPMEM:	call	LINGET		;00d6 - convert user input string (HL) into value in DE
	or	a		;00d9 - Set Flags
	jp	nz,SNERR	;00da - Display a ?SN ERROR if Register A is not equal to zero
	ex	de,hl		;00dd - move value to HL
	dec	hl		;00de - minus 1
	ld	a,$8F		;00df - Load Register A with a memory test value
	ld	b,(hl)		;00e1 - read and save current value
	ld	(hl),a		;00e2 - write the test value
	cp	(hl)		;00e3 - read and compare to see if value was saved
	ld	(hl),b		;00e4 - restore the original value
	jr	nz,MEMGET	;00e5 - if not a usaable ram adress, back to MEM SIZE prompt
USEDEF:	dec	hl		;00e7 - minus 1
	ld	de,MEMEND+$214	;00e8 - the minimum MEMORY SIZE? response.
	CPDEHL			;00eb - RST 18 - compare DE (input)  and HL (minimum)
	jp	c,OMERR		;00ec - less than memory required, so OM ERROR
	ld	de,$FFCE	;00ef - Subtract 32 Bytes
	ld	(MEMSIZ),hl	;00f2 - Save the MEMORY SIZE? amount
	add	hl,de		;00f5 - subtract 32 bytes from the memory size
	ld	(STKTOP),hl	;00f6 - start of string space pointer MEMSIZE-32
	call	SCRTCH		;00f9 - init the Level II variables and pointers
	ld	hl,HDGMSG	;00fc - Radio Shack L2 Basic - Message
	call	STROUT		;00ff - print the message
	jp	READY		;0102 - Level II BASIC READY routine
;
; ----------------------------------------------------------------------
; 0105H-011BH – MESSAGE STORAGE
; ----------------------------------------------------------------------
;
HDGMSG:	.DB	"Radio Shack Level II BASIC",ENTER	; RS L2 Basic Message V1.2
	.DB	"(Rev 1.4a)",ENTER,0
	.FILL	$012D - $				; UNUSED
;
; ----------------------------------------------------------------------
; 012DH – ?L3 ERROR ENTRY POINT – "L3ERR"
; ----------------------------------------------------------------------
L3ERR:	ld	e,ERRL3		;012d - Load Register E with the ?L3 ERROR code of 2CH
	jp	ERROR		;012f
;
; ----------------------------------------------------------------------
; 0132H-0134H –	LEVEL II BASIC POINT COMMAND ENTRY POINT – "POINT"
; ----------------------------------------------------------------------
POINT:	GETCHR			;0132 - rst 10h
	xor	a		;0133
;
; Z-80 Trick! The byte at this memory location, 01H, is there to turn the real instruction
; that follows (the operative action of the SET command) into a harmless LD BC,xxxx.
; This way, they didn’t have to jump over SET or RESET to get to the common graphics code.
; If parsing straight down, this loads BC with 0380H and then moves to 0136H. But if jump
; straight to 0136H, you skip that 01H opcode, and get a real instruciton of 3EH 80H
	.DB	LDBCNN		;0134
;
; ----------------------------------------------------------------------
; 0135H-0137H – LEVEL II BASIC SET COMMAND ENTRY POINT – “SET”
; ----------------------------------------------------------------------
SET:	ld	a,$80		;0135
	.DB	LDBCNN		;0137 - See comment above about what this does
;
; ----------------------------------------------------------------------
; 0138H-0139H – LEVEL II BASIC RESET COMMAND ENTRY POINT – “RESET”
; ----------------------------------------------------------------------
RESET:	ld	a,$01		;0138
;
; ----------------------------------------------------------------------
; 013AH-019CH GRAPHICS ROUTINE - Common Code for SET RESET and POINT
;   A will be 0 if POINT, 80H if SET and 1 for RESET.
; ----------------------------------------------------------------------
;
	push	af		;013a
	SYNTAX	('(')		;013b - rst 08h - all commands start with a (
	call	GETBYT		;013d - get a numeric value X coordinate
	cp	128		;0140 - is it greater than 128
	jp	nc,FCERR	;0142 - if greater than 128 then an error
	push	af		;0145 - Save coordinate’s X value on the STACK
	SYNTAX	(',')		;0146 - rst 08h - then a comma
	call	GETBYT		;0148 - get a numeric value Y coordinate
	cp	$30		;014b - test to see if the character was alphabetic or alphanumeric
	jp	nc,FCERR	;014d
	ld	d,$FF		;0150
LOPMD3:	inc	d		;0152
	sub	$03		;0153
	jr	nc,LOPMD3	;0155
	add	a,$03		;0157
	ld	c,a		;0159
	pop	af		;015a
	add	a,a		;015b
	ld	e,a		;015c
	ld	b,$02		;015d
SHFTW:	ld	a,d		;015f
	rra			;0160
	ld	d,a		;0161
	ld	a,e		;0162
	rra			;0163
	ld	e,a		;0164
	djnz	SHFTW		;0165
	ld	a,c		;0167
	adc	a,a		;0168
	inc	a		;0169
	ld	b,a		;016a
	xor	a		;016b
	scf			;016c
PWR2:	adc	a,a		;016d
	djnz	PWR2		;016e
	ld	c,a		;0170
	ld	a,d		;0171
	or	$3C		;0172
	ld	d,a		;0174
	ld	a,(de)		;0175
	or	a		;0176
	jp	m,FND4		;0177
	ld	a,$80		;017a
FND4:	ld	b,a		;017c
	pop	af		;017d
	or	a		;017e
	ld	a,b		;017f
	jr	z,TBIT		;0180
	ld	(de),a		;0182
	jp	m,SBIT		;0183
	ld	a,c		;0186
	cpl			;0187
	ld	c,a		;0188
	ld	a,(de)		;0189
	and	c		;018a
FINSTB:	ld	(de),a		;018b
FINPTB:	SYNTAX	(')')		;018c - rst 08h
	ret			;018e
SBIT:	or	c		;018f
	jr	FINSTB		;0190
TBIT:	and	c		;0192
	add	a,$FF		;0193
	sbc	a,a		;0195
	push	hl		;0196
	call	CONIA		;0197
	pop	hl		;019a
	jr	FINPTB		;019b
;
; ----------------------------------------------------------------------
; 019DH-01C8H – LEVEL II BASIC INKEY$ ROUTINE – “INKEY”
; ----------------------------------------------------------------------
INKEY:	GETCHR			;019d - rst 10h
; ----------------------------------------------------------------------
; 019E - Create 1 character string from keyboard input (TAS)
; ----------------------------------------------------------------------
	push	hl		;019e
	ld	a,(CHARC)	;019f
	or	a		;01a2
	jr	nz,BUFCIN	;01a3
	call	ISCHAR		;01a5
	or	a		;01a8
	jr	z,NULRT		;01a9
BUFCIN:	push	af		;01ab
	xor	a		;01ac
	ld	(CHARC),a	;01ad
	inc	a		;01b0
	call	STRINI		;01b1
	pop	af		;01b4
	ld	hl,(DSCTMP+1)	;01b5
	ld	(hl),a		;01b8
	jp	PUTNEW		;01b9
NULRT:	ld	hl,m_REDDY-1	;01bc
	ld	(FACLO),hl	;01bf
	ld	a,VTSTR		;01c2 - String Value Type
	ld	(VALTYP),a	;01c4
	pop	hl		;01c7
	ret			;01c8
;
; ======================================================================
; 01C9H – LEVEL II BASIC CLS ROUTINE – "CLS"
;
;   Clear the screen, select 64 characters and home the cursor.
;   All registers are used.
; ----------------------------------------------------------------------
CLS:	ld	a,CHOME		;01c9 - ascii for cursor Home
	call	OUT2D		;01cb - display it
	ld	a,CLRKEY	;01ce - ascii for erase to end of frame
	jp	OUT2D		;01d0 - call and return
;
; ======================================================================
; 01D3H – LEVEL II BASIC REFRESH RANDOM ROUTINE – “RANDOM”
;
;   This is part of the RANDOM routine which takes a value out of the
;   REFRESH register, stores it in location 40ABH and then returns.
;   A call to 01D3H reseeds the random number seed (location 40AB)
;   with the current contents of the refresh register.
; ----------------------------------------------------------------------
RANDOM:	ld	a,r		;01d3 - R (refresh) Reg - semi random number.
	ld	(RNDX+1),a	;01d5
	ret			;01d8
;
; ----------------------------------------------------------------------
; 01D9H-01F7H – CASSETTE ROUTINE
;   Output a pulse to the cassette recorder
; ----------------------------------------------------------------------
CTPULS:	ld	hl,$FC01	;01d9 - a top of pulse
	call	CTCHG		;01dc - output pulse
	ld	b,$0B		;01df - delay count of 80 milliseconds
CT1:	djnz	CT1		;01e1 - delay loop
	ld	hl,$FC02	;01e3 - a bottom of pulse
	call	CTCHG		;01e6 - output pulse
	ld	b,$0B		;01e9 - delay count of 80 milliseconds
CT2:	djnz	CT2		;01eb - delay loop
	ld	hl,$FC00	;01ed - clear pulse
	call	CTCHG		;01f0 - output pulse
	ld	b,$5C		;01f3 - delay count of 671 milliseconds
CT3:	djnz	CT3		;01f5 - delay loop
	ret			;01f7
;
; ----------------------------------------------------------------------
; 01F8H-01FDH – CASSETTE ROUTINE (TURN OFF CASSETTE) – “CTOFF”
; ----------------------------------------------------------------------
CTOFF:	push	hl		;01f8 - Save The HL Register
	ld	hl,$FB00	;01f9 - And Or Flags, turn off cassette
	jr	CTCHG2		;01fc - process this
;
; ----------------------------------------------------------------------
; 01FEH-0211H- CASSETTE ROUTINE (EVALUATE DRIVE NUMBER) – “CTON”
; ----------------------------------------------------------------------
CTON:	ld	a,(hl)		;01fe - char from BASIC program pointer
	sub	'#'		;01ff - Check for a # character
	ld	a,$00		;0201 - A default value, doesnt set flags
	jr	nz,DEFDRV	;0203 - Isnt a # char so process default = 0
	call	GETINT		;0205 - get INT drive number from BASIC program -> DE
	SYNTAX	(',')		;0208 - rst 08h - See if we have a Comma
	ld	a,e		;020a - need to convert from the negative number to positive
	and	d		;020b - combine the MSB with the LSB of the drive number
	add	a,$02		;020c - add 2 to make the drive number positive
	jp	nc,FCERR	;020e - If the drive number is invalid, FC ERROR
	dec	a		;0211 - dec the drive number
;
; ----------------------------------------------------------------------
; 0212H-021DH – CASSETTE ROUTINE (TURN ON CASSETTE) “DEFDRV”
;   CALL 212H will select the cassette unit specified in A-Register
;   and start the motor. Units are numbered from one.
;   Put 00H in A Register to turn on cassette 1, or O1H to turn on cassette 2.
;   All registers are used.
; ----------------------------------------------------------------------
DEFDRV:
#IFNDEF EACA80
	ld	(casselect),a	;0212 - Set the requested cassette
#ELSE
	out	(casport),a	;0212 - On Dick Smith System-80 (EACA) use IO port
	nop			;0214 - Nop since OUT is only 2 byte instruction
#ENDIF
	push	hl		;0215 - Save HL Register
	ld	hl,$FF04	;0216 - AND OR flags to turn on the cassette motor
CTCHG2:	call	CTCHG		;0219 - output this command
	pop	hl		;021c - current BASIC program pointer from the STACK
	ret			;021d
; ----------------------------------------------------------------------
; 021EH-022BH – CASSETTE ROUTINE – “CTSTAT”
; ----------------------------------------------------------------------
CTSTAT:	ld	hl,$FF00	;021e - no change to the cassette port
CTCHG:	ld	a,(CAST)	;0221 - saved shadow ram copy of cassette port
	and	h		;0224 - mask the value, remove unwanted bits
	or	l		;0225 - and set bits we want
	out	(vidcmt),a	;0226 - send value to the CAS port
	ld	(CAST),a	;0228 - save it for future
	ret			;022b
; ----------------------------------------------------------------------
; 022CH-0234H – CASSETTE ROUTINE (BLINK **) – “BCASIN”
;   Alternately displays and clears an asterisk in the upper right hand comer.
;   Uses all registers.
; ----------------------------------------------------------------------
BCASIN:	ld	a,(vidmem+$3F)	;022c
	xor	$0A		;022f
	ld	(vidmem+$3F),a	;0231
	ret			;0234
; ----------------------------------------------------------------------
; 0235H-0240H – CASSETTE ROUTINE (READ A BYTE) – “CASIN”
;   Read One Byte: Reads one byte from the currently selected unit.
;   The byte read is returned in the A-register. Other registers preserved
; ----------------------------------------------------------------------
CASIN:	push	bc		;0235
	push	hl		;0236
	ld	b,$08		;0237
CTB0:	call	CTBIT		;0239
	djnz	CTB0		;023c
	pop	hl		;023e
	pop	bc		;023f
	ret			;0240
; ----------------------------------------------------------------------
; 0241H-0260H – CASSETTE ROUTINE (READ A BIT) – “CTBIT”
;   Routine waits for timing pulse, and then performs a timing loop.
;   When the time is up it tests the tape for a bit, which will be “1”
;   if present and “0” if not. A CALL 241H is used by 235H eight times
;   to input one byte.
; ----------------------------------------------------------------------
CTBIT:	push	bc		;0241
	push	af		;0242
CB0:	in	a,(vidcmt)	;0243 - Read BIT from cassette port
	rla			;0245
	jr	nc,CB0		;0246
	ld	b,$60		;0248 - Delay for 703 microseconds (assume)
	; ld	b,$41		;0248 - Delay for 476 microseconds (V1.2)
CB1:	djnz	CB1		;024a - Delay Loop
	call	CTSTAT		;024c - clear the cassette controller
	ld	b,$85		;024f - Then Delay for 975 microseconds (assume)
	; ld	b,$76		;024f - Then delay for 865 microseconds (V1.2)
CB2:	djnz	CB2		;0251 - Delay Loop
	in	a,(vidcmt)	;0253 - Read BIT from cassette port
	ld	b,a		;0255
	pop	af		;0256
	rl	b		;0257
	rla			;0259
	push	af		;025a
	call	CTSTAT		;025b - clear the cassette controller
	pop	af		;025e
	pop	bc		;025f
	ret			;0260
; ----------------------------------------------------------------------
; 0261H-0263H – CASSETTE ROUTINE – “TWOCSO”
; ----------------------------------------------------------------------
TWOCSO:	call	CASOUT		;0261
;
; ----------------------------------------------------------------------
; 0264H-027DH – CASSETTE ROUTINE (WRITE A BYTE) – “CASOUT”
;   Writes the byte in the A Register to tape. BC, DE and HL are unchanged
; ----------------------------------------------------------------------
CASOUT:	push	hl		;0264
	push	bc		;0265
	push	de		;0266
	push	af		;0267
	ld	c,$08		;0268
	ld	d,a		;026a
BYT0:	call	CTPULS		;026b
	ld	a,d		;026e
	rlca			;026f
	ld	d,a		;0270
	jr	nc,BYT2		;0271
	call	CTPULS		;0273
BYT1:	dec	c		;0276
	jr	nz,BYT0		;0277
	pop	af		;0279
	pop	de		;027a
	pop	bc		;027b
	pop	hl		;027c
	ret			;027d
; ----------------------------------------------------------------------
; 027EH-0283H –	CASSETTE ROUTINE
; ----------------------------------------------------------------------
BYT2:	ld	b,$87		;027e
BYT3:	djnz	BYT3		;0280
	jr	BYT1		;0282
; ----------------------------------------------------------------------
; 0284H-0292H – CASSETTE ROUTINE (TURN ON CASSETTE AND WRITE LEADER) – “CWRTON”
; ----------------------------------------------------------------------
CWRTON:	call	CTON		;0284
	ld	b,$FF		;0287
	xor	a		;0289
CSAV1:	call	CASOUT		;028a
	djnz	CSAV1		;028d
	ld	a,$A5		;028f - sync byte (A5H)
	jr	CASOUT		;0291
; ----------------------------------------------------------------------
; 0293H-029EH –	CASSETTE ROUTINE (TURN ON CASSETTE AND READ LEADER) – “CSRDON”
; ----------------------------------------------------------------------
CSRDON:	call	CTON		;0293
CSRDON3: push	hl		;0296
	xor	a		;0297
CLOD1:	call	CTBIT		;0298
	cp	$A5		;029b - sync byte (A5H)
	jr	nz,CLOD1	;029d
; ----------------------------------------------------------------------
; 029FH-02A8H – CASSETTE ROUTINE
;   Places the double asterisk in the right top corner
;   to show that the sync byte has been found
; ----------------------------------------------------------------------
	ld	a,'*'		;029f
	ld	(vidmem+$3E),a	;02a1
	ld	(vidmem+$3F),a	;02a4
	pop	hl		;02a7
	ret			;02a8
;
ENBLK:	call	CADRIN		;02a9
	ld	(TEMP),hl	;02ac
	call	CTOFF		;02af
;
;
; ----------------------------------------------------------------------
; 02B2 – LEVEL II BASIC SYSTEM ROUTINE – “SYSTEM”
; ----------------------------------------------------------------------
SYSTEM:	call	SYSOUT		;02b2 - Call the DOS exit for system command at 41E2H.
	ld	sp,SYSSTK	;02b5 - Set the STACK pointer to the assumed load address.
	; This location passes control to the routine used by the BASIC command SYSTEM.
	call	CRDO		;02b8 - display a carriage return on the video display
	ld	a,'*'		;02bb
	call	OUTDO		;02bd - Display a * character on the video display.
	call	QINLIN		;02c0 - get the input from the keyboard
	jp	c,RESETR	;02c3 - If BREAK key, JMP 06CC entry. BUG 29
	GETCHR			;02c6 - rst 10h - first byte of user input
	jp	z,SNERR		;02c7 - if no input then a syntax error
	cp	'/'		;02ca - check for a slash command
	jp	nz,SNERR	;IF NOT a "/" command then a syntax error
	jr	GODO		;jump to routine to handle execution
;
; ======================================================================
	.ECHO 	" ROM REGION - (02D0 - 0313) - System \n"
; ======================================================================
;
; ======================================================================
R1FREE:	.EQU 	($0314 - $)
	.ECHO 	"  "
	.ECHO	R1FREE
	.ECHO   " of 67 bytes free \n"
	.FILL	R1FREE
; ======================================================================
;
; ----------------------------------------------------------------------
; 0314H – Read 2 bytes from the tape into Register Pair HL – “CADRIN”
;   This routine is commonly used by the SYSTEM routine to read
;   the last two bytes on tape which give the entry point.
; ----------------------------------------------------------------------
CADRIN:	call	CASIN		;0314 - read one byte from cassette
	ld	l,a		;0317
	call	CASIN		;0318 - read one byte from cassette
	ld	h,a		;031b
	ret			;031c
; ----------------------------------------------------------------------
; 031DH – Execute the Cassette Program which was Loaded – “GODO”
; ----------------------------------------------------------------------
GODO:	ex	de,hl		;031d - put user input buffer into DE
	ld	hl,(TEMP)	;031e - execution address read from tape
	ex	de,hl		;0321 - Swap back, user input buffer into HL
	GETCHR			;0322 - rst 10h
	call	nz,LINGET	;0323 - Convert to ascii string
	jr	nz,SYSTEM	;0326 - if no address defined Display * promt
	ex	de,hl		;0328 - execution address into HL
	jp	(hl)		;0329 - jump to execution address
;
; ----------------------------------------------------------------------
; 032AH-0347H – OUTPUT ROUTINE – “OUTCH1” and “OUTDO”
;   This is a general purpose output routine which outputs a byte from
;   the A Register to video, tape or printer. In order to use it,
;   the location 409CH must be loaded with -1 tape, 0 video, or 1 for printer.
; ----------------------------------------------------------------------
OUTDO:	push	bc		;032a
	ld	c,a		;032b
	call	EXOUTC		;032c
	ld	a,(PRTFLG)	;032f - get the current Device
	or	a		;0332 - set the flags
	ld	a,c		;0333
	pop	bc		;0334
	jp	m,CASOUT	;0335 - if is It Cassette
	jr	nz,OUTLPT	;0338 - if it is Printer
; ----------------------------------------------------------------------
; 033AH-0347H – OUTPUT ROUTINE – “OUT2D”
;   A Print routine which performs the same function as 33H except
;   that it doesn’t destroy the contents of the DE Register Pair.
;   All the general purpose registers are saved, which is often desirable
; ----------------------------------------------------------------------
OUT2D:	push	de		;033a
	call	_DSP		;033b
	push	af		;033e
	call	DSPPOS		;033f - Compute Line pos based on Vid Ram Cursor
	ld	(TTYPOS),a	;0342 - store current line pos
	pop	af		;0345
	pop	de		;0346
	ret			;0347
; ----------------------------------------------------------------------
; 0348H-0357H – VIDEO ROUTINE – “DSPPOS”
;   Works out horizontal cursor position based on (CURSOR) vid ram pointer
; ----------------------------------------------------------------------
DSPPOS:	ld	a,(CAST)	;0348 - get shadow copy of cassette port
	and	CAST32		;034b - mask of the 32 char mode bit
	ld	a,(CURSOR)	;034d - LSB of the current cursor position
	jr	z,NT32PS	;0350 - 64 characters per line mode?
	rrca			;0352 - divide by 2
	and	$1F		;0353 - Mask cursor position for 32 character
NT32PS:	and	$3F		;0355 - Mask cursor position for 64 character
	ret			;0357
; ----------------------------------------------------------------------
; 0358H-0360H – KEYBOARD ROUTINE – “ISCHAR”
;   Here is the routine to simulate the INKEY$ function. It performs exactly
;   the same function as 2BH but it restores all registers, whereas 2BH
;   destroys the DE Register Pair. This makes 35BH more useful than 2BH
; ----------------------------------------------------------------------
ISCHAR:	call	EXINC		;0358
	push	de		;035b
	call	_KBD		;035c
	pop	de		;035f
	ret			;0360
;
; ======================================================================
; 0361H – INPUT ROUTINE – “INLIN”
;
;   This is one of the general purpose input routines (see 5D9 and 1BB3 also).
;   This routine inputs a string from the keyboard, up to 240 characters,
;   and echoes them to the screen. It puts this data into a buffer located
;   at the address pointed to by the buffer pointer at 40A7H
; ----------------------------------------------------------------------
INLIN:	xor	a		;0361
	ld	(CHARC),a	;0362
	ld	(TTYPOS),a	;0365
	call	INLINE		;0368 - Go call the DOS link at 41AFH
	push	bc		;036b
	ld	hl,(BUFPNT)	;036c - starting address of the input buffer
	ld	b,240		;036f - length of the input buffer
	call	KEYIN		;0371 - keyboard input routine, until a CR, a BREAK
	push	af		;0374
	ld	c,b		;0375 - Move lenght of Input to C
	ld	b,0		;0376 - zero B, so BC has has lenght of Input
	add	hl,bc		;0378 - end of the Input
	ld	(hl),$00	;0379 - Save an end of the input terminator
	ld	hl,(BUFPNT)	;037b - back to start of the input buffer
	pop	af		;037e
	pop	bc		;037f
	dec	hl		;0380 - Decrement the input buffer pointer
	ret	c		;0381 - Return if the BREAK key was pressed
	xor	a		;0382 - Signal success
	ret			;0383
; ----------------------------------------------------------------------
; 0384H-038AH – KEYBOARD ROUTINE – “INCHR”
;   Waits for keypress
; ----------------------------------------------------------------------
INCHR:	call	ISCHAR		;0384
	or	a		;0387
	ret	nz		;0388
	jr	INCHR		;0389
; ----------------------------------------------------------------------
; 038BH-039BH – PRINTER ROUTINE – “FINLPT”
; ----------------------------------------------------------------------
FINLPT:	xor	a		;038b
	ld	(PRTFLG),a	;038c - set current output device VIDEO
	ld	a,(LPTPOS)	;038f
	or	a		;0392
	ret	z		;0393
	ld	a,ENTER		;0394
	push	de		;0396
	call	OUTLPT		;0397
	pop	de		;039a
	ret			;039b
;
; =====================================================================
; 039CH-03C1H – PRINTER ROUTINE – “OUTLPT”
;
;  This is the LPRINT routine. All registers are saved.
;  The byte to be printed should be in the A register
; ----------------------------------------------------------------------
OUTLPT:	push	af		;039c
	push	de		;039d
	push	bc		;039e
	ld	c,a		;039f
	ld	e,$00		;03a0
	cp	FORMF		;03a2
	jr	z,LZRPOS	;03a4
	cp	LINEF		;03a6
	jr	nz,LZRNOT	;03a8
	ld	a,ENTER		;03aa
	ld	c,a		;03ac
LZRNOT:	cp	ENTER		;03ad
	jr	z,LZRPOS	;03af
	ld	a,(LPTPOS)	;03b1
	inc	a		;03b4
	ld	e,a		;03b5
LZRPOS:	ld	a,e		;03b6
	ld	(LPTPOS),a	;03b7
	ld	a,c		;03ba
	call	_PRT		;03bb
	pop	bc		;03be
	pop	de		;03bf
	pop	af		;03c0
	ret			;03c1
;
; ----------------------------------------------------------------------
; 03C2H-03E2H – DRIVER ENTRY ROUTINE – “CIO”
;   This routine is called from a RST 14 GET (with a device code of 01H in
;   Register B), RST 1C PUT (with a device code of 02H in Register B),
;   and RST 24 CTL (with a device code of 04H in Register B).
; ----------------------------------------------------------------------
CIO:	push	hl		;03c2 - Save HL, IX, DE registers on the stack
	push	ix		;03c3
	push	de		;03c5 - starting address of Device Drive
	pop	ix		;03c6 - moved from DE to IX via the stack
	push	de		;03c8
	ld	hl,CIORTN	;03c9 - return address for device driver call
	push	hl		;03cc - return address pushed to stack
	ld	c,a		;03cd - put character to process into C
	ld	a,(de)		;03ce - device type code from the DCB
	and	b		;03cf - Isolate device code bits, using B parameter
	cp	b		;03d0 - check for equality with passed device type
	jp	nz,CIOSS	;03d1 - if not same - jump to DOS device Driver (4033)
	cp	$02		;03d4 - clear status flags
	ld	l,(ix+1)	;03d6 - LSB of driver address
	ld	h,(ix+2)	;03d9 - MSB of driver address
	jp	(hl)		;03dc - Jump (and ret) to the driver address in HL
;
; Device driver returns here
CIORTN:	pop	de		;03dd - restore registers from the stack
	pop	ix		;03de - which were pushed in CIO code above
	pop	hl		;03e0
	pop	bc		;03e1 - restore BC, pushed before jump to CIO
	ret			;03e2
;
; ======================================================================
; 03E3H-0457H – KEYBOARD DRIVER – “KEY”
;
;   This is the keyboard driver. It scans the keyboard and converts
;   the bit pattern obtained to ASCII and stores it in the A register.
; ----------------------------------------------------------------------
KBDDRV:	ld	hl,KYBTSS	;03e3
	ld	bc,kbdmatrix+$01;03e6 - first keyboard matrix row
	ld	d,$00		;03e9
KEYLP:	ld	a,(bc)		;03eb
	ld	e,a		;03ec
	xor	(hl)		;03ed
	ld	(hl),e		;03ee
	and	e		;03ef
	jr	nz,KEYDWN	;03f0
	inc	d		;03f2
	inc	l		;03f3
	rlc	c		;03f4
	jp	p,KEYLP		;03f6
	ret			;03f9
; ----------------------------------------------------------------------
; 03FAH-040AH – Accept a KB Downstroke and Convert it to ASCII – “KEYDWN”
; ----------------------------------------------------------------------
KEYDWN:	ld	e,a		;03fa
;
#IFDEF KEYBOUNCE
;
        jp	KEYBOU		;03fb jump to the new keyboard debounce routine.
KYDRES:				;03fe return address for keybounce
;
#ELSE
	ld	a,d		;03fb
	rlca			;03fc
	rlca			;03fd
#ENDIF
;
	rlca			;03fe
	ld	d,a		;03ff
	ld	c,$01		;0400
KEYDLP:	ld	a,c		;0402
	and	e		;0403
	jr	nz,KEYFND	;0404
	inc	d		;0406
	rlc	c		;0407
	jr	KEYDLP		;0409
; ----------------------------------------------------------------------
; 040BH-0428H – Part of the Keyboard routine – “KEYFND”
;   We now have identified the key. Next we need to see if it is shifted
; ----------------------------------------------------------------------
KEYFND:	ld	a,(kbdmatrix+$80);040b - value of the SHIFT key from 3880H
	ld	b,a		;040e
	ld	a,d		;040f
	add	a,$40		;0410
	cp	$60		;0412
	jr	nc,KEYNAL	;0414
	rrc	b		;0416
	jr	nc,KEYRTN	;0418
	add	a,$20		;041a
	ld	d,a		;041c
	ld	a,(kbdmatrix+$40);041d - value at keyboard memory row six
	and	$10		;0420
	jr	z,KEYRT2	;0422
	ld	a,d		;0424
	sub	$60		;0425
	jr	KEYRTN		;0427
; ----------------------------------------------------------------------
; 0429H-043CH – Part of the Keyboard routine – “KEYNAL”
;    If we are here, the character was not alphanumeric,
;    so need to check for special and/or shift
; ----------------------------------------------------------------------
KEYNAL:	sub	$70		;0429
	jr	nc,KEYSPL	;042b
	add	a,$40		;042d
	cp	$3C		;042f
	jr	c,KEYINV	;0431
	xor	$10		;0433
KEYINV:	rrc	b		;0435
	jr	nc,KEYRTN	;0437
	xor	$10		;0439
	jr	KEYRTN		;043b
; ----------------------------------------------------------------------
; 043DH-044AH – Part of the Keyboard routine – “KEYSPL”
;   This routine does a special key conversion via a table
; ----------------------------------------------------------------------
KEYSPL:	rlca			;043d
	rrc	b		;043e
	jr	nc,KEYNSF	;0440
	inc	a		;0442
KEYNSF:	ld	hl,KEYTAB	;0443
	ld	c,a		;0446
	ld	b,$00		;0447
	add	hl,bc		;0449
	ld	a,(hl)		;044a
; ----------------------------------------------------------------------
; 044BH-044BH – Part of the Keyboard routine – “KEYRTN”
;   This routine will debounce the keyboard downstroke and return
; ----------------------------------------------------------------------
KEYRTN:	ld	d,a		;044b - save value for the key pressed from A
KEYRT2:	ld	bc,3500		;044c - delay count (3500)
	call	DELAY		;044f - delay about 51.3 ms
	ld	a,d		;0452 - restore value for the key pressed
	cp	$01		;0453 - Check to see if the BREAK key was pressed
	ret	nz		;0455 - Return if the BREAK key wasn’t pressed
	rst	28h		;0456
	ret			;0457
;
; ======================================================================
; 0458H-058CH – VIDEO DISPLAY DRIVER – “DSPDRV”
;
;   This is the video driver. On entry, the character to be displayed
;   should be in the C register. On exit, A would contain the character
;   at the cursor (if called for an INPUT). This routine handles scrolling etc.
;
;   Register IX points to the DCB, so
;   IX+0 = the DCB type,
;   IX+1 = LSB of the Driver Address, IX+2 = MSB of the Driver Address,
;   IX+3 = LSB of the Cursor Position, IX+4 = MSB of the Cursor Position,
;   IX+5 = Cursor Character, cursor on off flag
;   IX+6 = “D”, and IX+7=”O”
; ----------------------------------------------------------------------
DSPDRV:
	ld	l,(ix+3)	;0458 - LSB of the current cursor position
	ld	h,(ix+4)	;045b - MSB of the current cursor position
	jr	c,DSPRD		;045e - Jump if get last character
	ld	a,(ix+5)	;0460 - cursor on/off flag
	or	a		;0463 - set flags
	jr	z,DSPGRP	;0464 - Jump if the cursor is off
	ld	(hl),a		;0466 - Display the character under the cursor
DSPGRP:	ld	a,c		;0467 - convert and display the charater
	cp	SPACE		;0468 - is it a control code <$20
	jp	c,DSPCTL	;046a - display control code
	cp	$80		;046d - is it a graphic >= $80
	jr	nc,DSPGRC	;046f - display graphic
#IFDEF LOWCASE
	jr	DSPCHR		;0471 - Disable all Alpha CHR translation
;
	.ECHO	" LOWCASE - Lowercase support enabled \n"
	.FILL	$047D - $ ,0	;UNUSED Fill Deleted code bock (ELSE) with NOP's
#ELSE
	cp	$40		;0471 - is it number or symbol ASCII 20h - 40h
	jr	c,DSPCHR	;0473 - then display it
	sub	$40		;0475 - So now upper case A is 01h
	cp	$20		;0477 - is it upper case case
	jr	c,DSPCHR	;0479 - display it
	sub	$20		;047b - convert from lower to upper case
#ENDIF
;
; Output the character, it is not a control character, tab, or special characters
;
DSPCHR:	call	DSPOUT		;047d - Display the character in A (and scroll if necessary)
;
; Completion of the Display Routines, after characters have been printed.
;
DSPSKP:	ld	a,h		;0480 - the MSB of the current cursor position
	and	$03		;0481 - Convert Cursor Pos to Vid Mem Address, clear upper bits.
	or	$3C		;0483 - then force the MSB to be 3C-3Fh (Vid Ram)
	ld	h,a		;0485 - save it back.
	ld	d,(hl)		;0486 - get the value at the location of the cursor
	ld	a,(ix+5)	;0487 - cursor on off flag
	or	a		;048a - Check to see if the cursor is on or off
	jr	z,DSPRTN	;048b - Jump if the cursor is off
	ld	(ix+5),d	;048d - cursor is on, save the character being displayed as the flag
	ld	(hl),CURCHR	;0490 - Display the cursor character
DSPRTN:	ld	(ix+3),l	;0492 - Save LSB of current cursor position
	ld	(ix+4),h	;0495 - Save MSB of current cursor position
	ld	a,c		;0498 - the character that was displayed
	ret			;0499
; ----------------------------------------------------------------------
; 049AH – Read the character at the current position of the display – “DSPRD”
; ----------------------------------------------------------------------
DSPRD:	ld	a,(ix+5)	;049a - the cursor on/off flag
	or	a		;049d - Check to see if the cursor is on or off
	ret	nz		;049e - RET if cursor is on and covering the character
	ld	a,(hl)		;049f - If cursor off, get char at the current cursor position
	ret			;04a0
; ----------------------------------------------------------------------
; 04A1H – Go to the beginning of the line – “DSPBOL”
; ----------------------------------------------------------------------
DSPBOL:	ld	a,l		;04a1 - the LSB of the current position
	and	$C0		;04a2 - point to the beginning of the line, zero the lowest 6 bits
	ld	l,a		;04a4 - save it back
	ret			;04a5
; ----------------------------------------------------------------------
; 04A6H – Handle graphic (NON ASCII) characters – “DSPHRC”
;   Called for characters $80 - $FF
; ----------------------------------------------------------------------
DSPGRC:	cp	$C0		;04a6 - check for Space compression Character
	jr	c,DSPCHR	;04a8 - It is Not. It is normal graphic, so display graphic
	sub	$C0		;04aa - convert into the number of spaces to display
	jr	z,DSPSKP	;04ac - $C0 means display 0 spaces, so Finish
	ld	b,a		;04ae - load the number of spaces to print
; ----------------------------------------------------------------------
; 04AFH – Handle Space Compression characters – “DSPSPC”
; ----------------------------------------------------------------------
DSPSPC:	ld	a,SPACE		;04af - a space character
	call	DSPOUT		;04b1 - Display It
	djnz	DSPSPC		;04b4 - Dec B, If more spaces then loop back
	jr	DSPSKP		;04b6 - Finish Off
; ----------------------------------------------------------------------
; 04B8H – Turn the cursor on – “DSPCON”
; ----------------------------------------------------------------------
DSPCON:	ld	a,(hl)		;04b8 - get char at current cursor position
DSPCN2:	ld	(ix+5),a	;04b9 - save it as the cursor on/off flag
	ret			;04bc
; ----------------------------------------------------------------------
; 04BDH – Turn the cursor off – “DSPCOF”
; ----------------------------------------------------------------------
DSPCOF:	xor	a		;04bd - clear the flag to ZERO, indicating No cursor
	jr	DSPCN2		;04be - save the Flag, and return
; ----------------------------------------------------------------------
; 04C0H – Home the cursor – “DSPHOM”
; ----------------------------------------------------------------------
DSPHOM:	ld	hl,vidmem	;04c0 - starting address of video memory
	ld	a,(CAST)	;04c3 - Shadow of Cassette Port
	and	~CAST32		;04c6 - turn off the 32 char mode bit
	ld	(CAST),a	;04c8 - save shadow copy
	out	(vidcmt),a	;04cb - write to the cassette port
	ret			;04cd
; ----------------------------------------------------------------------
; 04CEH – Backspace – “DSPBSP”
; ----------------------------------------------------------------------
DSPBSP:	dec	hl		;04ce - move cursor back 1 character
	ld	a,(CAST)	;04cf - get shadow copy of Cassette port
	and	CAST32		;04d2 - check for 32 char mode
	jr	z,DSPBS2	;04d4 - 64 char mode sip forward
	dec	hl		;04d6 - back again if 32 char mode
DSPBS2:	ld	(hl),SPACE	;04d7 - Clear the character under cursor
	ret			;04d9
; ----------------------------------------------------------------------
; 04DAH – Cursor Left – “DSPLFT”
; ----------------------------------------------------------------------
DSPLFT:	ld	a,(CAST)	;04da - get shadow copy of Cassette port
	and	CAST32		;04dd - check for 32 char mode
	call	nz,DSPLF2	;04df - if 32 char mode, move back twice
DSPLF2:	ld	a,l		;04e2 - get the lower order address
	and	$3F		;04e3 - mask 64 char line for RET below
	dec	hl		;04e5 - move back 1
	ret	nz		;04e6 - Return if still on the same line
;
; ----------------------------------------------------------------------
; 04E7H – Cursor Down – “DSPDWN”
;  This is a space saver because if the cursor isn’t on the same line
;  it needs to move down, so jumping here is also jumping to a CURSOR DOWN
;  routine that was simply a fall-through from a wrap around
; ----------------------------------------------------------------------
DSPDWN:	ld	de,vidlin	;04e7 - 1 line of 64 characters
	add	hl,de		;04ea - add to the cursor position
	ret			;04eb
; ----------------------------------------------------------------------
; 04ECH – Cursor Right – “DSPRHT”
; ----------------------------------------------------------------------
DSPRHT:	inc	hl		;04ec - advance the cursor
	ld	a,l		;04ed - LSB of the current cursor position
	and	$3F		;04ee - Mask out the upper bits
	ret	nz		;04f0 - Return if cursor still on the same line
; ----------------------------------------------------------------------
; 04F1H – Cursor Up – “DSPUP”
;  Same trick as dealing with CURSOR DOWN if there was an overflow,
;  this does a CURSOR UP if you back up too far
; ----------------------------------------------------------------------
DSPUP:	ld   de,$10000-vidlin	;04f1 - negative video line length (-64)
	add	hl,de		;04f4 - subtract 64 from current position
	ret			;04f5
; ----------------------------------------------------------------------
; 04F6H – Set up 32-Character mode – “DSPETB”
; ----------------------------------------------------------------------
DSPETB:	ld	a,(CAST)	;04f6 - get shadow copy of Cassette port
	or	CAST32		;04f9 - Set the 32 Char mode bit
	ld	(CAST),a	;04fb - save shadow copy of cassette port
	out	(vidcmt),a	;04fd - output setting the HW register
	inc	hl		;0500 - Increment the current cursor position
	ld	a,l		;0501 - get lower order byte
	and	$FE		;0502 - mask out the LSB bit, not relevant for 32char
	ld	l,a		;0504 - write it back to L, adjusting cursor position
	ret			;0505
; ----------------------------------------------------------------------
; 0506H – Process control characters – “DSPCTL”
; ----------------------------------------------------------------------
DSPCTL:
	ld	de,DSPSKP	;0506 - Completion of video display routines
	push	de		;0509 - Save the return address on the STACK
	cp	BACKS		;050a - is a backspace 08h
	jr	z,DSPBSP	;050c - then process a backspace
	cp	LINEF		;050e - is less than a line feed 0A character
	ret	c		;0510 - then nothing further to check
	cp	CURON		;0511 - compare with cursor on 0Eh
	jr	c,DSPCR		;0513 - process a CR/LF which is 0Dh
	jr	z,DSPCON	;0515 - process a cursor on.
	cp	CUROFF		;0517 - cursor off
	jr	z,DSPCOF	;0519
	cp	MODE32		;051b - turn on the 32 character per line mode
	jr	z,DSPETB	;051d
	cp	ARLEFT		;051f - move cursor left
	jr	z,DSPLFT	;0521
	cp	ARIGHT		;0523 - move cursor right
	jr	z,DSPRHT	;0525
	cp	ARDOWN		;0527 - move cursor down
	jr	z,DSPDWN	;0529
	cp	ARUP		;052b - move cursor up
	jr	z,DSPUP		;052d
	cp	CHOME		;052f - cursor home, top left
	jr	z,DSPHOM	;0531
	cp	CLINE		;0533 - cursor to SOL
	jp	z,DSPBOL	;0535
	cp	ELINE		;0538 - erase to EOL
	jr	z,DSPEOL	;053a
	cp	CLRKEY		;053c - erase to EOF
	jr	z,DSPEOF	;053e
	ret			;0540
; ----------------------------------------------------------------------
; 0541H – Part of the Display routine – “DSPOUT”
;   Output the character held in Register A and move the cursor,
;   scrolling the screen if necessary
;   HL contains the current screen address
; ----------------------------------------------------------------------
DSPOUT:
	ld	(hl),a		;0541 - write the character to video ram
	inc	hl		;0542 - next screen position
	ld	a,(CAST)	;0543 - cassette port shadow byte
	and	CAST32		;0546 - mask out 32 char mode bit
	jr	z,DSPOT2	;0548 - if not 32 character mode, skip over
	inc	hl		;054a - Skip another screen location (32 char)
DSPOT2:
	ld	a,h		;054b
	cp	$40		;054c - past end of screen at (4000h)
	ret	nz		;054e - nothing to do
	ld	de,$FFC0	;054f - => -64, ie one line of characters
	add	hl,de		;0552 - move cursor back one line
	push	hl		;0553
; ----------------------------------------------------------------------
; 0554H – Part of the Display routine – “DSPROL”
;   Scroll the screen upward by one line
; ----------------------------------------------------------------------
DSPROL:	ld	de,vidmem	;0554 - starting address of video memory (3C00h)
	ld   hl,vidmem+vidlin	;0557 - second line of vid memory
	push	bc		;055a - Save BC
	ld	bc,15*vidlin	;055b - 15 Lines of Video Memory
	ldir			;055e - MOVE 15 LINES OF VIDEO MEMORY UP ONE LINE
	pop	bc		;0560 - Restore BC
	ex	de,hl		;0561
	jr	DSPERF		;0562 - clear the last line
; ----------------------------------------------------------------------
; 0564H – Part of the Display routine – “DSPCR”
;   Display a carriage return / line feed
; ----------------------------------------------------------------------
DSPCR:	ld	a,l		;0564 - LSB of the current cursor position
	and	$C0		;0565 - make it’s at the start of the current line
	ld	l,a		;0567 - put the value back.
	push	hl		;0568 - Save current cursor position
	ld	de,vidlin	;0569 - length of video display line (64 chars)
	add	hl,de		;056c - add line to current cursor pos
	ld	a,h		;056d - MSB of the current cursor position
	cp	$40		;056e - is past end of video memory (+1)
	jr	z,DSPROL	;0570 - if past the end, scroll the screen
	pop	de		;0572 - Throw away saved cursor position
; ----------------------------------------------------------------------
; 0573H – Part of the Display routine – “DSPEOL”
;   Erase to the end of the line
; ----------------------------------------------------------------------
DSPEOL:	push	hl		;0573 - Save cursor position on the STACK
	ld	d,h		;0574 - MSB of the current cursor position
	ld	a,l		;0575 - LSB of the current cursor position
	or	$3F		;0576 - Set he EOL by setting the lower bits
	ld	e,a		;0578 - EOL of the current line
	inc	de		;0579 - starting character of next line
	jr	DSPERA		;057a - blank to address in DE, and return
; ----------------------------------------------------------------------
; 057CH – Part of the Display routine – “DSPEOF”
;   Erase to the end of the frame. clear the video screen from (including)
;   position N – where N is an integer between 0 and 1023 (decimal),
;   inclusive, to the end of the display, Load the HL Register with the
;   value 3C00H + N and then CALL DSPEOF
; ----------------------------------------------------------------------
DSPEOF:	push	hl		;057c - Save cursor position on the STACK
DSPERF:	ld      de,vidmem+1024  ;057d - end of video memory (4000H)
DSPERA:	ld	(hl),SPACE	;0580 - write a space to cursor
	inc	hl		;0582 - next position
	ld	a,h		;0583 - MSB of the video memory pointer
	cp	d		;0584 - compare with end of VID ram ($40)
	jr	nz,DSPERA	;0585 - Loop back if not finished
	ld	a,l		;0587 - LSB of the video memory pointer
	cp	e		;0588 - compare with end of VID ram ($0)
	jr	nz,DSPERA	;0589 - Loop back if not finished
	pop	hl		;058b - retrieve the saved cusor position
	ret			;058c
;
; ======================================================================
; 058DH – PRINTER DRIVER – “PRT”
;
;   This is the Printer Driver. On entry, Register C to hold the character
;   to be sent to the printer, and [IX] should point to the DCB,
; ----------------------------------------------------------------------
PRTDRV:	ld	a,c		;058d
	or	a		;058e
	jr	z,PRTSTA	;058f - If char=0 then get the printer status and return
	cp	VERTAB		;0591 - is a skip to the top of the form Vertical Tab
	jr	z,PRTVT		;0593 - Jump if it is a Vertical Tab
	cp	FORMF		;0595 - is conditional skip to the top of the form Form Feed
	jr	nz,PRTIT	;0597 - if not form feed - jump and print char
	xor	a		;0599
	or	(ix+3)		;059a
	jr	z,PRTIT		;059d - Jump if zero lines are to be skipped
PRTVT:	ld	a,(ix+3)	;059f - number of lines on the page
	sub	(ix+4)		;05a2 - number of lines printed
	ld	b,a		;05a5 - number of lines left to print
PRTFF:	call	PRTSTA		;05a6 - Call the GET PRINTER STATUS routine
	jr	nz,PRTFF	;05a9 - Loop back until the printer is ready
	ld	a,LINEF		;05ab - We print line feed character(s)
#IFNDEF EACA80
	ld	(prtstat),a	;05ad - Send the character to the printer port 37E8H
#ELSE
	nop			;05ad
	out	(prtport),a	;05ae - On Dick Smith System-80 (EACA) use IO port
#ENDIF
	djnz	PRTFF		;05b0 - Loop back until all of the lines have been skipped
	jr	PRTOP		;05b2 - all lines skipped, reset the line counter and ret
; ----------------------------------------------------------------------
; Printing of normal character starts here
; ----------------------------------------------------------------------
PRTIT:	push	af		;05b4
PRTIT2:	call	PRTSTA		;05b5 - Call the GET PRINTER STATUS routine
	jr	nz,PRTIT2	;05b8 - Loop back until the printer is ready
	pop	af		;05ba
#IFNDEF EACA80
	ld	(prtstat),a	;05ad - Send the character to the printer port 37E8H
#ELSE
	nop			;05bb
	out	(prtport),a	;05bc - On Dick Smith System-80 (EACA) use IO port
#ENDIF
	cp	ENTER		;05be
	ret	nz		;05c0
	inc	(ix+4)		;05c1
	ld	a,(ix+4)	;05c4
	cp	(ix+3)		;05c7
	ld	a,c		;05ca
	ret	nz		;05cb
PRTOP:	ld	(ix+4),0	;05cc
	ret			;05d0
;
; ======================================================================
; 05D1H – Get printer status routine – “PRTSTA”
;
;   Returns the status of the line printer in the status register as
;   zero if the printer is ready, and non-zero if not ready.
; ----------------------------------------------------------------------
PRTSTA:
#IFNDEF EACA80
	ld	a,(prtstat)	;05d1 - Get the status value from the printer (37E8H)
#ELSE
	nop			;05d1
	in	a,(prtport)	;05d2 - On Dick Smith System-80 (EACA) use IO port
#ENDIF
	and	$F0		;05d4
	cp	$30		;05d6
	ret			;05d8
;
; ======================================================================
; 05D9H – Wait For Next Line – “KEYIN”
;
;   Accepts keyboard input and stores each character in a
;   buffer supplied by caller. Input continues until either a
;   carriage return or a BREAK is typed, or until the buffer is
;   full. All edit control codes are recognized, e.g. TAB,
;   BACKSPACE, etc. The calling sequence is: On exit the
;   registers contain
;
;   On exit the registers contain: HL=Buffer address, B=num chars transmitted
;   excluding last, C=Orginal buffer size, A=Last character received
;   if a carriage return or BREAK is typed.
;   Carry Set if break key was terminator, reset otherwise.
;   If the buffer is full, the A Register will contain the buffer size.
; ----------------------------------------------------------------------
KEYIN:	push	hl		;05d9
	ld	a,CURON		;05da - turn on the cursor character
	call	_DSP		;05dc
	ld	c,b		;05df
KLNNXT:	call	_KEY		;05e0
	cp	SPACE		;05e3
	jr	nc,KLNCHR	;05e5
	cp	ENTER		;05e7 - ENTER
	jp	z,KLNCR		;05e9
	cp	CLRKEY		;05ec - CLEAR
	jr	z,KLNCLR	;05ee
	cp	BREAK		;05f0 - BREAK
	jr	z,KLNBRK	;05f2
	ld	de,KLNNXT	;05f4
	push	de		;05f7
	cp	BACKS		;05f8 - Backspace (left arrow)
	jr	z,KLNBSP	;05fa
	cp	ARLEFT		;05fc - Shifted left arrow
	jr	z,KLNCAN	;05fe
	cp	TAB		;0600 - TAB (right arrow)
	jr	z,KLNHT		;0602
	cp	ARIGHT		;0604 - Shifted Right Arrow
	jr	z,KLNETB	;0606
	cp	LINEF		;0608
	ret	nz		;060a
	pop	de		;060b
; ----------------------------------------------------------------------
; Printable Character
; ----------------------------------------------------------------------
KLNCHR:	ld	(hl),a		;060c
	ld	a,b		;060d
	or	a		;060e
	jr	z,KLNNXT	;060f
	ld	a,(hl)		;0611
	inc	hl		;0612
	call	_DSP		;0613
	dec	b		;0616
	jr	KLNNXT		;0617
; ----------------------------------------------------------------------
; 0619H – Part of the Display routine – “KLNCLR”
;   Clear the screen
; ----------------------------------------------------------------------
KLNCLR:	call	CLS		;0619
	ld	b,c		;061c
	pop	hl		;061d
	push	hl		;061e
	jp	KLNNXT		;061f
; ----------------------------------------------------------------------
; 0622H – Part of the Display routine – “KLNCNL”
;   Cancel the accumulated line
; ----------------------------------------------------------------------
KLNCNL:	call	KLNBSP		;0622
	dec	hl		;0625
	ld	a,(hl)		;0626
	inc	hl		;0627
	cp	LINEF		;0628
	ret	z		;062a
KLNCAN:	ld	a,b		;062b
	cp	c		;062c
	jr	nz,KLNCNL	;062d
	ret			;062f
; ----------------------------------------------------------------------
; 0630H – Part of the Display routine – “KLNBSP”
;   Backspace one character. On entry Register B to hold the number
;   of characters received, and Register C to hold the size of the buffer
; ----------------------------------------------------------------------
KLNBSP:	ld	a,b		;0630
	cp	c		;0631
	ret	z		;0632
	dec	hl		;0633
	ld	a,(hl)		;0634
	cp	LINEF		;0635
	inc	hl		;0637
	ret	z		;0638
	dec	hl		;0639
	ld	a,BACKS		;063a
	call	_DSP		;063c
	inc	b		;063f
	ret			;0640
; ----------------------------------------------------------------------
; 0641H – Part of the Display routine – “KLNETB”
;   Turn on 32 Character Mode
; ----------------------------------------------------------------------
KLNETB:	ld	a,MODE32	;0641 - turn on the 32 character per line mode character
	jp	_DSP		;0643
; ----------------------------------------------------------------------
; 0646H – Part of the Display routine – “KLNHT”
;   Process a horizontal tab
; ----------------------------------------------------------------------
KLNHT:	call	DSPPOS		;0646
	and	$07		;0649
	cpl			;064b
	inc	a		;064c
	add	a,$08		;064d
	ld	e,a		;064f
KLNHTL:	ld	a,b		;0650
	or	a		;0651
	ret	z		;0652
	ld	a,SPACE		;0653
	ld	(hl),a		;0655
	inc	hl		;0656
	push	de		;0657
	call	_DSP		;0658
	pop	de		;065b
	dec	b		;065c
	dec	e		;065d
	ret	z		;065e
	jr	KLNHTL		;065f
; ----------------------------------------------------------------------
; 0661H – Part of the Display routine – “KLNBRK”
;   Process a Carriage Return and Automatic Line Feed
; ----------------------------------------------------------------------
KLNBRK:	scf			;0661
KLNCR:	push	af		;0662
	ld	a,ENTER		;0663
	ld	(hl),a		;0665
	call	_DSP		;0666
	ld	a,CUROFF	;0669 - turn off the cursor character
	call	_DSP		;066b
	ld	a,c		;066e
	sub	b		;066f
	ld	b,a		;0670
	pop	af		;0671
	pop	hl		;0672
	ret			;0673
;
; ----------------------------------------------------------------------
; 0674H-06D1H – INITIALIZATION ROUTINE – "INIT"
;   System initialisation.
;   - Enter with CMT/Video port init value in A.
;     On reset, A=0: 64 char video mode, CMT motor relay off, CMT out = 0.85 V.
; ----------------------------------------------------------------------
INIT:
	out	(vidcmt),a	;0674 - reset the Video cassette latch, A=0
;
INITA1:	ld	hl,INITR	;0676 - starting address of the RST’s and DCB’s
	ld	de,RAM		;0679 - starting address of the RAM comms region
	ld	bc,$36		;067c - move 54 bytes
	ldir			;067f - Move 6D2-707 to 4000-4035
;
	dec	a		;0681 - count down by 2 starting at 0
	dec	a		;0682 - so effective loop
	jr	nz,INITA1	;0683 - Loop back until block move occurred 128 times
;
	ld	b,$27		;0685 - 39 bytes of memory need to be zerod
CLRAM:	ld	(de),a		;0687 - zero byte in memory starting at 4036h
	inc	de		;0688 - next address
	djnz	CLRAM		;0689 - loop until filled zero's till 4062h
; ----------------------------------------------------------------------
;  Check for a manual override
; ----------------------------------------------------------------------
	ld	a,(kbdmatrix+$40);068b - value at keyboard BREAK KEY
	and	$04		;068e - if the BREAK key is being pressed
	jp	nz,INIT2	;0690 - Jump if the BREAK key was pressed
;
; This is the beginning of the routine which boots a diskette
	ld	sp,TMPSTK	;0693 - $407D since Disk load will overite > $4200
#IFDEF FREHDBT
	; FreHD includes these 3 bytes by removing code below (06ac)
	call	HDBOOT		;0696 - Call to the FreHD hd boot routines.
#ENDIF
;
	ld	a,(diskstat)	;0696 - status of the disk controller (37ECH)
	inc	a		;0699 - FF => 0, 0 => 1
	cp	$02		;069a - is disk controller present.
	jp	c,INIT2		;069c - Jump to Level II Init if no disk controller
;
;   fallthrough for floppy boot
; ----------------------------------------------------------------------
; 069FH-06CBH – Bootstrap from Diskette – "BOOT"
; Now we know (can assume) there is a disk controller and we should boot it.
; ----------------------------------------------------------------------
;
BOOT:	ld	a,$01		;069f - Drive 0
	ld	(dskselect),a	;06a1 - Select Drive, turning motor on
;
	ld	hl,diskstat	;06a4 - address of the disk command/status Register 37ECH
	ld	de,diskdata	;06a7 - address of the disk data Register (37EFH)
	ld	(hl),$03	;06aa - command 03H (RESTORE and POSITION TO TRACK 0)
#IFNDEF FREHDBT
	; FreHD excludes  these 3 bytes for call HDBOOT above (696h)
	; noting it is expected tha BC = 0000 at this point of the execution
	ld	bc,$0000	;06ac
#ENDIF
	call	DELAY		;06af - delay (BC times 14.65) about 3 seconds
;
BOOTDL:	bit	0,(hl)		;06b2 - is the diskette controller is busy
	jr	nz,BOOTDL	;06b4 - Wait until it is ready
;
	xor	a		;06b6
	ld	(disksect),a	;06b7 - set the disk sector register with 0
	ld	bc,MEMEND	;06ba - address to read sector data (4200H)
	ld	a,$8C		;06bd - command to read single IBM formatted sector
	ld	(hl),a		;06bf - send command to FDC register
;
BOOTLP:	bit	1,(hl)		;06c0 - check to see if there is data available
	jr	z,BOOTLP	;06c2 - loop indefinitely until data ready
;
	ld	a,(de)		;06c4 - load byte from disk data register
	ld	(bc),a		;06c5 - write byte to ram.
	inc	c		;06c6 - next mem address
	jr	nz,BOOTLP	;06c7 - Loop until whole 256 byte sector has been read
	jp	MEMEND		;06c9 - Hand execution to the boot sector code $4200
;
; ----------------------------------------------------------------------
; 06CCH-06CEH – (Model 1 Only!) - re-entry point into BASIC – "RESETR"
;  This is the best re-entry point to BASIC on the Model I.
;  This is an alternative re-entry point into BASIC.
;  A JP 6CCH is often better than a jump to 1A19H.
; ----------------------------------------------------------------------
RESETR:	ld	bc,STPRDY	;06cc - Address of
	jp	ERESET		;06cf - Jumps to 19AE
; ----------------------------------------------------------------------
; 06D2H-0707H – ROM STORAGE LOCATION FOR DATA TO BE MOVED TO RAM
;   BY THE INITIALIZATION PROCESS – “INITR”
;   Note These $36 bytes are moved to RAM at address $4000 during init
; ----------------------------------------------------------------------
INITR:
; RST Code vectors, each is a 3 byte instruction
	jp	SYNCHR		;4000 (mRST1) - RST 00H
	jp	CHRGTR		;4003 (mRST2) - RST 10H
	jp	DCOMPR		;4006 (mRST3) - RST 18H
	jp	GETYPR		;4009 (mRST4) - RST 20H
	ret			;400C (mRST5) - RST 28H
	NOP2
	ret			;400F (mRST6) - RST 30H
	NOP2
	ei			;4012 (mRST7) - RST 38H (Interrupt)
	ret
	nop
; Keyboard DCB
	.DB	1		; 4015 (mKDCB) - Device Type = 1 for KB (Read only)
	.DW	KBDDRV		; 4016 - keyboard driver address
	.DB	0		; 4017 - Not used on Model 1
	.DB	0		; 4018 - Not used on Model 1
	.DB	0		; 4019 - Not used on Model 1
	.DB	"KI"
; Display DCB
	.DB	7		; 401D (mDDCB) - Device Type = 7 for VID
	.DW	DSPDRV		; 401E - DISPLAY driver address
	.DW	vidmem		; 4020 (CURSOR) - Cursor Position (3C00H to 3FFFH)
	.DB	0		; 4022 - Character "covered" on video by Cursor
	.DB	"DO"
; Printer DCB
	.DB	6		; 4025 (mPDCB) - Device Type = 6 for Printer
	.DW	PRTDRV		; 4026 - printer driver address
	.DB	67		; 4028 - lines per page
	.DB	0		; 4029 - Current Line Number
	.DB	0		; 402A - Not used on Model 1
	.DB	"PR"
;
; Normal Disk Operating System re-entry vector.
	jp	$5000		; 402D - MAKE SYS1 (10) DOS REQUEST,
				; typically JP 4400H
; Abnormal DOS re-entry
	rst	00h		; 4030 - DOS REQUEST CODE FOR SYS1
	NOP2			; typically LD A,A3 followed by RST 28
; DOS Device Vectoring Routine
	ld	a, 0		; 4033 (CIOSS) - CALL DOS DEVICE DRIVER (CIOSS)
	ret			; typically will JP 44BBh
;
; ======================================================================
; MATH ROUTINES
; ======================================================================
;
; ----------------------------------------------------------------------
; 0708H-070FH – SINGLE PRECISION ADDITION,
;   ACCumulator = (HL) + ACCumulator – “FADDH”
; ----------------------------------------------------------------------
FADDH:	ld	hl,FHALF	;0708
FADDS:	call	MOVRM		;070b
	jr	FADD		;070e
; ----------------------------------------------------------------------
; 0710H-0712H – SINGLE PRECISION SUBTRACTION,
;   ACCumulator = (HL) – ACCumulator - “FSUBS”
; ----------------------------------------------------------------------
FSUBS:	call	MOVRM		;0710
;
; ======================================================================
; 0713H – LEVEL II BASIC SINGLE PRECISION SUBTRACTION - “FSUB”
;
;   Subtracts the single precision value in (BC/DE) from the
;   single precision value in WRA1. The difference is left in WRA1.
; ----------------------------------------------------------------------
FSUB:	call	NNEG		;0713
;
; ======================================================================
; 0716H – LEVEL II BASIC SINGLE PRECISION ADDITION - “FADD”
;
;   Add the single precision value in (BC/DE) to the single
;   precision value in WRA1. The sum is left in WRA1
; ----------------------------------------------------------------------
FADD:	ld	a,b		;0716
	or	a		;0717
	ret	z		;0718
	ld	a,(FAC)		;0719
	or	a		;071c
	jp	z,MOVFR		;071d
	sub	b		;0720
	jr	nc,FADD1	;0721
	cpl			;0723
	inc	a		;0724
	ex	de,hl		;0725
	call	PUSHF		;0726
	ex	de,hl		;0729
	call	MOVFR		;072a
	pop	bc		;072d
	pop	de		;072e
FADD1:	cp	$19		;072f
	ret	nc		;0731
	push	af		;0732
	call	UNPACK		;0733
	ld	h,a		;0736
	pop	af		;0737
	call	SHIFTR		;0738
	or	h		;073b
	ld	hl,FACLO	;073c
	jp	p,FADD3		;073f
	call	FADDA		;0742
	jp	nc,ROUND	;0745
	inc	hl		;0748
	inc	(hl)		;0749
	jp	z,OVERR		;074a
	ld	l,$01		;074d
	call	SHRADD		;074f
	jr	ROUND		;0752
; ----------------------------------------------------------------------
; 0754H-077CH – SINGLE PRECISION MATH ROUTINE – “FADD3”
; ----------------------------------------------------------------------
FADD3:	xor	a		;0754
	sub	b		;0755
	ld	b,a		;0756
	ld	a,(hl)		;0757
	sbc	a,e		;0758
	ld	e,a		;0759
	inc	hl		;075a
	ld	a,(hl)		;075b
	sbc	a,d		;075c
	ld	d,a		;075d
	inc	hl		;075e
	ld	a,(hl)		;075f
	sbc	a,c		;0760
	ld	c,a		;0761
FADFLT:	call	c,NGER		;0762
NORMAL:	ld	l,b		;0765
	ld	h,e		;0766
	xor	a		;0767
NORM1:	ld	b,a		;0768
	ld	a,c		;0769
	or	a		;076a
	jr	nz,NORM3	;076b
	ld	c,d		;076d
	ld	d,h		;076e
	ld	h,l		;076f
	ld	l,a		;0770
	ld	a,b		;0771
	sub	$08		;0772
	cp	$E0		;0774
	jr	nz,NORM1	;0776
ZERO:	xor	a		;0778
ZERO0:	ld	(FAC),a		;0779
	ret			;077c
; ----------------------------------------------------------------------
; 077DH-07A7H – SINGLE PRECISION MATH SUPPORT ROUTINE – “NORM2”
; ----------------------------------------------------------------------
NORM2:	dec	b		;077d
	add	hl,hl		;077e
	ld	a,d		;077f
	rla			;0780
	ld	d,a		;0781
	ld	a,c		;0782
	adc	a,a		;0783
	ld	c,a		;0784
NORM3:	jp	p,NORM2		;0785
	ld	a,b		;0788
	ld	e,h		;0789
	ld	b,l		;078a
	or	a		;078b
	jr	z,ROUND		;078c
	ld	hl,FAC		;078e
	add	a,(hl)		;0791
	ld	(hl),a		;0792
	jr	nc,ZERO		;0793
	ret	z		;0795
; ----------------------------------------------------------------------
; 0796H-07A7H – SINGLE PRECISION MATH ROUTINE – “ROUND”
; The "ROUND" routine rounds the result in CDEB and puts the result into the ACCumulator.
; All registers are affected. CDE is rounded up or down based on the MSB of Register B.
; ----------------------------------------------------------------------
ROUND:	ld	a,b		;0796
ROUNDB:	ld	hl,FAC		;0797
	or	a		;079a
	call	m,ROUNDA	;079b
	ld	b,(hl)		;079e
	inc	hl		;079f
	ld	a,(hl)		;07a0
	and	$80		;07a1
	xor	c		;07a3
	ld	c,a		;07a4
	jp	MOVFR		;07a5
; ----------------------------------------------------------------------
; 07A8H-07B6H – SINGLE PRECISION MATH SUPPORT ROUTINE – “ROUNDA”
;   This is a subroutine within the ROUND round. This will add one to C/D/E.
; ----------------------------------------------------------------------
ROUNDA:	inc	e		;07a8
	ret	nz		;07a9
	inc	d		;07aa
	ret	nz		;07ab
	inc	c		;07ac
	ret	nz		;07ad
	ld	c,$80		;07ae
	inc	(hl)		;07b0
	ret	nz		;07b1
; ----------------------------------------------------------------------
; 07B2H – ?OV ERROR ENTRY POINT – “OVERR”
; ----------------------------------------------------------------------
OVERR:	ld	e,ERROV		;07b2
	jp	ERROR		;07b4
; ----------------------------------------------------------------------
; 07B7H-07C2H SINGLE PRECISION MATH ROUTINE – “FADDA”
;   This routine adds (HL+2),)(HL+1),(HL+0) to C,D,E.
; ----------------------------------------------------------------------
FADDA:	ld	a,(hl)		;07b7
	add	a,e		;07b8
	ld	e,a		;07b9
	inc	hl		;07ba
	ld	a,(hl)		;07bb
	adc	a,d		;07bc
	ld	d,a		;07bd
	inc	hl		;07be
	ld	a,(hl)		;07bf
	adc	a,c		;07c0
	ld	c,a		;07c1
	ret			;07c2
; ----------------------------------------------------------------------
; 07C3H-07D6H – SINGLE PRECISION MATH ROUTINE – NEGR
;   This routine negates the number in C/D/E/B.
; ----------------------------------------------------------------------
NGER:	ld	hl,FACSGN	;07c3
	ld	a,(hl)		;07c6
	cpl			;07c7
	ld	(hl),a		;07c8
	xor	a		;07c9
	ld	l,a		;07ca
	sub	b		;07cb
	ld	b,a		;07cc
	ld	a,l		;07cd
	sbc	a,e		;07ce
	ld	e,a		;07cf
	ld	a,l		;07d0
	sbc	a,d		;07d1
	ld	d,a		;07d2
	ld	a,l		;07d3
	sbc	a,c		;07d4
	ld	c,a		;07d5
	ret			;07d6
; ----------------------------------------------------------------------
; 07D7H-07F7H – SINGLE PRECISION MATH ROUTINE – “SHIFTR”
;   This routine will shift the number in C/D/E right the number of times
;   held in Register A. The general idea is to shift right 8 places
;   as many times as is possible within the number of times in A,
;   and then jump out to shift single bits once you can't shift 8
;   at a time anymore. Alters everything except Register H.
; ----------------------------------------------------------------------
SHIFTR:	ld	b,$00		;07d7
SHIFTR1: sub	$08		;07d9
	jr	c,SHFTR2	;07db
	ld	b,e		;07dd
	ld	e,d		;07de
	ld	d,c		;07df
	ld	c,$00		;07e0
	jr	SHIFTR1		;07e2
; ----------------------------------------------------------------------
; 07E4 – SINGLE PRECISION MATH ROUTINE – “SHFTR2”
;   This routine will shift the number in C/D/E right the number
;   of times held in Register A, but one byte at a time.
; ----------------------------------------------------------------------
SHFTR2:	add	a,$09		;07e4
	ld	l,a		;07e6
SHFTR3:	xor	a		;07e7
	dec	l		;07e8
	ret	z		;07e9
	ld	a,c		;07ea
SHRADD:	rra			;07eb
	ld	c,a		;07ec
	ld	a,d		;07ed
	rra			;07ee
	ld	d,a		;07ef
	ld	a,e		;07f0
	rra			;07f1
	ld	e,a		;07f2
	ld	a,b		;07f3
	rra			;07f4
	ld	b,a		;07f5
	jr	SHFTR3		;07f6
;
; ----------------------------------------------------------------------
; 07F8H-07FBH – SINGLE PRECISION CONSTANT STORAGE LOCATION – “FONE”
; ----------------------------------------------------------------------
FONE:	.DB	0, 0, 0, $81	; store a value of 1.0
;
; ----------------------------------------------------------------------
; 07FCH-0808H – SINGLE PRECISION CONSTANTS STORAGE LOCATION 2 – “LOGCN2”
; ----------------------------------------------------------------------
LOGCN2:	.DB	3			; count of numbers in table
	.DB	$AA, $56, $19, $80	; 0.598978650
	.DB	$F1, $22, $76, $80	; 0.961470632
	.DB	$45, $AA, $38, $82	; 2.88539129
;
; ======================================================================
; 0809H – LEVEL II BASIC LOG ROUTINE – “FNLOG”
;
;   Computes the natural log (base E) of the single precision value in
;   WRA1. The result is returned as a single precision value in WRA1.
; ----------------------------------------------------------------------
FNLOG:	call	SIGN		;0809
	or	a		;080c
	jp	pe,FCERR	;080d
	ld	hl,FAC		;0810
	ld	a,(hl)		;0813
	ld	bc,$8035	;0814
	ld	de,$04F3	;0817
	sub	b		;081a
	push	af		;081b
	ld	(hl),b		;081c
	push	de		;081d
	push	bc		;081e
	call	FADD		;081f
	pop	bc		;0822
	pop	de		;0823
	inc	b		;0824
	call	FDIV		;0825
	ld	hl,FONE		;0828
	call	FSUBS		;082b
	ld	hl,LOGCN2	;082e
	call	POLYX		;0831
	ld	bc,$8080	;0834
	ld	de,$0000	;0837
	call	FADD		;083a
	pop	af		;083d
	call	FINLOG		;083e
MULLN2:	ld	bc,$8031	;0841
	ld	de,$7218	;0844
; fall into the MULTiplocation routine.
;
; ======================================================================
; 0847H – LEVEL II BASIC SINGLE PRECISION MULTIPLICATION, – “FMULT”
;
;   Single-precision multiplication (ACCumulator=BCDE*ACC or ACC = ARG * FAC)).
;   Multiplies the current value in the ACCumulator by the value in (BC/DE).
;   the product is left in the ACCumulator.
; ----------------------------------------------------------------------
FMULT:	call	SIGN		;0847
	ret	z		;084a
	ld	l,$00		;084b
	call	MULDIV		;084d
	ld	a,c		;0850
	ld	(FMLTT1),a	;0851
	ex	de,hl		;0854
	ld	(FMLTT2),hl	;0855
	ld	bc,$0000	;0858
	ld	d,b		;085b
	ld	e,b		;085c
	ld	hl,NORMAL	;085d
	push	hl		;0860
	ld	hl,FMULT2	;0861
	push	hl		;0864
	push	hl		;0865
	ld	hl,FACLO	;0866
FMULT2:	ld	a,(hl)		;0869
	inc	hl		;086a
	or	a		;086b
	jr	z,FMULT3	;086c
	push	hl		;086e
	ld	l,$08		;086f
FMULT4:	rra			;0871
	ld	h,a		;0872
	ld	a,c		;0873
	jr	nc,FMULT5	;0874
	push	hl		;0876
	ld	hl,(FMLTT2)	;0877
	add	hl,de		;087a
	ex	de,hl		;087b
	pop	hl		;087c
	ld	a,(FMLTT1)	;087d
	adc	a,c		;0880
FMULT5:	rra			;0881
	ld	c,a		;0882
	ld	a,d		;0883
	rra			;0884
	ld	d,a		;0885
	ld	a,e		;0886
	rra			;0887
	ld	e,a		;0888
	ld	a,b		;0889
	rra			;088a
	ld	b,a		;088b
	dec	l		;088c
	ld	a,h		;088d
	jr	nz,FMULT4	;088e
POPHRT:	pop	hl		;0890
	ret			;0891
; ----------------------------------------------------------------------
; 0892H-0896H – SINGLE PRECISION MATH ROUTINE – “FMULT3”
;   This is accomplished by a circular shift of BC/DE one byte
;   B is lost, C is replaced by A
; ----------------------------------------------------------------------
FMULT3:	ld	b,e		;0892
	ld	e,d		;0893
	ld	d,c		;0894
	ld	c,a		;0895
	ret			;0896
;
; ----------------------------------------------------------------------
; 0897H-08A1H – SINGLE PRECISION MATH ROUTINE – “DIV10”
;   This routine divides the ACCumulator by 10. Every Register is used.
; ----------------------------------------------------------------------
DIV10:	call	PUSHF		;0897
	ld	hl,FTEN		;089a
	call	MOVFM		;089d
FDIVT:	pop	bc		;08a0
	pop	de		;08a1
; ----------------------------------------------------------------------
; 08A2H-0903H – LEVEL II BASIC SINGLE PRECISION DIVISION – “FDIV”
;   Single-precision division (ACCumulator=BCDE/ACCumulator or
;   ACC = ARG / ACC). If ACCumulator=0 a ” /0 ERROR ” will result.
; ----------------------------------------------------------------------
FDIV:	call	SIGN		;08a2
	jp	z,DV0ERR	;08a5
	ld	l,$FF		;08a8
	call	MULDIV		;08aa
	inc	(hl)		;08ad
	inc	(hl)		;08ae
	dec	hl		;08af
	ld	a,(hl)		;08b0
	ld	(FDIVA+1),a	;08b1
	dec	hl		;08b4
	ld	a,(hl)		;08b5
	ld	(FDIVB+1),a	;08b6
	dec	hl		;08b9
	ld	a,(hl)		;08ba
	ld	(FDIVC+1),a	;08bb
	ld	b,c		;08be
	ex	de,hl		;08bf
	xor	a		;08c0
	ld	c,a		;08c1
	ld	d,a		;08c2
	ld	e,a		;08c3
	ld	(FDIVG+1),a	;08c4
FDIV1:	push	hl		;08c7
	push	bc		;08c8
	ld	a,l		;08c9
	call	FDIVC		;08ca - subtraction rountine in RAM buffer
	sbc	a,$00		;08cd
	ccf			;08cf
	jr	nc,FDIV2	;08d0
	ld	(FDIVG+1),a	;08d2
	pop	af		;08d5
	pop	af		;08d6
;
	scf			;08d7 - Z80 Trick - Set Carry Flag
	.DB	JPNCNN		;08d8 - JP NC,nnnn - skip next 2 instruction
;
FDIV2:	pop	bc		;08d9
	pop	hl		;08da
	ld	a,c		;08db
	inc	a		;08dc
	dec	a		;08dd
	rra			;08de
	jp	m,ROUNDB	;08df
	rla			;08e2
	ld	a,e		;08e3
	rla			;08e4
	ld	e,a		;08e5
	ld	a,d		;08e6
	rla			;08e7
	ld	d,a		;08e8
	ld	a,c		;08e9
	rla			;08ea
	ld	c,a		;08eb
	add	hl,hl		;08ec
	ld	a,b		;08ed
	rla			;08ee
	ld	b,a		;08ef
	ld	a,(FDIVG+1)	;08f0
	rla			;08f3
	ld	(FDIVG+1),a	;08f4
	ld	a,c		;08f7
	or	d		;08f8
	or	e		;08f9
	jr	nz,FDIV1	;08fa
	push	hl		;08fc
	ld	hl,FAC		;08fd
	dec	(hl)		;0900
	pop	hl		;0901
	jr	nz,FDIV1	;0902
	jp	OVERR		;0904
; ----------------------------------------------------------------------
; 0907H-0913H – DOUBLE PRECISION MATH ROUTINE – “MULDVS”
;   This routine is to check for special cases and to add exponents for
;   the FMULT and FDIV routines. Registers A, B, H and L are modified.
; ----------------------------------------------------------------------
MULDVS:	ld	a,$FF		;0907
;
	.DB	LDLNN		;0909 - Z80 Trick - LD L,nn - skip next instruction
;
MULDVA:	xor	a		;090a
	ld	hl,ARG-1	;090b
	ld	c,(hl)		;090e
	inc	hl		;090f
	xor	(hl)		;0910
	ld	b,a		;0911
	ld	l,$00		;0912
; ----------------------------------------------------------------------
; 0914H-0930H – SINGLE PRECISION MATH ROUTINE – “MULDIV”
; ----------------------------------------------------------------------
MULDIV:	ld	a,b		;0914
	or	a		;0915
	jr	z,MULDV2	;0916
	ld	a,l		;0918
	ld	hl,FAC		;0919
	xor	(hl)		;091c
	add	a,b		;091d
	ld	b,a		;091e
	rra			;091f
	xor	b		;0920
	ld	a,b		;0921
	jp	p,MULDV1	;0922
	add	a,$80		;0925
	ld	(hl),a		;0927
	jp	z,POPHRT	;0928
	call	UNPACK		;092b
	ld	(hl),a		;092e
DCXHRT:	dec	hl		;092f
	ret			;0930
; ----------------------------------------------------------------------
; 0931H-093DH – SINGLE PRECISION MATH ROUTINE – “MLDVEX”
;   This routine is called from EXP. If jumped here will checks if ACC=0.
;   If so, the Z flag will be set
; ----------------------------------------------------------------------
MLDVEX:	call	SIGN		;0931
	cpl			;0934
	pop	hl		;0935
MULDV1:	or	a		;0936
MULDV2:	pop	hl		;0937
	jp	p,ZERO		;0938
	jp	OVERR		;093b
; ----------------------------------------------------------------------
; 093EH-0954H – SINGLE PRECISION MATH ROUTINE – “MUL10”
;   This routine multiplies the ACCumulator by 10. Every register is modified.
; ----------------------------------------------------------------------
MUL10:	call	MOVRF		;093e
	ld	a,b		;0941
	or	a		;0942
	ret	z		;0943
	add	a,$02		;0944
	jp	c,OVERR		;0946
	ld	b,a		;0949
	call	FADD		;094a
	ld	hl,FAC		;094d
	inc	(hl)		;0950
	ret	nz		;0951
	jp	OVERR		;0952
; ----------------------------------------------------------------------
; 0955H-0963H – SINGLE PRECISION MATH ROUTINE – “SIGN”
;   Puts the SIGN of the ACCumulator into Register A.
;   Only Register A is modified by this routine;
;   the ACCumulator is left untouched.
; ----------------------------------------------------------------------
SIGN:	ld	a,(FAC)		;0955
	or	a		;0958
	ret	z		;0959
	ld	a,(FAC-1)	;095a
;
	.DB	CPNN		;095d - Z80 Trick - CP nn - skip next bytye
;
FCOMPS:	cpl			;095e
ICOMPS:	rla			;095f
SIGNS:	sbc	a,a		;0960
	ret	nz		;0961
	inc	a		;0962
	ret			;0963
; ----------------------------------------------------------------------
; 0964H-0976H – MATH CONVERSION ROUTINE – “FLOAT”
;   This routine will take a signed integer held in Register A and
;   turn it into a floating point number. All registers are modified.
; ----------------------------------------------------------------------
FLOAT:	ld	b,$88		;0964
	ld	de,$0000	;0966
FLOATR:	ld	hl,FAC		;0969
	ld	c,a		;096c
	ld	(hl),b		;096d
	ld	b,$00		;096e
	inc	hl		;0970
	ld	(hl),$80	;0971
	rla			;0973
	jp	FADFLT		;0974
;
; ======================================================================
; 0977H – LEVEL II BASIC ABS() ROUTINE – “FNABS”
;
;   ABS routine (ACCumulator=ABS(ACCumulator)) input and output can be integer,
;   single-precision or double-precision, depending on what is placed in the NTF
; ----------------------------------------------------------------------
FNABS:	call	VSIGN		;0977
	ret	p		;097a
VNEG:	TSTDAT			;097b
	jp	m,INEG		;097c
	jp	z,TMERR		;097f
NNEG:	ld	hl,FAC-1	;0982
	ld	a,(hl)		;0985
	xor	$80		;0986
	ld	(hl),a		;0988
	ret			;0989
;
; ----------------------------------------------------------------------
; 098AH-0993H – LEVEL II BASIC SGN() ROUTINE – “FNSGN”
;   SGN function (ACCumulator=SGN(ACCumulator)). After execution, NTF=2
;   and ACCumulator=-l, 0 or 1 depending on sign and value of ACC before
;   execution. Registers A, H, and L are affected.
; ----------------------------------------------------------------------
FNSGN:	call	VSIGN		;098a
CONIA:	ld	l,a		;098d
	rla			;098e
	sbc	a,a		;098f
	ld	h,a		;0990
	jp	MAKINT		;0991
;
; ----------------------------------------------------------------------
; 0994H-09A3H – MATH ROUTINE – “VSIGN”
;   This routine checks the sign of the ACCumulator. NTF must be set.
;   After execution A register=00 if ACCumulator=0, A=01 if ACC > 0
;   or A=FFH if A < 1. The Flags are also valid.
; ----------------------------------------------------------------------
VSIGN:	TSTDAT			;0994
	jp	z,TMERR		;0995
	jp	p,SIGN		;0998
	ld	hl,(FACLO)	;099b
;
ISIGN:	ld	a,h		;099e
	or	l		;099f
	ret	z		;09a0
	ld	a,h		;09a1
	jr	ICOMPS		;09a2
; ----------------------------------------------------------------------
; 09A4H-09B0H – SINGLE PRECISION MATH ROUTINE – “PUSHF” - MOVE
;   Moves the single precision value in the ACCumulator to the STACK
;   It is Assumed that ACCumulator contains a single precision value
;   A, BC and HL are unchanged by this function.
; ----------------------------------------------------------------------
PUSHF:	ex	de,hl		;09a4
	ld	hl,(FACLO)	;09a5
	ex	(sp),hl		;09a8
	push	hl		;09a9
	ld	hl,(FAC-1)	;09aa
	ex	(sp),hl		;09ad
	push	hl		;09ae
	ex	de,hl		;09af
	ret			;09b0
;
; ----------------------------------------------------------------------
; 09B1H-09BEH – SINGLE PRECISION MATH ROUTINE – “MOVFM” - MOVE
;   This routine moves a number from memory (pointed to by HL) into the ACC
;   All registers except Register A are affected, with HL = HL + 4 on exit.
; ----------------------------------------------------------------------
MOVFM:	call	MOVRM		;09b1
; ----------------------------------------------------------------------
; 09B4H – SINGLE PRECISION MATH ROUTINE – “MOVFR” - MOVE
;   Store the single precision value in BC:DE into ACC. Destroys value in BC:DE.
; ----------------------------------------------------------------------
MOVFR:	ex	de,hl		;09b4
	ld	(FACLO),hl	;09b5
	ld	h,b		;09b8
	ld	l,c		;09b9
	ld	(FAC-1),hl	;09ba
	ex	de,hl		;09bd
	ret			;09be
; ----------------------------------------------------------------------
; 09BFH-09CAH – SINGLE PRECISION MATH ROUTINE – “MOVRF” - MOVE
;   It loads four bytes from ACCumulator (single) into the BC/DE Register Pairs.
;   Only Register A is unchanged.
; ----------------------------------------------------------------------
MOVRF:	ld	hl,FACLO	;09bf
; ----------------------------------------------------------------------
; 09C2H – SINGLE PRECISION MATH ROUTINE – “MOVRM” - MOVE
;   It loads four byte Single, pointed by HL, into the BC/DE Register Pairs.
;   Only Register A is unchanged.
; ----------------------------------------------------------------------
MOVRM:	ld	e,(hl)		;09c2
	inc	hl		;09c3
GETBCD:	ld	d,(hl)		;09c4
	inc	hl		;09c5
	ld	c,(hl)		;09c6
	inc	hl		;09c7
	ld	b,(hl)		;09c8
INXHRT:	inc	hl		;09c9
	ret			;09ca
; ----------------------------------------------------------------------
; 09CBH-09D1H – SINGLE PRECISION MATH ROUTINE – “MOVMF” - MOVE
;   Copy a Single Precision value from ACCumulator to memory address
;   pointed to by HL. Modifies all Registers except for C
; ----------------------------------------------------------------------
MOVMF:	ld	de,FACLO	;09cb
; ----------------------------------------------------------------------
; 09CEH – SINGLE PRECISION MATH ROUTINE – “MOVE” - MOVE
;   Copy a Single Precision value from from the location pointed to by DE
;   into the location pointed to by HL. Modifies all Registers except for C
; ----------------------------------------------------------------------
MOVE:	ld	b,VTSNG		;09ce - Move 4 bytes
	jr	MOVE1		;09d0
; ----------------------------------------------------------------------
; 09D2H-09DEH – MOVE VALUE FROM DE TO HL - “MOVVFM”
;   moves the number of bytes specified in the variable type flag
;   from the address in DE to the address in HL. Uses A, B, DE and HL.
; ----------------------------------------------------------------------
MOVVFM:	ex	de,hl		;09d2
; ----------------------------------------------------------------------
; 09D3H – MOVE VALUE FROM HL TO DE - “VMOVE”
;   moves the number of bytes specified in the variable type flag
;   from the address in HL to the address in DE. Uses A, B, DE and HL.
; ----------------------------------------------------------------------
VMOVE:	ld	a,(VALTYP)	;09d3
	ld	b,a		;09d6
; ----------------------------------------------------------------------
; 09D7H – MOVE VALUE FROM HL TO DE - “MOVE1”
;   moves the number of bytes specified in B register
;   from the address in HL to the address in DE. Uses A, B, DE and HL.
; ----------------------------------------------------------------------
MOVE1:	ld	a,(de)		;09d7
	ld	(hl),a		;09d8
	inc	de		;09d9
	inc	hl		;09da
	dec	b		;09db
	jr	nz,MOVE1	;09dc
	ret			;09de
; ----------------------------------------------------------------------
; 09DFH-09F3H – SINGLE PRECISION MATH ROUTINE – “UNPACK”
;   This routine “UNPACKS” the ACCumulator and the Registers.
;   Registers A, C, H, and L are altered.
; ----------------------------------------------------------------------
UNPACK:	ld	hl,FAC-1	;09df
	ld	a,(hl)		;09e2
	rlca			;09e3
	scf			;09e4
	rra			;09e5
	ld	(hl),a		;09e6
	ccf			;09e7
	rra			;09e8
	inc	hl		;09e9
	inc	hl		;09ea
	ld	(hl),a		;09eb
	ld	a,c		;09ec
	rlca			;09ed
	scf			;09ee
	rra			;09ef
	ld	c,a		;09f0
	rra			;09f1
	xor	(hl)		;09f2
	ret			;09f3
; ----------------------------------------------------------------------
; 09F4H-09FBH – MOVE FROM ACCUM2 TO ACCUM – “VMOVFA”
;   Copy any precision value from ACCUM2 to ACCUM.
;   Precision and number of bytes moved determined by NTF.
; ----------------------------------------------------------------------
VMOVFA:	ld	hl,ARGLO	;09f4
; ----------------------------------------------------------------------
; 09F7 – MOVE FROM (HL) TO ACCUM – “VMOVFA”
;   Copy any precision value from address pointed to by HL to ACCUM
;   Precision and number of bytes moved determined by NTF.
; ----------------------------------------------------------------------
VMOVFM:	ld	de,MOVVFM	;09f7
	jr	VMOVMF		;09fa
; ----------------------------------------------------------------------
; 09FCH-0A0BH – MOVE FROM ACCUM TO ACCUM2 – “VMOVAF”
;   Copy any precision value from ACCUM to ACCUM2.
;   Precision and number of bytes moved determined by NTF.
;   All Registers except C are affected.
; ----------------------------------------------------------------------
VMOVAF:	ld	hl,ARGLO	;09fc
; ----------------------------------------------------------------------
; 09FFH – MOVE FROM ACCUM TO (HL) – “VMOVAF”
;   Copy any precision value from ACCUM to address pointed to by HL.
;   Precision and number of bytes moved determined by NTF.
;   All Registers except C are affected.
; ----------------------------------------------------------------------
	ld	de,VMOVE	;09ff
VMOVMF:	push	de		;0a02
VDFACS:	ld	de,FACLO	;0a03
	TSTDAT			;0a06
	ret	c		;0a07
	ld	de,DFACLO	;0a08
	ret			;0a0b
;
; ======================================================================
; 0A0CH – LEVEL II BASIC SINGLE PRECISION COMPARE – “FCOMP”
;
;   This routine will compare two single precision numbers.
;   On Exit, A=1 if ARG < ACCumulator, A=0 if ARG=Accmulator,
;   and A=-1 if ARG > ACCumulator. This routine exits with the CF on.
;   Alters Registers A, H, and L.
; ----------------------------------------------------------------------
FCOMP:	ld	a,b		;0a0c
	or	a		;0a0d
	jp	z,SIGN		;0a0e
	ld	hl,FCOMPS	;0a11 - Load Register Pair HL with a return address to the FCOMPS routine
	push	hl		;0a14
	call	SIGN		;0a15
	ld	a,c		;0a18
	ret	z		;0a19
	ld	hl,FAC-1	;0a1a
	xor	(hl)		;0a1d
	ld	a,c		;0a1e
	ret	m		;0a1f
	call	FCOMP2		;0a20
FCOMPD:	rra			;0a23
	xor	c		;0a24
	ret			;0a25
; ----------------------------------------------------------------------
; 0A26H-0A38H – Part of the single precision comparison routine – “FCOMP2”
; ----------------------------------------------------------------------
FCOMP2:	inc	hl		;0a26
	ld	a,b		;0a27
	cp	(hl)		;0a28
	ret	nz		;0a29
	dec	hl		;0a2a
	ld	a,c		;0a2b
	cp	(hl)		;0a2c
	ret	nz		;0a2d
	dec	hl		;0a2e
	ld	a,d		;0a2f
	cp	(hl)		;0a30
	ret	nz		;0a31
	dec	hl		;0a32
	ld	a,e		;0a33
	sub	(hl)		;0a34
	ret	nz		;0a35
	pop	hl		;0a36
	pop	hl		;0a37
	ret			;0a38
;
; ======================================================================
; 0A39H – LEVEL II BASIC INTEGER COMPARISON ROUTINE – “ICOMP”
;
;   Integer compare. Compares HL with DE. After execution, A=0 if HL=DE,
;   A=1 if HL>DE or A=FFH if HL<DE. The S and Z flags are valid.
; ----------------------------------------------------------------------
ICOMP:	ld	a,d		;0a39
	xor	h		;0a3a
	ld	a,h		;0a3b
	jp	m,ICOMPS	;0a3c
	cp	d		;0a3f
	jp	nz,SIGNS	;0a40
	ld	a,l		;0a43
	sub	e		;0a44
	jp	nz,SIGNS	;0a45
	ret			;0a48
; ----------------------------------------------------------------------
; 0A49H-0A77H – DOUBLE PRECISION COMPARISON ROUTINE – “DCOMPD”
;   Double-precision compare. Compares ACCumulator with the ARG
;   (a/k/a REG 2). After execution the A Register will contain:
;   A=0 if ACCumulator=ARG (a/k/a REG 2), A=1 if ACC > ARG (a/k/a REG 2)
;   or A=FFH if ACC < ARG (a/k/a REG 2). S and Z flags are valid.
; ----------------------------------------------------------------------
DCOMPD:	ld	hl,ARGLO	;0a49
	call	VMOVE		;0a4c
XDCOMP:	ld	de,ARG		;0a4f
	ld	a,(de)		;0a52
	or	a		;0a53
	jp	z,SIGN		;0a54
	ld	hl,FCOMPS	;0a57
	push	hl		;0a5a
	call	SIGN		;0a5b
	dec	de		;0a5e
	ld	a,(de)		;0a5f
	ld	c,a		;0a60
	ret	z		;0a61
	ld	hl,FAC-1	;0a62
	xor	(hl)		;0a65
	ld	a,c		;0a66
	ret	m		;0a67
	inc	de		;0a68
	inc	hl		;0a69
	ld	b,$08		;0a6a
DCOMP1:	ld	a,(de)		;0a6c
	sub	(hl)		;0a6d
	jp	nz,FCOMPD	;0a6e
	dec	de		;0a71
	dec	hl		;0a72
	dec	b		;0a73
	jr	nz,DCOMP1	;0a74
	pop	bc		;0a76
	ret			;0a77
;
; ======================================================================
; 0A78H – LEVEL II BASIC DOUBLE PRECISION COMPARE – “DCOMP”
;
;   this routine will compare
;   two double precision numbers, but is the opposite of the ICOMP, FCOMP,
;   and XDCOMP routines. This one swaps ARC and ACC, so on Exit,
;   A=1 if ARG > ACCumulator, A=0 if ARG=Accmulator, and A=-1
;   if ARG < ACCumulator. Every register is affected.
; ----------------------------------------------------------------------
DCOMP:	call	XDCOMP		;0a78
	jp	nz,FCOMPS	;0a7b
	ret			;0a7e
;
; ======================================================================
; 0A7FH – LEVEL II BASIC CINT ROUTINE – “FRCINT” - MATH CONVERSION ROUTINE
;
;   CINT routine. Takes a value from ACC, converts it to an integer value
;   and puts it back into the ACC. On completion, the HL Register Pair
;   contains the LSB of the integer value, and the NTF contains 2
;   (Integer=2). If NTF=3 (string) a TM ERROR will be generated and control
;   will be passed to BASIC. Every register is affected. No rounding is performed
; ----------------------------------------------------------------------
FRCINT:	TSTDAT			;0a7f - check the value of the current number type
	ld	hl,(FACLO)	;0a80 - in case an int, Load HL with the integer
	ret	m		;0a83 - If an INTEGER, then return HL
	jp	z,TMERR		;0a84 - If a STRING, Display a ?TM ERROR
;
#IFDEF BUGFIX5
;
	.ECHO	" BUGFIX5 - ROM Error 5 Patched \n"
	NOP3
#ELSE
; If double-precision (NC flag set based on type), call the subroutine at 0AB9H
; (a sign/compare or CSNG entry point), which converts double to single-precision
; with rounding to nearest (standard IEEE-like behavior in TRS-80 floating-point,
; adding 0.5 in mantissa before truncating lower bits. This rounding happens before
; truncation, causing values like 2.9999999# to become 3.0 in single-precision,
; and then INT(3.0) = 3. For single-precision or integer inputs, no call is made,
; and direct truncation occurs (correct behavior).
; CREDIT : Ira Goldklang
;
	call	nc,CONSD	;0a87 - If Double, Convert to single precision
#ENDIF
	ld	hl,OVERR	;0a8a - Just in case the number is too big,
	push	hl		;0a8d - RET to the ?OV ERROR, pushed onto stack.
;
; ----------------------------------------------------------------------
; 0A8EH – MATH CONVERSION ROUTINE – “CONIS”
;   This routine will convert a single precision number to an integer.
;   Every register is affected.
; ----------------------------------------------------------------------
CONIS:	ld	a,(FAC)		;0a8e
	cp	$90		;0a91
	jr	nc,CONIS2	;0a93
	call	QINT		;0a95
	ex	de,hl		;0a98
CONIS1:	pop	de		;0a99
; ----------------------------------------------------------------------
; 0A9AH - LEVEL II BASIC CONVERSION ROUTINE - "MAKINT" - MOVE
;   This is the routine that returns the value in the HL Register Pair
;   to the BASIC program that called it. In effect it moves the content
;   of HL into the ACCumulator so it is ACCumulator = (HL)
;   with VALTYPE set accordingly
; ----------------------------------------------------------------------
MAKINT:	ld	(FACLO),hl	;0a9a
; ----------------------------------------------------------------------
; 0A9DH - Set NTF to INTEGER
; ----------------------------------------------------------------------
VALINT:	ld	a,VTINT		;0a9d - Value type INTeger
CONISD:	ld	(VALTYP),a	;0a9f
	ret			;0aa2
; ----------------------------------------------------------------------
; 0AA3H – MATH CONVERSION ROUTINE – “CONIS2”
;   This routine’s purpose is to check to see if a number from the FIN routine is -32768.
; ----------------------------------------------------------------------
CONIS2:	ld	bc,$9080	;0aa3
	ld	de,$0000	;0aa6
	call	FCOMP		;0aa9
	ret	nz		;0aac
	ld	h,c		;0aad
	ld	l,d		;0aae
	jr	CONIS1		;0aaf
;
; ======================================================================
; 0AB1H – LEVEL II BASIC CSNG ROUTINE – “FRCSNG”
;
;   Force the number in the ACCumulator to be a single-precision number.
;   Every register is affected.
; ----------------------------------------------------------------------
FRCSNG:	TSTDAT			;0ab1
	ret	po		;0ab2
	jp	m,CONSI		;0ab3
	jp	z,TMERR		;0ab6
;
; ----------------------------------------------------------------------
; 0AB9 – MATH CONVERSION ROUTINE – “CONSD”
;  Convert a double-precision number to single-precision.
;  Every register is affected.
; ----------------------------------------------------------------------
CONSD:	call	MOVRF		;0ab9 - Move the HIGH ORDER/MSB's into Register Pair BC/DE
	call	VALSNG		;0abc - set number type to single precision
	ld	a,b		;0abf - check for zero, first load the exponent
	or	a		;0ac0 - set flags
	ret	z		;0ac1 - exponent zero, number zero, return
	call	UNPACK		;0ac2 - turn on the MSB of the single in the ACCumulator
	ld	hl,FACLO-1	;0ac5 - chop off the MSB of double double precision
	ld	b,(hl)		;0ac8 - chopped number, the ROUND routine expects
	jp	ROUND		;0ac9 - round the chopped number up and RETurn
;
; ----------------------------------------------------------------------
; 0ACCH-0ADAH - MATH CONVERSION ROUTINE – “CONSI”
;   Convert Integer to Single Precision. Every register is affected.
; ----------------------------------------------------------------------
CONSI:	ld	hl,(FACLO)	;0acc
; ----------------------------------------------------------------------
;   Convert Integer (Passed in HL) to Single Precision
; ----------------------------------------------------------------------
CONSIH:	call	VALSNG		;0acf
	ld	a,h		;0ad2
	ld	d,l		;0ad3
	ld	e,$00		;0ad4
	ld	b,$90		;0ad6
	jp	FLOATR		;0ad8
;
; ======================================================================
; 0ADBH – LEVEL II BASIC CDBL ROUTINE – “FRCDBL”
;
;   CDBL routine. Takes a value from ACCumulator (regardless of integer
;   or single precision) and convert it to double-precision.
;   The result will be in ACC and NTF will be 8.
; ----------------------------------------------------------------------
FRCDBL:	TSTDAT			;0adb
	ret	nc		;0adc
	jp	z,TMERR		;0add
	call	m,CONSI		;0ae0
;
; ----------------------------------------------------------------------
; 0AE3H – LEVEL II BASIC CDBL ROUTINE – “CONDS” -  MATH CONVERSION ROUTINE
;   Convert a single precision number to double. Modifies A, H, and L.
; ----------------------------------------------------------------------
CONDS:	ld	hl,$0000	;0ae3
	ld	(DFACLO),hl	;0ae6
	ld	(DFACLO+2),hl	;0ae9
; ----------------------------------------------------------------------
; 0AECH - Set NTF to DOUBLE
; ----------------------------------------------------------------------
VALDBL:	ld	a,VTDBL		;0aec - Double Value Type
;
; ----------------------------------------------------------------------
; 0AEEH-0AF3H – MATH ROUTINE – “VALSNG”
; ----------------------------------------------------------------------
;
	.DB	LDBCNN		;0aee - Z80 Trick LD BC,nnnn - skip next 2 byte instruction
;
; ----------------------------------------------------------------------
; 0AEFH - Set NTF to SINGLE
; ----------------------------------------------------------------------
VALSNG:	ld	a,VTSNG		;0aef - single precision number type flag (of 4)
	jp	CONISD		;0af1
;
; ----------------------------------------------------------------------
; 0AF4H-0AFAH – LEVEL II BASIC STRING CONVERSION ROUTINE – “CHKSTR”
;   This routine calls 20H (RST 20H) and returns if NTF=3 (string) else if NTF is not 3
;   then it generates a TM ERROR. BC, DE, and HL are saved
; ----------------------------------------------------------------------
CHKSTR:	TSTDAT			;0af4
	ret	z		;0af5
;
; ----------------------------------------------------------------------
; 0AF6H – ?TM ERROR ENTRY POINT – “TMERR”
; ----------------------------------------------------------------------
TMERR:	ld	e,ERRTM		;0af6
	jp	ERROR		;0af8
;
; ----------------------------------------------------------------------
; 0AFBH-0B1EH – MATH ROUTINE – “QINT”
;   This routine is a quick “Greatest Integer” function. Registers A-E are affected.
;   The result of INT(ACCumulator) is left in BC DE as a signed number
; ----------------------------------------------------------------------
QINT:	ld	b,a		;0afb
	ld	c,a		;0afc
	ld	d,a		;0afd
	ld	e,a		;0afe
	or	a		;0aff
	ret	z		;0b00
	push	hl		;0b01
	call	MOVRF		;0b02
	call	UNPACK		;0b05
	xor	(hl)		;0b08
	ld	h,a		;0b09
	call	m,QINTA		;0b0a
	ld	a,$98		;0b0d
	sub	b		;0b0f
	call	SHIFTR		;0b10
	ld	a,h		;0b13
	rla			;0b14
	call	c,ROUNDA	;0b15
	ld	b,$00		;0b18
	call	c,NGER		;0b1a
	pop	hl		;0b1d
	ret			;0b1e
; ----------------------------------------------------------------------
; 0B1FH-0B25H – MATH ROUTINE – “QINTA”
; ----------------------------------------------------------------------
QINTA:	dec	de		;0b1f
	ld	a,d		;0b20
	and	e		;0b21
	inc	a		;0b22
	ret	nz		;0b23
DCXBRT:	dec	bc		;0b24
	ret			;0b25
;
; ======================================================================
; 0B26H – LEVEL II BASIC FIX ROUTINE – “FNFIX”
;
;   Unconditionally truncates the fractional part of a floating
;   point number in WRA1. The result is stored in WRA1 and
;   the type flag is set to integer.
; ----------------------------------------------------------------------
FNFIX:	TSTDAT			;0b26
	ret	m		;0b27
	call	SIGN		;0b28
	jp	p,FNINT		;0b2b
	call	NNEG		;0b2e
	call	FNINT		;0b31
	jp	VNEG		;0b34
;
; ======================================================================
; 0B37H – LEVEL II BASIC INT( ROUTINE – “FNINT”
;
;   Return Integer: Returns the integer portion of a floating point number.
;   Every flag is affected. If the value is positive, the integer portion
;   is returned. If the value is negative with a fractional part,
;   it is rounded up before truncation. The integer portion is left in A
; ----------------------------------------------------------------------
FNINT:	TSTDAT			;0b37
	ret	m		;0b38
	jr	nc,DINT		;0b39
	jr	z,TMERR		;0b3b
	call	CONIS		;0b3d
IINT:	ld	hl,FAC		;0b40
	ld	a,(hl)		;0b43
	cp	$98		;0b44
	ld	a,(FACLO)	;0b46
	ret	nc		;0b49
	ld	a,(hl)		;0b4a
	call	QINT		;0b4b
	ld	(hl),$98	;0b4e
	ld	a,e		;0b50
	push	af		;0b51
	ld	a,c		;0b52
	rla			;0b53
	call	FADFLT		;0b54
	pop	af		;0b57
	ret			;0b58
;
; ----------------------------------------------------------------------
; 0B59H-0B9DH – MATH ROUTINE – “DINT”
;   Greated Integer function for double-precision numbers.
;   All registers are affected.
; ----------------------------------------------------------------------
DINT:	ld	hl,FAC		;0b59
	ld	a,(hl)		;0b5c
	cp	$90		;0b5d
	jp	c,FRCINT	;0b5f
	jr	nz,DINT2	;0b62
	ld	c,a		;0b64
	dec	hl		;0b65
	ld	a,(hl)		;0b66
	xor	$80		;0b67
	ld	b,$06		;0b69
DINT1:	dec	hl		;0b6b
	or	(hl)		;0b6c
	dec	b		;0b6d
	jr	nz,DINT1	;0b6e
	or	a		;0b70
	ld	hl,$8000	;0b71
	jp	z,MAKINT	;0b74
	ld	a,c		;0b77
DINT2:	cp	$B8		;0b78
	ret	nc		;0b7a
DINTFO:	push	af		;0b7b
	call	MOVRF		;0b7c
	call	UNPACK		;0b7f
	xor	(hl)		;0b82
	dec	hl		;0b83
	ld	(hl),$B8	;0b84
	push	af		;0b86
	call	m,DINTA		;0b87
	ld	hl,FAC-1	;0b8a
	ld	a,$B8		;0b8d
	sub	b		;0b8f
	call	DSHFTR		;0b90
	pop	af		;0b93
	call	m,DROUNA	;0b94
	xor	a		;0b97
	ld	(DFACLO-1),a	;0b98
	pop	af		;0b9b
	ret	nc		;0b9c
	jp	DNORML		;0b9d
;
; ----------------------------------------------------------------------
; 0BA0H-0BA9H – MATH ROUTINE – “DINTA”
; ----------------------------------------------------------------------
DINTA:	ld	hl,DFACLO	;0ba0
DINTA1:	ld	a,(hl)		;0ba3
	dec	(hl)		;0ba4
	or	a		;0ba5
	inc	hl		;0ba6
	jr	z,DINTA1	;0ba7
	ret			;0ba9
; ----------------------------------------------------------------------
; 0BAAH-0BC6H – MATH ROUTINE – “UMULT”
;   This is the integer multiply routine for multiplying dimensioned
;   array. It will calculate DE = BC * DE. If there is an overflow,
;   a ?BS ERROR will get thrown. Every register except HL is affected.
; ----------------------------------------------------------------------
UMULT:	push	hl		;0baa
	ld	hl,$0000	;0bab
	ld	a,b		;0bae
	or	c		;0baf
	jr	z,MULRET	;0bb0
	ld	a,$10		;0bb2
UMULT1:	add	hl,hl		;0bb4
	jp	c,BSERR		;0bb5
	ex	de,hl		;0bb8
	add	hl,hl		;0bb9
	ex	de,hl		;0bba
	jr	nc,UMULT2	;0bbb
	add	hl,bc		;0bbd
	jp	c,BSERR		;0bbe
UMULT2:	dec	a		;0bc1
	jr	nz,UMULT1	;0bc2
MULRET:	ex	de,hl		;0bc4
	pop	hl		;0bc5
	ret			;0bc6
;
; ======================================================================
; 0BC7H – LEVEL II BASIC INTEGER SUBTRACTION – “ISUB”
;
;   Integer subtract. (ACCumulator=DE-HL) The result is returned in both
;   ACCumulator and, if there was no overflow, the HL Register Pair.
; ----------------------------------------------------------------------
ISUB:	ld	a,h		;0bc7
	rla			;0bc8
	sbc	a,a		;0bc9
	ld	b,a		;0bca
	call	INEGHL		;0bcb
	ld	a,c		;0bce
	sbc	a,b		;0bcf
	jr	IADDS		;0bd0
;
; ======================================================================
; 0BD2H – LEVEL II BASIC INTEGER ADDITION – “IADD”
;
;   Integer addition (ACCumulator=DE+HL), where ACCumulator = 4121H-4122H.
;   After execution NTF=2, or 4 if overflow has occurred, in which case
;   the result in the ACCumulator will be single-precision.
;   The result is returned in both ACCumulator and the HL Register Pair.
; ----------------------------------------------------------------------
IADD:	ld	a,h		;0bd2
	rla			;0bd3
	sbc	a,a		;0bd4
IADDS:	ld	b,a		;0bd5
	push	hl		;0bd6
	ld	a,d		;0bd7
	rla			;0bd8
	sbc	a,a		;0bd9
	add	hl,de		;0bda
	adc	a,b		;0bdb
	rrca			;0bdc
	xor	h		;0bdd
	jp	p,CONIS1	;0bde
	push	bc		;0be1
	ex	de,hl		;0be2
	call	CONSIH		;0be3
	pop	af		;0be6
	pop	hl		;0be7
	call	PUSHF		;0be8
	ex	de,hl		;0beb
	call	INEGAD		;0bec
	jp	FADDT		;0bef
;
; ======================================================================
; 0BF2H – LEVEL II BASIC INTEGER MULTIPLICATION – “IMULT”
;
;   Integer multiply. (ACCumulator (and HL) =DE*HL). Multiplies HL by DE.
;   The product is left in HL and DE is preserved. If overflow occurs,
;   both values are converted to single precision and the operation is
;   restarted. The product would be left in the ACCumulator.
; ----------------------------------------------------------------------
IMULT:	ld	a,h		;0bf2
	or	l		;0bf3
	jp	z,MAKINT	;0bf4
	push	hl		;0bf7
	push	de		;0bf8
	call	IMULDV		;0bf9
	push	bc		;0bfc
	ld	b,h		;0bfd
	ld	c,l		;0bfe
	ld	hl,$0000	;0bff
	ld	a,$10		;0c02
IMULT1:	add	hl,hl		;0c04
	jr	c,IMULT5	;0c05
	ex	de,hl		;0c07
	add	hl,hl		;0c08
	ex	de,hl		;0c09
	jr	nc,IMULT2	;0c0a
	add	hl,bc		;0c0c
	jp	c,IMULT5	;0c0d
IMULT2:	dec	a		;0c10
	jr	nz,IMULT1	;0c11
	pop	bc		;0c13
	pop	de		;0c14
	ld	a,h		;0c15
	or	a		;0c16
	jp	m,IMULT3	;0c17
	pop	de		;0c1a
	ld	a,b		;0c1b
	jp	INEGA		;0c1c
; ----------------------------------------------------------------------
; 0C1FH-0C34H – MATH ROUTINE – “IMULT3”
; ----------------------------------------------------------------------
IMULT3:	xor	$80		;0c1f
	or	l		;0c21
	jr	z,IMULT4	;0c22
	ex	de,hl		;0c24
;
	.DB	LDBCNN		;0c25 - Z80 trick - LD BC,nnnn skip next 2 bytes
IMULT5:	pop	bc		;0c26
	pop	hl		;0c27
;
	call	CONSIH		;0c28
	pop	hl		;0c2b
	call	PUSHF		;0c2c
	call	CONSIH		;0c2f
FMULTT:	pop	bc		;0c32
	pop	de		;0c33
	jp	FMULT		;0c34
; ----------------------------------------------------------------------
; 0C37H-0C44H – MATH ROUTINE – “IMULT4”
; ----------------------------------------------------------------------
IMULT4:	ld	a,b		;0c37
	or	a		;0c38
	pop	bc		;0c39
	jp	m,MAKINT	;0c3a
	push	de		;0c3d
	call	CONSIH		;0c3e
	pop	de		;0c41
	jp	NNEG		;0c42
; ----------------------------------------------------------------------
; 0C45H-0C5AH – MATH ROUTINE – “IMULDV”
;   This is the integer division routine HL = DE / HL. The remainder will be
;   in DE and the quotient will be left in HL. Every register is affected.
; ----------------------------------------------------------------------
IMULDV:	ld	a,h		;0c45
	xor	d		;0c46
	ld	b,a		;0c47
	call	INEGH		;0c48
	ex	de,hl		;0c4b
INEGH:	ld	a,h		;0c4c
INEGA:	or	a		;0c4d
	jp	p,MAKINT	;0c4e
; ----------------------------------------------------------------------
; Negate HL routine. This routine changes the sign of the HL Register Pair
; and stores it in the ACC. (HL=ACCumulator=-HL) The result is returned
; in both the HL Register Pair and the ACC.
; ----------------------------------------------------------------------
INEGHL:	xor	a		;0c51
	ld	c,a		;0c52
	sub	l		;0c53
	ld	l,a		;0c54
	ld	a,c		;0c55
	sbc	a,h		;0c56
	ld	h,a		;0c57
	jp	MAKINT		;0c58
; ----------------------------------------------------------------------
; 0C5BH-0C6FH – MATH ROUTINE – “INEG”
;   Integer Negation Routine. All registers are altered.
; ----------------------------------------------------------------------
INEG:	ld	hl,(FACLO)	;0c5b
	call	INEGHL		;0c5e
	ld	a,h		;0c61
	xor	$80		;0c62
	or	l		;0c64
	ret	nz		;0c65
INEG2:	ex	de,hl		;0c66
	call	VALSNG		;0c67
	xor	a		;0c6a
INEGAD:	ld	b,$98		;0c6b
	jp	FLOATR		;0c6d
;
; ======================================================================
; 0C70H – LEVEL II BASIC DOUBLE PRECISION SUBTRACTION – “DSUB”

;   Double-precision subtraction (ACCumulator = ACCumulator – ARG).
;   Subtracts the double precision value in ARG (a/k/a REG 2)
;   from the value in the ACCumulator. The dif is left in ACC.
; ----------------------------------------------------------------------
DSUB:	ld	hl,ARG-1	;0c70
	ld	a,(hl)		;0c73
	xor	$80		;0c74
	ld	(hl),a		;0c76
;
; ======================================================================
; 0C77H - LEVEL II BASIC DOUBLE PRECISION ADDITION – “DADD”
;
;   Double-precision addition (ACCumulator=ACCumulator+ARG (a/k/a REG 2)).
;   Adds the double precision value in ARG (a/k/a REG 2) to the value
;   in the ACCumulator. Sum is left in the ACCumulator.
;   All registers are affected.
; ----------------------------------------------------------------------
DADD:	ld	hl,ARG		;0c77
	ld	a,(hl)		;0c7a
	or	a		;0c7b
	ret	z		;0c7c
	ld	b,a		;0c7d
	dec	hl		;0c7e
	ld	c,(hl)		;0c7f
	ld	de,FAC		;0c80
	ld	a,(de)		;0c83
	or	a		;0c84
	jp	z,VMOVFA	;0c85
	sub	b		;0c88
	jr	nc,DADD2	;0c89
	cpl			;0c8b
	inc	a		;0c8c
	push	af		;0c8d
	ld	c,$08		;0c8e
	inc	hl		;0c90
	push	hl		;0c91
DADD1:	ld	a,(de)		;0c92
	ld	b,(hl)		;0c93
	ld	(hl),a		;0c94
	ld	a,b		;0c95
	ld	(de),a		;0c96
	dec	de		;0c97
	dec	hl		;0c98
	dec	c		;0c99
	jr	nz,DADD1	;0c9a
	pop	hl		;0c9c
	ld	b,(hl)		;0c9d
	dec	hl		;0c9e
	ld	c,(hl)		;0c9f
	pop	af		;0ca0
DADD2:	cp	$39		;0ca1
	ret	nc		;0ca3
	push	af		;0ca4
	call	UNPACK		;0ca5
	inc	hl		;0ca8
	ld	(hl),$00	;0ca9
	ld	b,a		;0cab
	pop	af		;0cac
	ld	hl,ARG-1	;0cad
	call	DSHFTR		;0cb0
	ld	a,(FACFLG)	;0cb3
	ld	(DFACLO-1),a	;0cb6
	ld	a,b		;0cb9
	or	a		;0cba
	jp	p,DADD3		;0cbb
	call	DADDAA		;0cbe
	jp	nc,DROUND	;0cc1
	ex	de,hl		;0cc4
	inc	(hl)		;0cc5
	jp	z,OVERR		;0cc6
	call	DSHFRB		;0cc9
	jp	DROUND		;0ccc
; ----------------------------------------------------------------------
; 0CCFH-0D1FH – DOUBLE PRECISION MATH ROUTINE – “DADD3”
; ----------------------------------------------------------------------
DADD3:	call	DADDAS		;0ccf
	ld	hl,FACSGN	;0cd2
	call	c,DNEGR		;0cd5
; ----------------------------------------------------------------------
; 0CD8H – DOUBLE PRECISION MATH ROUTINE – “DNORML” and “DNORM1”
; ----------------------------------------------------------------------
DNORML:	xor	a		;0cd8
DNORM1:	ld	b,a		;0cd9
	ld	a,(FAC-1)	;0cda
	or	a		;0cdd
	jr	nz,DNORM5	;0cde
	ld	hl,DFACLO-1	;0ce0
	ld	c,$08		;0ce3
DNORM2:	ld	d,(hl)		;0ce5
	ld	(hl),a		;0ce6
	ld	a,d		;0ce7
	inc	hl		;0ce8
	dec	c		;0ce9
	jr	nz,DNORM2	;0cea
	ld	a,b		;0cec
	sub	$08		;0ced
	cp	$C0		;0cef
	jr	nz,DNORM1	;0cf1
	jp	ZERO		;0cf3
; ----------------------------------------------------------------------
; 0CF6H – Part of the “DNORML” and “DNORM1” Routine
; ----------------------------------------------------------------------
DNORM3:	dec	b		;0cf6
	ld	hl,DFACLO-1	;0cf7
	call	DSHFLC		;0cfa
	or	a		;0cfd
DNORM5:	jp	p,DNORM3	;0cfe
	ld	a,b		;0d01
	or	a		;0d02
	jr	z,DROUND	;0d03
	ld	hl,FAC		;0d05
	add	a,(hl)		;0d08
	ld	(hl),a		;0d09
	jp	nc,ZERO		;0d0a
	ret	z		;0d0d
; ----------------------------------------------------------------------
; 0D0EH – DOUBLE PRECISION MATH ROUTINE – “DROUND” and “DROUNB”
; ----------------------------------------------------------------------
DROUND:	ld	a,(DFACLO-1)	;0d0e
DROUNB:	or	a		;0d11
	call	m,DROUNA	;0d12
	ld	hl,FACSGN	;0d15
	ld	a,(hl)		;0d18
	and	$80		;0d19
	dec	hl		;0d1b
	dec	hl		;0d1c
	xor	(hl)		;0d1d
	ld	(hl),a		;0d1e
	ret			;0d1f
; ----------------------------------------------------------------------
; 0D20H-0D32H – DOUBLE PRECISION MATH support routine – “DROUNA”
; ----------------------------------------------------------------------
DROUNA:	ld	hl,DFACLO	;0d20
	ld	b,$07		;0d23
DRON1:	inc	(hl)		;0d25
	ret	nz		;0d26
	inc	hl		;0d27
	dec	b		;0d28
	jr	nz,DRON1	;0d29
	inc	(hl)		;0d2b
	jp	z,OVERR		;0d2c
	dec	hl		;0d2f
	ld	(hl),$80	;0d30
	ret			;0d32
; ----------------------------------------------------------------------
; 0D33H-0D44H – DOUBLE PRECISION MATH ROUTINE – “DADDAA” and “DADDA”
; ----------------------------------------------------------------------
DADDAA:	ld	hl,ARGLO	;0d33
DADDFO:	ld	de,DFACLO	;0d36
DADDS:	ld	c,$07		;0d39
	xor	a		;0d3b
DADALS:	ld	a,(de)		;0d3c
	adc	a,(hl)		;0d3d
	ld	(de),a		;0d3e
	inc	de		;0d3f
	inc	hl		;0d40
	dec	c		;0d41
	jr	nz,DADALS	;0d42
	ret			;0d44
; ----------------------------------------------------------------------
; 0D45H-0D56H – DOUBLE PRECISION MATH ROUTINE – “DADDAS”
;   This routine subtracts numbers in the pure version. This needs to
;   be done in two subroutines since the ROM cannot be modified.
; ----------------------------------------------------------------------
DADDAS:	ld	hl,ARGLO	;0d45
DADDFS:	ld	de,DFACLO	;0d48
DADDSS:	ld	c,$07		;0d4b
	xor	a		;0d4d
DADSLS:	ld	a,(de)		;0d4e
	sbc	a,(hl)		;0d4f
	ld	(de),a		;0d50
	inc	de		;0d51
	inc	hl		;0d52
	dec	c		;0d53
	jr	nz,DADSLS	;0d54
	ret			;0d56
; ----------------------------------------------------------------------
; 0D57H-0D68H – DOUBLE PRECISION MATH ROUTINE – “DNEGR”
;   This routine will negate the signed number held in the ACCumulator.
;   Registers A, B, C, H, and L are affected.
;   This routine is called by DADD and DINT.
; ----------------------------------------------------------------------
DNEGR:	ld	a,(hl)		;0d57
	cpl			;0d58
	ld	(hl),a		;0d59
	ld	hl,DFACLO-1	;0d5a
	ld	b,$08		;0d5d
	xor	a		;0d5f
	ld	c,a		;0d60
DNEGR1:	ld	a,c		;0d61
	sbc	a,(hl)		;0d62
	ld	(hl),a		;0d63
	inc	hl		;0d64
	dec	b		;0d65
	jr	nz,DNEGR1	;0d66
	ret			;0d68
; ----------------------------------------------------------------------
; 0D69H-0D8FH – DOUBLE PRECISION MATH ROUTINE – “DSHFTR”
;   This routine wwill shift the double precision value held in the
;   ACCumulator to the right once.
; ----------------------------------------------------------------------
DSHFTR:	ld	(hl),c		;0d69
	push	hl		;0d6a
DSHFR1:	sub	$08		;0d6b
	jr	c,DSHFR3	;0d6d
	pop	hl		;0d6f
DSHFRM:	push	hl		;0d70
	ld	de,$0800	;0d71 - shifts a zero into the HIGH ORDER byte and sets up a counter
DSHFR2:	ld	c,(hl)		;0d74
	ld	(hl),e		;0d75
	ld	e,c		;0d76
	dec	hl		;0d77
	dec	d		;0d78
	jr	nz,DSHFR2	;0d79
	jr	DSHFR1		;0d7b
; ----------------------------------------------------------------------
; 0D69H-0D8FH – DOUBLE PRECISION MATH ROUTINE – “DSHFR3”
; ----------------------------------------------------------------------
DSHFR3:	add	a,$09		;0d7d
	ld	d,a		;0d7f
DSHFR4:	xor	a		;0d80
	pop	hl		;0d81
	dec	d		;0d82
	ret	z		;0d83
DSHFRA:	push	hl		;0d84
	ld	e,$08		;0d85
DSHFR5:	ld	a,(hl)		;0d87
	rra			;0d88
	ld	(hl),a		;0d89
	dec	hl		;0d8a
	dec	e		;0d8b
	jr	nz,DSHFR5	;0d8c
	jr	DSHFR4		;0d8e
; ----------------------------------------------------------------------
; 0D90H-0D96H – DOUBLE PRECISION MATH ROUTINE – “DSHFRB”
;   This is the entry from DADD and DMULT.
; ----------------------------------------------------------------------
DSHFRB:	ld	hl,FAC-1	;0d90
	ld	d,$01		;0d93
	jr	DSHFRA		;0d95
; ----------------------------------------------------------------------
; 0D97H-0DA0H – DOUBLE PRECISION MATH ROUTINE – “DSHFLC”
;   This routine will rotate the ACCumulator left one.
;   Register A, C, H, and L are affected.
; ----------------------------------------------------------------------
DSHFLC:	ld	c,$08		;0d97
DSHFTL:	ld	a,(hl)		;0d99
	rla			;0d9a
	ld	(hl),a		;0d9b
	inc	hl		;0d9c
	dec	c		;0d9d
	jr	nz,DSHFTL	;0d9e
	ret			;0da0
;
; ======================================================================
; 0DA1H – LEVEL II BASIC DOUBLE PRECISION MULTIPLICATION – “DMULT”
;
;   Double-precision multiplication (ACCumulator=ACC*ARG (a/k/a REG 2)).
;   Multiplies the double precision value in the ACCumulator by the value
;   in ARG (a/k/a REG 2). The product is left in the ACCumulator.
; ----------------------------------------------------------------------
DMULT:	call	SIGN		;0da1
	ret	z		;0da4
	call	MULDVA		;0da5
	call	DMULDV		;0da8
	ld	(hl),c		;0dab
	inc	de		;0dac
	ld	b,$07		;0dad
DMULT2:	ld	a,(de)		;0daf
	inc	de		;0db0
	or	a		;0db1
	push	de		;0db2
	jr	z,DMULT5	;0db3
	ld	c,$08		;0db5
DMULT3:	push	bc		;0db7
	rra			;0db8
	ld	b,a		;0db9
	call	c,DADDAA	;0dba
	call	DSHFRB		;0dbd
	ld	a,b		;0dc0
	pop	bc		;0dc1
	dec	c		;0dc2
	jr	nz,DMULT3	;0dc3
DMULT4:	pop	de		;0dc5
	dec	b		;0dc6
	jr	nz,DMULT2	;0dc7
	jp	DNORML		;0dc9
; ----------------------------------------------------------------------
; 0DCCH – DOUBLE PRECISION MULTIPLICATION Support Routine – “DMULT5”
; ----------------------------------------------------------------------
DMULT5:	ld	hl,FAC-1	;0dcc
	call	DSHFRM		;0dcf
	jr	DMULT4		;0dd2
;
; ----------------------------------------------------------------------
; 0DD4H-0DDBH – DOUBLE PRECISION CONSTANT STORAGE AREA – “DTEN” and “FTEN”
; ----------------------------------------------------------------------
;
DTEN:	.DB	$00, $00, $00, $00; A double precision constant 10.0 (8 bytes)
FTEN:	.DB	$00, $00, $20, $84; A single precision constant 10.0
;
; ----------------------------------------------------------------------
; 0DDCH-0DE4H – DOUBLE PRECISION MATH ROUTINE – “DDIV10”
;   Double precision divide routine. Divides the ACCumulator by 10.
;   All registers are affected.
; ----------------------------------------------------------------------
DDIV10:	ld	de,DTEN		;0ddc
	ld	hl,ARGLO	;0ddf
	call	VMOVE		;0de2
;
; ======================================================================
; 0DE5H – LEVEL II BASIC DOUBLE PRECISION DIVISION – “DDIV”
;
;   Divides the double precision value in the ACCumulator by the value in
;   ARG (a/k/a REG 2). The quotient is left in the ACCumulator.
;   All registers are affected
; ----------------------------------------------------------------------
DDIV:	ld	a,(ARG)		;0de5
	or	a		;0de8
	jp	z,DV0ERR	;0de9
	call	MULDVS		;0dec
	inc	(hl)		;0def
	inc	(hl)		;0df0
	call	DMULDV		;0df1
	ld	hl,FBUFFR+33	;0df4 - address of the extra HIGH ORDER byte we will use in ARG
	ld	(hl),c		;0df7 - zero that byte
	ld	b,c		;0df8
DDIV1:	ld	de,FMLTT0	;0df9
	ld	hl,ARGLO	;0dfc
	call	DADDSS		;0dff
	ld	a,(de)		;0e02
	sbc	a,c		;0e03
	ccf			;0e04
	jr	c,DDIV2		;0e05
	ld	de,FMLTT0	;0e07
	ld	hl,ARGLO	;0e0a
	call	DADDS		;0e0d
;
	xor	a		;0e10 - Clear the CF for the Z80 Trick
	.DB	JPCNN		;0e11 - JP C,nnnn, since C flag cleared skips next 2 bytes
;
DDIV2:	ld	(de),a		;0e12
	inc	b		;0e13
	ld	a,(FAC-1)	;0e14
	inc	a		;0e17
	dec	a		;0e18
	rra			;0e19
	jp	m,DROUNB	;0e1a
	rla			;0e1d
	ld	hl,DFACLO	;0e1e
	ld	c,$07		;0e21
	call	DSHFTL		;0e23
	ld	hl,FMLTT0	;0e26
	call	DSHFLC		;0e29
	ld	a,b		;0e2c
	or	a		;0e2d
	jr	nz,DDIV1	;0e2e
	ld	hl,FAC		;0e30
	dec	(hl)		;0e33
	jr	nz,DDIV1	;0e34
	jp	OVERR		;0e36
; ----------------------------------------------------------------------
; 0E39H-0E4CH – DOUBLE PRECISION MATH ROUTINE – “DMULDV”
;   This routine will transfer the double precision number held in the ACCumulator
;   to FBUFFR for the DMULT and DDIV routines. All registers are affected.
; ----------------------------------------------------------------------
DMULDV:	ld	a,c		;0e39
	ld	(ARG-1),a	;0e3a
	dec	hl		;0e3d
	ld	de,FMLTT2	;0e3e
	ld	bc,$0700	;0e41 - B number of bytes to be moved, and C=0
DMLDV1:	ld	a,(hl)		;0e44
	ld	(de),a		;0e45
	ld	(hl),c		;0e46
	dec	de		;0e47
	dec	hl		;0e48
	dec	b		;0e49
	jr	nz,DMLDV1	;0e4a
	ret			;0e4c
; ----------------------------------------------------------------------
; 0E4DH-0E64H – MATH ROUTINE – “DMUL10”
;   This routine multiplies the current double-precision value by 10 by
;   adding it to itself. First the current value is moved to a saved
;   location, and then DP add routine adds the current value to that
;   saved value. All registers are affected
; ----------------------------------------------------------------------
DMUL10:	call	VMOVAF		;0e4d
	ex	de,hl		;0e50
	dec	hl		;0e51
	ld	a,(hl)		;0e52
	or	a		;0e53
	ret	z		;0e54
	add	a,$02		;0e55
	jp	c,OVERR		;0e57
	ld	(hl),a		;0e5a
	push	hl		;0e5b
	call	DADD		;0e5c
	pop	hl		;0e5f
	inc	(hl)		;0e60
	ret	nz		;0e61
	jp	OVERR		;0e62
;
; ======================================================================
; 0E65H-0F88H – ASCII to Double Precision Converter – “FINDBL”
;
;   This routine converts an ASCII string (pointed to by HL) to a
;   double-precision value and stores it in the ACCumulator.
;   The NTF is fixed accordingly. The string must be terminated with a , or zero.
; ----------------------------------------------------------------------
FINDBL:	call	ZERO		;0e65
	call	VALDBL		;0e68
;
	.DB	ORNN		;0e6b - Z80 Trick - OR nn - next instruction skippd NZ flag SET
;
; ======================================================================
; 0E6CH - ASCII To Binary - "FIN"
;
;   Converts the ASCII string pointed to by HL to binary. If
;   the value is less than 2**16 and does not contain a decimal
;   point or an E or D descriptor (exponent), the string will be
;   converted to its integer equivalent. If the string contains a
;   decimal point or an E, or D descriptor or if it exceeds 2**16
;   it will be converted to single or double precision. The
;   binary value will be left in WRA1 and the mode flag will be
;   to the proper value.
; ----------------------------------------------------------------------
FIN:	xor	a		;0e6c - Z FLAG SET
	ex	de,hl		;0e6d
	ld	bc,$00FF	;0e6e
	ld	h,b		;0e71
	ld	l,b		;0e72
	call	z,MAKINT	;0e73
	ex	de,hl		;0e76
	ld	a,(hl)		;0e77
	cp	'-'		;0e78
	push	af		;0e7a
	jp	z,FINC		;0e7b
	cp	'+'		;0e7e
	jr	z,FINC		;0e80
	dec	hl		;0e82
FINC:	GETCHR			;0e83 - rst 10h
	jp	c,FINDIG	;0e84
	cp	'.'		;0e87
	jp	z,FINDP		;0e89
	cp	'E'		;0e8c
	jr	z,FINEX		;0e8e
	cp	'%'		;0e90
	jp	z,FININT	;0e92
	cp	'#'		;0e95
	jp	z,FINDBF	;0e97
	cp	'!'		;0e9a
	jp	z,FINSNF	;0e9c
	cp	'D'		;0e9f
	jr	nz,FINE		;0ea1
	or	a		;0ea3
FINEX:	call	FINFRC		;0ea4
	push	hl		;0ea7
	ld	hl,FINEC	;0ea8
	ex	(sp),hl		;0eab
	GETCHR			;0eac - rst 10h
	dec	d		;0ead
	cp	TKMNUS		;0eae - '-' token
	ret	z		;0eb0
	cp	'-'		;0eb1
	ret	z		;0eb3
	inc	d		;0eb4
	cp	TKPLUS		;0eb5
	ret	z		;0eb7
	cp	'+'		;0eb8
	ret	z		;0eba
	dec	hl		;0ebb
	pop	af		;0ebc
FINEC:	GETCHR			;0ebd - rst 10h
	jp	c,FINEDG	;0ebe
	inc	d		;0ec1
	jr	nz,FINE		;0ec2
	xor	a		;0ec4
	sub	e		;0ec5
	ld	e,a		;0ec6
FINE:	push	hl		;0ec7
	ld	a,e		;0ec8
	sub	b		;0ec9
FINE2:	call	p,FINMUL	;0eca
	call	m,FINDIV	;0ecd
	jr	nz,FINE2	;0ed0
	pop	hl		;0ed2
	pop	af		;0ed3
	push	hl		;0ed4
	call	z,VNEG		;0ed5
	pop	hl		;0ed8
	TSTDAT			;0ed9
	ret	pe		;0eda
	push	hl		;0edb
	ld	hl,POPHRT	;0edc
	push	hl		;0edf
	call	CONIS2		;0ee0
	ret			;0ee3
; ----------------------------------------------------------------------
; 0EE4 – MATH ROUTINE – “FINDP”
;   This routine checks to see if we have seen TWO decimal points and to set
;   the decimal point flag. We jumped here when we found a single decimal point.
; ----------------------------------------------------------------------
FINDP:	TSTDAT			;0ee4
	inc	c		;0ee5
	jr	nz,FINE		;0ee6
	call	c,FINFRC	;0ee8
	jp	FINC		;0eeb
; ----------------------------------------------------------------------
; 0EEE – MATH ROUTINE – “FININT”
; ----------------------------------------------------------------------
FININT:	TSTDAT			;0eee
	jp	p,SNERR		;0eef
INFINE:	inc	hl		;0ef2
	jr	FINE		;0ef3
FINDBF:	or	a		;0ef5
FINSNF:	call	FINFRC		;0ef6
	jr	INFINE		;0ef9
; ----------------------------------------------------------------------
; 0EFB – MATH ROUTINE – “FINFRC”
;   This routine will force the ACCumulator to be either single precision
;   or double precision based on the Z FLAG. Z FLAG = Force to single precision;
;   NZ FLAG = Force to double precision.
; ----------------------------------------------------------------------
FINFRC:	push	hl		;0efb
	push	de		;0efc
	push	bc		;0efd
	push	af		;0efe
	call	z,FRCSNG	;0eff
	pop	af		;0f02
	call	nz,FRCDBL	;0f03
	pop	bc		;0f06
	pop	de		;0f07
	pop	hl		;0f08
	ret			;0f09
; ----------------------------------------------------------------------
; 0EE4 – MATH ROUTINE – “FINMUL” and “FINMLT”
;   This subroutine multiplies a number by 10 once. The reason this is a
;   subroutine is that it can also double as a check to see if A is ZERO,
;   thus saving bytes. All registers are affected.
; ----------------------------------------------------------------------
FINMUL:	ret	z		;0f0a
FINMLT:	push	af		;0f0b
	TSTDAT			;0f0c
	push	af		;0f0d
	call	po,MUL10	;0f0e
	pop	af		;0f11
	call	pe,DMUL10	;0f12
	pop	af		;0f15
DCRART:	dec	a		;0f16
	ret			;0f17
; ----------------------------------------------------------------------
; 0F18 – MATH ROUTINE – “FINDIV”
;   This subroutine divides a number by 10 once. FIN and FOUT use this
;   routine. Registers A, B, and C are affected.
; ----------------------------------------------------------------------
FINDIV:	push	de		;0f18
	push	hl		;0f19
	push	af		;0f1a
	TSTDAT			;0f1b
	push	af		;0f1c
	call	po,DIV10	;0f1d
	pop	af		;0f20
	call	pe,DDIV10	;0f21
	pop	af		;0f24
	pop	hl		;0f25
	pop	de		;0f26
	inc	a		;0f27
	ret			;0f28
; ----------------------------------------------------------------------
; 0F29 – MATH ROUTINE – “FINDIG”
;   This routine will pack the next digit of the number into the ACCumulator.
;   To do this, the ACCumulator is multipled by ten to shift everything
;   over and make room for the digit, and then the digit is added in.
; ----------------------------------------------------------------------
FINDIG:	push	de		;0f29
	ld	a,b		;0f2a
	adc	a,c		;0f2b
	ld	b,a		;0f2c
	push	bc		;0f2d
	push	hl		;0f2e
	ld	a,(hl)		;0f2f
	sub	$30		;0f30
	push	af		;0f32
	TSTDAT			;0f33
	jp	p,FINDGV	;0f34
	ld	hl,(FACLO)	;0f37
	ld	de,$0CCD	;0f3a - 3277 to see if we will overflow
	CPDEHL			;0f3d
	jr	nc,FINDG2	;0f3e
	ld	d,h		;0f40
	ld	e,l		;0f41
	add	hl,hl		;0f42
	add	hl,hl		;0f43
	add	hl,de		;0f44
	add	hl,hl		;0f45
	pop	af		;0f46
	ld	c,a		;0f47
	add	hl,bc		;0f48
	ld	a,h		;0f49
	or	a		;0f4a
	jp	m,FINDG1	;0f4b
	ld	(FACLO),hl	;0f4e
FINDGE:	pop	hl		;0f51
	pop	bc		;0f52
	pop	de		;0f53
	jp	FINC		;0f54
; ----------------------------------------------------------------------
; 0F57 – MATH ROUTINE – “FINDG1”
;   This routine handles 32768 and 32769
; ----------------------------------------------------------------------
FINDG1:	ld	a,c		;0f57
	push	af		;0f58
; ----------------------------------------------------------------------
; 0F59 – MATH ROUTINE – “FINDG2”
;   Convert integer digits into single precision digits
; ----------------------------------------------------------------------
FINDG2:	call	CONSI		;0f59
	scf			;0f5c
; ----------------------------------------------------------------------
; 0F5D – MATH ROUTINE – “FINDGV”
;   Determine if we have a single precision or a double precision number
; ----------------------------------------------------------------------
FINDGV:	jr	nc,FINDGD	;0f5d
	ld	bc,$9474	;0f5f - exponent and MSB of a single precision constant
	ld	de,$2400	;0f62 - NMSB and the LSB of a single precision constant - 1E6
	call	FCOMP		;0f65
	jp	p,FINDG3	;0f68
	call	MUL10		;0f6b
	pop	af		;0f6e
	call	FINLOG		;0f6f
	jr	FINDGE		;0f72
; ----------------------------------------------------------------------
; 0F74 – MATH ROUTINE – “FINDG3” and “FINDGD”
;   The routine will convert a 7 digit single precision number
;   into a double precision number
; ----------------------------------------------------------------------
FINDG3:	call	CONDS		;0f74
FINDGD:	call	DMUL10		;0f77
	call	VMOVAF		;0f7a
	pop	af		;0f7d
	call	FLOAT		;0f7e
	call	CONDS		;0f81
	call	DADD		;0f84
	jr	FINDGE		;0f87
; ----------------------------------------------------------------------
; 0F89H-0F93H – SINGLE PRECISION MATH ROUTINE – “FINLOG”
;   This is a subroutine for FIN and for LOG
; ----------------------------------------------------------------------
FINLOG:	call	PUSHF		;0f89
	call	FLOAT		;0f8c
FADDT:	pop	bc		;0f8f
	pop	de		;0f90
	jp	FADD		;0f91
; ----------------------------------------------------------------------
; 0F94H-0FA6H – MATH ROUTINE – “FINEDG”
;   Pack in a digit of the exponent. This is done by multiplying the
;   old exponent by 10 and then adding in the desired digit.
;   Note: This routine does NOT check for overflow.
; ----------------------------------------------------------------------
FINEDG:	ld	a,e		;0f94
	cp	$0A		;0f95
	jr	nc,FINEDO	;0f97
	rlca			;0f99
	rlca			;0f9a
	add	a,e		;0f9b
	rlca			;0f9c
	add	a,(hl)		;0f9d
	sub	$30		;0f9e
	ld	e,a		;0fa0
;
	.DB	JPMNN		;0fa1 - Z80 Trick - JP M,nnnn - skip next 2 bytes
;
FINEDO:	ld	e,$32		;0fa2
	jp	FINEC		;0fa4
; ----------------------------------------------------------------------
; 0FA7H-0FAEH – DISPLAY MESSAGE ROUTINE – “INPRT”
;   Display "IN " and integer stored in HL. Used to display messages
;   such as "BREAK IN nnnnn"
; ----------------------------------------------------------------------
INPRT:	push	hl		;0fa7
	ld	hl,m_INTX	;0fa8
	call	STROUT		;0fab
	pop	hl		;0fae
;
; ======================================================================
; 0FAFH – CONVERT BINARY TO ASCII AND DISPLAY RESULT – “LINPRT”
;
;   This routine converts the two byte number in the HL Register Pair
;   (which is assumed to be an integer) to ASCII and displays it at
;   the current cursor position on the video screen. The space for
;   the sign at the beginning of a line is removed. All registers are affected.
; ----------------------------------------------------------------------
LINPRT:	call	MAKINT		;0faf
	xor	a		;0fb2
	call	FOUINI		;0fb3
	or	(hl)		;0fb6
	call	FOUT2		;0fb7
	jp	STROUI		;0fba
;
; ----------------------------------------------------------------------
; 0FBDH-1363H – BINARY TO ASCII CONVERSION ROUTINE – “FOUT”
;
;   This routine will output the value held in the ACCumulator according
;   to the format specifications held in Registers A, B, and C.
;   The ACCumulator contents are lost and all registers are affected.
; ----------------------------------------------------------------------
FOUT:	xor	a		;0fbd - Zero Register A so that the format is set for free output
;
; ======================================================================
; 0FBEH – FLOATING to ASCII Conversion Routine – “PUFOUT”
;
;   This routine converts a single or double precision number in the
;   ACCumulator to its ASCII equivalent. The ASCII value is stored at
;   the buffer pointed to by the HL Register Pair. As the value is
;   converted from binary to ASCII, it is formatted as it would be if
;   a PRINT USING statement had been invoked. The format modes that can
;   be specified are selected by loading the A, B, and C registers
; ----------------------------------------------------------------------
PUFOUT:	call	FOUINI		;0fbe
	and	$08		;0fc1
	jr	z,FOUT1		;0fc3
	ld	(hl),'+'	;0fc5
FOUT1:	ex	de,hl		;0fc7
	call	VSIGN		;0fc8
	ex	de,hl		;0fcb
	jp	p,FOUT2		;0fcc
	ld	(hl),'-'	;0fcf
	push	bc		;0fd1
	push	hl		;0fd2
	call	VNEG		;0fd3
	pop	hl		;0fd6
	pop	bc		;0fd7
	or	h		;0fd8
FOUT2:	inc	hl		;0fd9
	ld	(hl),$30	;0fda
	ld	a,(TEMP3)	;0fdc
	ld	d,a		;0fdf
	rla			;0fe0
	ld	a,(VALTYP)	;0fe1
	jp	c,FOUTFX	;0fe4
	jp	z,FOUTZR	;0fe7
	cp	VTSNG		;0fea - compare with Single Precsion
	jp	nc,FOUFRV	;0fec - Not single or Double precision
	ld	bc,$0000	;0fef
	call	FOUTCI		;0ff2
FOUTZS:	ld	hl,FBUFFR	;0ff5
	ld	b,(hl)		;0ff8
	ld	c,SPACE		;0ff9
	ld	a,(TEMP3)	;0ffb
	ld	e,a		;0ffe
	and	$20		;0fff
	jr	z,FOTZS1	;1001
	ld	a,b		;1003
	cp	c		;1004
	ld	c,'*'		;1005
	jr	nz,FOTZS1	;1007
;
#IFDEF BUGFIX8
	.ECHO	" BUGFIX8 - ROM Error 8 Patched \n"
	NOP
#ELSE
; The ROM's formatting routine incorrectly applies the asterisk
; fill character to the trailing position for positive numbers,
; replacing the intended space with *.
; CREDIT : Ira Goldklang
;
	ld	b,c		;1009
#ENDIF
;
FOTZS1:	ld	(hl),c		;100a
	GETCHR			;100b - rst 10h
	jr	z,FOTZS4	;100c
	cp	'E'		;100e
	jr	z,FOTZS4	;1010
	cp	'D'		;1012
	jr	z,FOTZS4	;1014
	cp	'0'		;1016
	jr	z,FOTZS1	;1018
	cp	','		;101a
	jr	z,FOTZS1	;101c
	cp	'.'		;101e
	jr	nz,FOTZS2	;1020
FOTZS4:	dec	hl		;1022
	ld	(hl),'0'	;1023
FOTZS2:	ld	a,e		;1025
	and	$10		;1026
	jr	z,FOTZS3	;1028
	dec	hl		;102a
	ld	(hl),'$'	;102b
FOTZS3:	ld	a,e		;102d
	and	$04		;102e
	ret	nz		;1030
	dec	hl		;1031
	ld	(hl),b		;1032
	ret			;1033
; ----------------------------------------------------------------------
; 1034 – MATH ROUTINE – “FOUINI”
;   Initially set up the format specs and put in a SPACE for the sign
;   of a positive number. This routine gets called by the FLOATING
;   to ASCII Conversion Routine (at 0FBEH) and by the BINARY to ASCII
;   Conversion Routine (at 0FAFH)
; ----------------------------------------------------------------------
FOUINI:	ld	(TEMP3),a	;1034
	ld	hl,FBUFFR	;1037
	ld	(hl),SPACE	;103a
	ret			;103c
; ----------------------------------------------------------------------
; 103D – MATH ROUTINE – “FOUFRV”
;   This routine gets called by the FLOATING to ASCII Conversion Routine
;   (0FBEH-0FC0H) if the value being converted is either Single Precision
;   or Double Precision. This will print a single or double precision
;   number in free format
; ----------------------------------------------------------------------
FOUFRV:	cp	$05		;103d
	push	hl		;103f
	sbc	a,$00		;1040
	rla			;1042
	ld	d,a		;1043
	inc	d		;1044
	call	FONTINV		;1045
	ld	bc,$0300	;1048 - B=3 (decimal point count), C=0 (comma count)
	add	a,d		;104b
	jp	m,FOFRS1	;104c
	inc	d		;104f
	cp	d		;1050
	jr	nc,FOFRS1	;1051
	inc	a		;1053
	ld	b,a		;1054
	ld	a,$02		;1055
FOFRS1:	sub	$02		;1057
	pop	hl		;1059
	push	af		;105a
	call	FOUTED		;105b
	ld	(hl),$30	;105e
	call	z,INXHRT	;1060
	call	FOUTCV		;1063
FOFRS2:	dec	hl		;1066
	ld	a,(hl)		;1067
	cp	'0'		;1068
	jr	z,FOFRS2	;106a
	cp	'.'		;106c
	call	nz,INXHRT	;106e
	pop	af		;1071
	jr	z,FOUTDN	;1072
; ----------------------------------------------------------------------
; 1074 – MATH ROUTINE – “FOFLDN”
;   This routine will put the exponent and a D or E into the buffer.
;   On entry, Register A holds the exponent and it is assumed that
;   all FLAGs are set correctly.
; ----------------------------------------------------------------------
FOFLDN:	push	af		;1074
	TSTDAT			;1075
	ld	a,$22		;1076
	adc	a,a		;1078
	ld	(hl),a		;1079
	inc	hl		;107a
	pop	af		;107b
	ld	(hl),'+'	;107c
	jp	p,FOUCE1	;107e
	ld	(hl),'-'	;1081
	cpl			;1083
	inc	a		;1084
; ----------------------------------------------------------------------
; 1085 – MATH ROUTINE – “FOUCE1” and “FOUCE2”
; ----------------------------------------------------------------------
FOUCE1:	ld	b,$2F		;1085
FOUCE2:	inc	b		;1087
	sub	$0A		;1088
	jr	nc,FOUCE2	;108a
	add	a,$3A		;108c
	inc	hl		;108e
	ld	(hl),b		;108f
	inc	hl		;1090
	ld	(hl),a		;1091
FOUTZR:	inc	hl		;1092
; ----------------------------------------------------------------------
; 1093 – MATH ROUTINE – “FOUTDN”
;   This routine will print a free format zero.
; ----------------------------------------------------------------------
FOUTDN:	ld	(hl),$00	;1093
	ex	de,hl		;1095
	ld	hl,FBUFFR	;1096
	ret			;1099
; ----------------------------------------------------------------------
; 109A- MATH ROUTINE – “FOUTFX”
;   This routine will print a number in fixed format.
; ----------------------------------------------------------------------
FOUTFX:	inc	hl		;109a
	push	bc		;109b
	cp	$04		;109c
	ld	a,d		;109e
	jp	nc,FOUFXV	;109f
	rra			;10a2
	jp	c,FFXIFL	;10a3
	ld	bc,$0603	;10a6 - B to a count of 6, C with a comma count of 3
	call	FOUICC		;10a9
	pop	de		;10ac
	ld	a,d		;10ad
	sub	$05		;10ae
	call	p,FOTZER	;10b0
	call	FOUTCI		;10b3
FOUTTD:	ld	a,e		;10b6
	or	a		;10b7
	call	z,DCXHRT	;10b8
	dec	a		;10bb
	call	p,FOTZER	;10bc
; ----------------------------------------------------------------------
; 10BF – MATH ROUTINE – “FOUTTS”
;   This routine will finish up the printing of a fixed format number.
; ----------------------------------------------------------------------
FOUTTS:	push	hl		;10bf
	call	FOUTZS		;10c0
	pop	hl		;10c3
	jr	z,FFXIX1	;10c4
	ld	(hl),b		;10c6
	inc	hl		;10c7
FFXIX1:	ld	(hl),$00	;10c8
	ld	hl,FBUFFR-1	;10ca
FOUBE1:	inc	hl		;10cd
FOUBE5:	ld	a,(TEMP2)	;10ce
	sub	l		;10d1
	sub	d		;10d2
	ret	z		;10d3
	ld	a,(hl)		;10d4
	cp	SPACE		;10d5
	jr	z,FOUBE1	;10d7
	cp	'*'		;10d9
	jr	z,FOUBE1	;10db
	dec	hl		;10dd
	push	hl		;10de
; ----------------------------------------------------------------------
; 10DF – MATH ROUTINE – “FOUBE2”
;   In this routine, we check to see if we can ignore the leading zero
;   before a decimal point.
;   If we see a leading zero, it must be the one before a decimal point
;   or else FOUTZS would have akready suppressed it. In that case, we
;   just INC HL over the character following the zero, and not have to
;   check for the decimal point explicitly.
; ----------------------------------------------------------------------
FOUBE2:	push	af		;10df
	ld	bc,FOUBE2	;10e0
	push	bc		;10e3
	GETCHR			;10e4 - rst 10h
	cp	'-'		;10e5
	ret	z		;10e7
	cp	'+'		;10e8
	ret	z		;10ea
	cp	'$'		;10eb
	ret	z		;10ed
	pop	bc		;10ee
	cp	'0'		;10ef
	jr	nz,FOUBE4	;10f1
	inc	hl		;10f3
	GETCHR			;10f4 - rst 10h
	jr	nc,FOUBE4	;10f5
	dec	hl		;10f7
;
	.DB	LDBCNN		;10f8 Z80 Trick - LD BC,nnnn - skip next 2 instructions
;
; ----------------------------------------------------------------------
; 10F9 – MATH ROUTINE – “FOUBE3”
;   If we can get rid of the zero, we put the characters on the STACK
;   back into the buffer one position in front of where they originally were.
;   Note that the maximum number of STACK levels this uses is three — one
;   for the last entry flag, one for a possible sign, and one for a possible $.
;   We don’t have to worry about the first character being in the buffer twice
;   because the pointer when FOUT exits will be pointing to the second occurance.
; ----------------------------------------------------------------------
FOUBE3:	dec	hl		;10f9
	ld	(hl),a		;10fa
	pop	af		;10fb
	jr	z,FOUBE3	;10fc
	pop	bc		;10fe
	jp	FOUBE5		;10ff
; ----------------------------------------------------------------------
; 1102 – MATH ROUTINE – “FOUBE4”
;   If the number is too big for the field, we wind up here to deal with that.
; ----------------------------------------------------------------------
FOUBE4:	pop	af		;1102
	jr	z,FOUBE4	;1103
	pop	hl		;1105
	ld	(hl),'%'	;1106
	ret			;1108
; ----------------------------------------------------------------------
; 1109 – MATH ROUTINE – “FOUFXV”
;   This is where the PRINT USING routine will print a single
;   or double precision number in a fixed format
; ----------------------------------------------------------------------
FOUFXV:	push	hl		;1109
	rra			;110a
	jp	c,FFXFLV	;110b
	jr	z,FFXSFX	;110e
	ld	de,FFXDXM	;1110
	call	DCOMPD		;1113
	ld	d,$10		;1116
	jp	m,FFXSDC	;1118
; ----------------------------------------------------------------------
; 111B – MATH ROUTINE – “FFXSDO”
;   This routine will print a number which is greaster than 10^16
;   in free format with a percent sign
; ----------------------------------------------------------------------
FFXSDO:	pop	hl		;111b
	pop	bc		;111c
	call	FOUT		;111d
	dec	hl		;1120
	ld	(hl),'%'	;1121
	ret			;1123
; ----------------------------------------------------------------------
; 1124 – MATH ROUTINE – “FFXSFX”
;   This routine will print a SINGLE PRECISION number in fixed format/fixed point notation
; ----------------------------------------------------------------------
FFXSFX:	ld	bc,$B60E	;1124 - Load Register Pair BC/DE with 1e16
	ld	de,$1BCA	;1127 - BC and DE  SP = to 1×10^16
	call	FCOMP		;112a
	jp	p,FFXSDO	;112d
	ld	d,$06		;1130
; ----------------------------------------------------------------------
; 1124 – MATH ROUTINE – “FFXSDC”
;   This routine will print a SINGLE or DOUBLE number in fixed format/point notation
; ----------------------------------------------------------------------
FFXSDC:	call	SIGN		;1132
	call	nz,FONTINV	;1135
	pop	hl		;1138
	pop	bc		;1139
	jp	m,FFXXVS	;113a
	push	bc		;113d
	ld	e,a		;113e
	ld	a,b		;113f
	sub	d		;1140
	sub	e		;1141
	call	p,FOTZER	;1142
	call	FOUTCD		;1145
	call	FOUTCV		;1148
	or	e		;114b
	call	nz,FOTZEC	;114c
	or	e		;114f
	call	nz,FOUTED	;1150
	pop	de		;1153
	jp	FOUTTD		;1154
; ----------------------------------------------------------------------
; 1157 – MATH ROUTINE – “FFXXVS”
;   This routine will print a SINGLE or DOUBLE number that has fractional digits
; ----------------------------------------------------------------------
FFXXVS:	ld	e,a		;1157
	ld	a,c		;1158
	or	a		;1159
	call	nz,DCRART	;115a
	add	a,e		;115d
	jp	m,FFXXV8	;115e
	xor	a		;1161
FFXXV8:	push	bc		;1162
	push	af		;1163
FFXXV2:	call	m,FINDIV	;1164
	jp	m,FFXXV2	;1167
	pop	bc		;116a
	ld	a,e		;116b
	sub	b		;116c
	pop	bc		;116d
	ld	e,a		;116e
	add	a,d		;116f
	ld	a,b		;1170
	jp	m,FFXXV3	;1171
	sub	d		;1174
	sub	e		;1175
	call	p,FOTZER	;1176
	push	bc		;1179
	call	FOUTCD		;117a
	jr	FFXXV6		;117d
; ----------------------------------------------------------------------
; 117F – MATH ROUTINE – “FFXXV3”
; ----------------------------------------------------------------------
FFXXV3:	call	FOTZER		;117f
	ld	a,c		;1182
	call	FOUTDP		;1183
	ld	c,a		;1186
	xor	a		;1187
	sub	d		;1188
	sub	e		;1189
	call	FOTZER		;118a
	push	bc		;118d
	ld	b,a		;118e
	ld	c,a		;118f
FFXXV6:	call	FOUTCV		;1190
	pop	bc		;1193
	or	c		;1194
	jr	nz,FFXXV7	;1195
	ld	hl,(TEMP2)	;1197
; ----------------------------------------------------------------------
; 119A – MATH ROUTINE – “FFXXV7”
;   This routine will print trailing zeroes.
; ----------------------------------------------------------------------
FFXXV7:	add	a,e		;119a
	dec	a		;119b
	call	p,FOTZER	;119c
	ld	d,b		;119f
	jp	FOUTTS		;11a0
; ----------------------------------------------------------------------
; 11A3 – MATH ROUTINE – “FFXIFL”
;   This routine will print an integer in fixed format/floating point notation.
; ----------------------------------------------------------------------
FFXIFL:	push	hl		;11a3
	push	de		;11a4
	call	CONSI		;11a5
	pop	de		;11a8
	xor	a		;11a9
; ----------------------------------------------------------------------
; 11AA – MATH ROUTINE – “FFXFLV”
;   This routine will print a SINGLE or DOUBLE PRECISION number in
;   fixed format/floating point notation.
; ----------------------------------------------------------------------
FFXFLV:	jp	z,FFXSFL	;11aa
	ld	e,$10		;11ad - maximum length of a double
;
	.DB	LDBCNN		;11af - Z80 Trick - LD BC,nnnn - skip 2 byte instruction
;
FFXSFL:	ld	e,$06		;11b0 - maximum length of a single precision value
	call	SIGN		;11b2
	scf			;11b5
	call	nz,FONTINV	;11b6
	pop	hl		;11b9
	pop	bc		;11ba
	push	af		;11bb
	ld	a,c		;11bc
	or	a		;11bd
	push	af		;11be
	call	nz,DCRART	;11bf
	add	a,b		;11c2
	ld	c,a		;11c3
	ld	a,d		;11c4
	and	$04		;11c5
	cp	$01		;11c7
	sbc	a,a		;11c9
	ld	d,a		;11ca
	add	a,c		;11cb
	ld	c,a		;11cc
	sub	e		;11cd
	push	af		;11ce
	push	bc		;11cf
FFXLV1:	call	m,FINDIV	;11d0
	jp	m,FFXLV1	;11d3
	pop	bc		;11d6
	pop	af		;11d7
	push	bc		;11d8
	push	af		;11d9
	jp	m,FFXLV3	;11da
	xor	a		;11dd
FFXLV3:	cpl			;11de
	inc	a		;11df
	add	a,b		;11e0
	inc	a		;11e1
	add	a,d		;11e2
	ld	b,a		;11e3
	ld	c,$00		;11e4
	call	FOUTCV		;11e6
	pop	af		;11e9
	call	p,FOTZNC	;11ea
	pop	bc		;11ed
	pop	af		;11ee
	call	z,DCXHRT	;11ef
	pop	af		;11f2
	jr	c,FFXLV2	;11f3
	add	a,e		;11f5
	sub	b		;11f6
	sub	d		;11f7
FFXLV2:	push	bc		;11f8
	call	FOFLDN		;11f9
	ex	de,hl		;11fc
	pop	de		;11fd
	jp	FOUTTS		;11fe
; ----------------------------------------------------------------------
; 1201 – Test the magnitude of SP and DP numbers,
;        and clear the times the value was scaled – “FOUTNV”
; ----------------------------------------------------------------------
FONTINV: push	de		;1201
	xor	a		;1202
	push	af		;1203
	TSTDAT			;1204
	jp	po,FOUNDB	;1205
FORBIG:	ld	a,(FAC)		;1208
	cp	$91		;120b
	jp	nc,FOUNDB	;120d
	ld	de,TENTEN	;1210
	ld	hl,ARGLO	;1213
	call	VMOVE		;1216
	call	DMULT		;1219
	pop	af		;121c
	sub	$0A		;121d
	push	af		;121f
	jr	FORBIG		;1220
; ----------------------------------------------------------------------
; 1222 – MATH ROUTINE – “FOUNDB”
; ----------------------------------------------------------------------
FOUNDB:	call	FOUNVC		;1222
FOUNDV1: TSTDAT			;1225
	jr	nc,FOUNDV4	;1226
	ld	bc,$9143	;1228
	ld	de,$4FF9	;122b
	call	FCOMP		;122e
	jr	FOUNDV5		;1231
FOUNDV4: ld	de,FOUTDL	;1233
	call	DCOMPD		;1236
FOUNDV5: jp	p,FOUNDV3	;1239
	pop	af		;123c
	call	FINMLT		;123d
	push	af		;1240
	jr	FOUNDV1		;1241
FOUNDVV: pop	af		;1243
	call	FINDIV		;1244
	push	af		;1247
	call	FOUNVC		;1248
FOUNDV3: pop	af		;124b
	pop	de		;124d
	or	a		;124c
	ret			;124e
; ----------------------------------------------------------------------
; 124F – MATH ROUTINE – “FOUNVC”
;   This routine will see if the number in the ACCumulator is small enough yet
; ----------------------------------------------------------------------
FOUNVC:	TSTDAT			;124f
	jp	pe,FONVC1	;1250
	ld	bc,$9474	;1253 - the exponent and the MSB of a single precision
	ld	de,$23F8	;1256 - BC and DE = (single precision) 999,999.5
	call	FCOMP		;1259
	jr	FONVC2		;125c
FONVC1:	ld	de,FOUTDU	;125e
	call	DCOMPD		;1261
FONVC2:	pop	hl		;1264
	jp	p,FOUNDVV	;1265
	jp	(hl)		;1268
; ----------------------------------------------------------------------
; 1269H – MATH ROUTINE – “FOTZER”
;   This routine puts leading zeroes into the input buffer. The count is held in A
;   and it can be zero, but the Z FLAG needs to be set in that case.
;   Only (HL) and Register A are affected.
; ----------------------------------------------------------------------
FOTZER:	or	a		;1269
FOTZR1:	ret	z		;126a
	dec	a		;126b
	ld	(hl),$30	;126c
	inc	hl		;126e
	jr	FOTZR1		;126f
; ----------------------------------------------------------------------
; 1271 – MATH ROUTINE – “FOTZNC”
;   This routine will put zeroes in the buffer along with commans or a decimal
;   point in the middle.
; ----------------------------------------------------------------------
FOTZNC:	jr	nz,FOTZEC	;1271
FOTZRC:	ret	z		;1273
	call	FOUTED		;1274
FOTZEC:	ld	(hl),$30	;1277
	inc	hl		;1279
	dec	a		;127a
	jr	FOTZRC		;127b
; ----------------------------------------------------------------------
; 127D – MATH ROUTINE – “FOUTCD”
;    This routine will put a possible comma count into Register C and will
;    zero Register C if we are not using commas in the specification.
; ----------------------------------------------------------------------
FOUTCD:	ld	a,e		;127d
	add	a,d		;127e
	inc	a		;127f
	ld	b,a		;1280
	inc	a		;1281
FOTCD1:	sub	$03		;1282
	jr	nc,FOTCD1	;1284
	add	a,$05		;1286
	ld	c,a		;1288
FOUICC:	ld	a,(TEMP3)	;1289
	and	$40		;128c
	ret	nz		;128e
	ld	c,a		;128f
	ret			;1290
; ----------------------------------------------------------------------
; 1291 – MATH ROUTINE – “FOUTED”
;   This routine will put decimal points and commas in their correct places.
;   This subroutine should be called before the next digit is put in the buffer.
;   Register B = the decimal point count and Register C = the comma count.
; ----------------------------------------------------------------------
FOUTED:	dec	b		;1291
	jr	nz,FOUED1	;1292
FOUTDP:	ld	(hl),'.'	;1294
	ld	(TEMP2),hl	;1296
	inc	hl		;1299
	ld	c,b		;129a
	ret			;129b
; ----------------------------------------------------------------------
; 129C – MATH ROUTINE – “FOUED1”
;   Part of the above routine, jumped here to test to see if a comma needs
;   to be placed at (HL).
; ----------------------------------------------------------------------
FOUED1:	dec	c		;129c
	ret	nz		;129d
	ld	(hl),','	;129e
	inc	hl		;12a0
	ld	c,$03		;12a1
	ret			;12a3
; ----------------------------------------------------------------------
; 12A4 – MATH ROUTINE – “FOUTCV”
;   This routine will convert a SINGLE or a DOUBLE PRECISION number
;   that has been normalized to decimal digits.
; ----------------------------------------------------------------------
FOUTCV:	push	de		;12a4
	TSTDAT			;12a5
	jp	po,FOUTCS	;12a6
	push	bc		;12a9
	push	hl		;12aa
	call	VMOVAF		;12ab
	ld	hl,DHALF	;12ae
	call	VMOVFM		;12b1
	call	DADD		;12b4
	xor	a		;12b7
	call	DINTFO		;12b8
	pop	hl		;12bb
	pop	bc		;12bc
	ld	de,FODTBL	;12bd
	ld	a,$0A		;12c0
FOUCD1:	call	FOUTED		;12c2
	push	bc		;12c5
	push	af		;12c6
	push	hl		;12c7
	push	de		;12c8
	ld	b,$2F		;12c9
FOUCD2:	inc	b		;12cb
	pop	hl		;12cc
	push	hl		;12cd
	call	DADDFS		;12ce
	jr	nc,FOUCD2	;12d1
	pop	hl		;12d3
	call	DADDFO		;12d4
	ex	de,hl		;12d7
	pop	hl		;12d8
	ld	(hl),b		;12d9
	inc	hl		;12da
	pop	af		;12db
	pop	bc		;12dc
	dec	a		;12dd
	jr	nz,FOUCD1	;12de
	push	bc		;12e0
	push	hl		;12e1
	ld	hl,DFACLO	;12e2
	call	MOVFM		;12e5
	jr	FOUCDC		;12e8
; ----------------------------------------------------------------------
; 12EA – MATH CONVERSION ROUTINE – “FOUTCS”
; This routine is to convert a SINGLE precision value to an INTEGER which will be the decimal digits.
; ----------------------------------------------------------------------
FOUTCS:	push	bc		;12ea
	push	hl		;12eb
	call	FADDH		;12ec
	inc	a		;12ef
	call	QINT		;12f0
	call	MOVFR		;12f3
FOUCDC:	pop	hl		;12f6
	pop	bc		;12f7
	xor	a		;12f8
	ld	de,FOSTBL	;12f9
; ----------------------------------------------------------------------
; 12FC – MATH ROUTINE – “FOUCS1”
;   This routine is to calculate the next digit of the number.
; ----------------------------------------------------------------------
FOUCS1:	ccf			;12fc
	call	FOUTED		;12fd
	push	bc		;1300
	push	af		;1301
	push	hl		;1302
	push	de		;1303
	call	MOVRF		;1304
	pop	hl		;1307
	ld	b,$2F		;1308
; ----------------------------------------------------------------------
; 130A – MATH ROUTINE – “FOUCS2”
;   This routine divides the integer portion of the current value
;   by 100,000 using compound subtraction.
; ----------------------------------------------------------------------
FOUCS2:	inc	b		;130a
	ld	a,e		;130b
	sub	(hl)		;130c
	ld	e,a		;130d
	inc	hl		;130e
	ld	a,d		;130f
	sbc	a,(hl)		;1310
	ld	d,a		;1311
	inc	hl		;1312
	ld	a,c		;1313
	sbc	a,(hl)		;1314
	ld	c,a		;1315
	dec	hl		;1316
	dec	hl		;1317
	jr	nc,FOUCS2	;1318
	call	FADDA		;131a
	inc	hl		;131d
	call	MOVFR		;131e
	ex	de,hl		;1321
	pop	hl		;1322
	ld	(hl),b		;1323
	inc	hl		;1324
	pop	af		;1325
	pop	bc		;1326
	jr	c,FOUCS1	;1327
	inc	de		;1329
	inc	de		;132a
	ld	a,$04		;132b
	jr	FOUCI1		;132d
;
; ======================================================================
; 132F – INTEGER to ASCII – “FOUTCI”
;
;   This routine converts an integer into decimal digits by dividing
;   the integer portion of the current value by 100,000 using compound
;   subtraction. The quotient is kept in Register B as an ASCII value
;   and A=0 on exit.
; ----------------------------------------------------------------------
FOUTCI:	push	de		;132f
	ld	de,FOITBL	;1330
	ld	a,$05		;1333
FOUCI1:	call	FOUTED		;1335
	push	bc		;1338
	push	af		;1339
	push	hl		;133a
	ex	de,hl		;133b
	ld	c,(hl)		;133c
	inc	hl		;133d
	ld	b,(hl)		;133e
	push	bc		;133f
	inc	hl		;1340
	ex	(sp),hl		;1341
	ex	de,hl		;1342
	ld	hl,(FACLO)	;1343
	ld	b,$2F		;1346
FOUCI2:	inc	b		;1348
	ld	a,l		;1349
	sub	e		;134a
	ld	l,a		;134b
	ld	a,h		;134c
	sbc	a,d		;134d
	ld	h,a		;134e
	jr	nc,FOUCI2	;134f
	add	hl,de		;1351
	ld	(FACLO),hl	;1352
	pop	de		;1355
	pop	hl		;1356
	ld	(hl),b		;1357
	inc	hl		;1358
	pop	af		;1359
	pop	bc		;135a
	dec	a		;135b
	jr	nz,FOUCI1	;135c
	call	FOUTED		;135e
	ld	(hl),a		;1361
	pop	de		;1362
	ret			;1363
;
; ----------------------------------------------------------------------
; 1364-136B – DOUBLE PRECISION CONSTANT STORAGE LOCATION – “TENTEN”
; A double precision constant equal to 10000000000
; ----------------------------------------------------------------------
TENTEN:	.DB	$00, $00, $00, $00, $F9, $02, $15, $A2
;
; ----------------------------------------------------------------------
; 136C-1373 – DOUBLE PRECISION CONSTANT STORAGE LOCATION – “FOUTDL”
; A double precision constant equal to 999,999,999,999,999.95
; ----------------------------------------------------------------------
FOUTDL:	.DB	$FD, $FF, $9F, $31, $A9, $5F, $63, $B2
;
; ----------------------------------------------------------------------
; 1374-137B – DOUBLE PRECISION CONSTANT STORAGE LOCATION – “FOUTDU”
; A double precision constant equal to 9,999,999,999,999,999.5
; ----------------------------------------------------------------------
FOUTDU:	.DB	$FE, $FF, $03, $BF, $C9, $1B, $0E, $B6
;
; ----------------------------------------------------------------------
; 137C-1383 – DOUBLE PRECISION CONSTANT STORAGE LOCATION – “DHALF”
; ----------------------------------------------------------------------
; A double precision constant equal to 0.5D0 .
DHALF:	.DB	$00, $00, $00, $00
;
; A single precision constant equal to 0.5E0 .
; Referencing : half-way through double precision value, results in a single precision value of 0.5
FHALF:	.DB	$00, $00, $00, $80
;
; ----------------------------------------------------------------------
; 1384-138B – DOUBLE PRECISION CONSTANT STORAGE LOCATION – “FFXDXM”
; A double precision constant equal to 1D16
; ----------------------------------------------------------------------
FFXDXM:	.DB	$00, $00, $04, $BF, $C9, $1B, $0E, $B6
;
; ----------------------------------------------------------------------
; 138C-13D1 – DOUBLE PRECISION INTEGER CONSTANT STORAGE LOCATION – “FODTBL”
; ----------------------------------------------------------------------
FODTBL:	.DB	$00, $80, $C6, $A4, $7E, $8D, $03	; 1D15
	.DB	$00, $40, $7A, $10, $F3, $5A, $00	; 1D14
	.DB	$00, $A0, $72, $4E, $18, $09, $00	; 1D13
	.DB	$00, $10, $A5, $D4, $E8, $00, $00	; 1D12
	.DB	$00, $E8, $76, $48, $17, $00, $00	; 1D10
	.DB	$00, $E4, $0B, $54, $02, $00, $00	; 1D9
	.DB	$00, $CA, $9A, $3B, $00, $00, $00	; 1D8
	.DB	$00, $E1, $F5, $05, $00, $00, $00	; 1D7
	.DB	$80, $96, $98, $00, $00, $00, $00	; 1D6
	.DB	$40, $42, $0F, $00, $00, $00, $00	; 1D5
;
; NOTE: The above data does not (exactly) match what is held
; in the TRS-80 web site rom disassembly
;
; ----------------------------------------------------------------------
; 13D2-13D7 – SINGLE PRECISION POWER OF TEN TABLE LOCATION – “FOSTBL
; ----------------------------------------------------------------------
FOSTBL:	.DB	$A0, $86, $01	; 1E5
	.DB	$10, $27, $00	; 1E4
;
; ----------------------------------------------------------------------
; 13D8 - 13E1 – SINGLE PRECISION POWER OF TEN TABLE LOCATION – “FOITBL
; ----------------------------------------------------------------------
FOITBL:	.DB	$10, $27	; 10,000
	.DB	$E8, $03	; 1,000
	.DB	$64, $00	; 100
	.DB	$0A, $00	; 10
	.DB	$01, $00	; 1
;
; ----------------------------------------------------------------------
; 13E2-13E6 – MATH ROUTINE – “PSHNEG”
; ----------------------------------------------------------------------
PSHNEG:	ld	HL,NNEG		; address of the routine for conversion of floating point numbers from negative to positive
	ex	(sp),hl		;13e5
	jp	(hl)		;13e6
;
; ======================================================================
; 13E7 – LEVEL II BASIC SQR(n) – “FNSQR”
;   This routine computes the square root of any value in ACC. It processes
;   it by raising n to the power of 0.5. The root is left in ACC as a single
;   precision value. Single-precision values only should be used
; ----------------------------------------------------------------------
FNSQR:	call	PUSHF		;13e7
	ld	hl,FHALF	;13ea
	call	MOVFM		;13ed
	jr	FPWRT		;13f0
;
; ======================================================================
; 13F2 - LEVEL II BASIC X to the Y Power (X^Y) ROUTINE – “FPWRQ”
;
;   A call to 13F2H raises the single precision value which has been
;   saved to the STACK to the power specified in ACC. The result will be
;   returned in ACC. The method of computation is e ** (y ln x).
; ----------------------------------------------------------------------
FPWRQ:	call	FRCSNG		;13f2
FPWRT:	pop	bc		;13f5
	pop	de		;13f6
;
; ----------------------------------------------------------------------
; 13F7 – LEVEL II BASIC Exponentiation routine – “FPWR”
;   This routine handles the exponentiation routine of X^Y. To do so,
;   first Y is checked for 0 and, if so, then the answer is simply 1.
;   Then we check X for 0 and, if so, then the answer is simply 0.
; ----------------------------------------------------------------------
FPWR:	call	SIGN		;13f7
	ld	a,b		;13fa
	jr	z,FNEXP		;13fb
	jp	p,POSEXP	;13fd
	or	a		;1400
	jp	z,DV0ERR	;1401
POSEXP:	or	a		;1404
	jp	z,ZERO0		;1405
	push	de		;1408
	push	bc		;1409
	ld	a,c		;140a
	or	$7F		;140b
	call	MOVRF		;140d
	jp	p,FPWR1		;1410
	push	de		;1413
	push	bc		;1414
	call	IINT		;1415
	pop	bc		;1418
	pop	de		;1419
	push	af		;141a
	call	FCOMP		;141b
	pop	hl		;141e
	ld	a,h		;141f
	rra			;1420
FPWR1:	pop	hl		;1421
	ld	(FAC-1),hl	;1422
	pop	hl		;1425
	ld	(FACLO),hl	;1426
	call	c,PSHNEG	;1429
	call	z,NNEG		;142c
	push	de		;142f
	push	bc		;1430
	call	FNLOG		;1431
	pop	bc		;1434
	pop	de		;1435
	call	FMULT		;1436
;
; ======================================================================
; 1439 – LEVEL II ROM EXP ROUTINE. Function "FNEXP"
;
;   Single-precision only. (ACCumulator = EXP(REG1)).
; ----------------------------------------------------------------------
FNEXP:	call	PUSHF		;1439
	ld	bc,$8138	;143c
	ld	de,$AA3B	;143f
	call	FMULT		;1442
	ld	a,(FAC)		;1445
	cp	$88		;1448
	jp	nc,MLDVEX	;144a
	call	IINT		;144d
	add	a,$80		;1450
	add	a,$02		;1452
	jp	c,MLDVEX	;1454
	push	af		;1457
	ld	hl,FONE		;1458
	call	FADDS		;145b
	call	MULLN2		;145e
	pop	af		;1461
	pop	bc		;1462
	pop	de		;1463
	push	af		;1464
	call	FSUB		;1465
	call	NNEG		;1468
	ld	hl,EXPCON	;146b
	call	POLY		;146e
	ld	de,$0000	;1471
	pop	bc		;1474
	ld	c,d		;1475
	jp	FMULT		;1476
;
; ----------------------------------------------------------------------
; 1479-1499 – SINGLE PRECISION CONSTANT STORAGE LOCATION
; This represents 1/6, -1/5, 1/4, -1/3, 1/2, -1, and 1 – “EXPCON”
; ----------------------------------------------------------------------
;
EXPCON:	.DB	$08		; number of constants which follow
	.DB	$40, $2E, $94, $74; constant equal to -0.00014171607 (-1.413165 * 10e-4)
	.DB	$70, $4F, $2E, $77; constant equal to 0.00132988204 (1.32988 * 10e-3, roughly -1/6)
	.DB	$6E, $02, $88, $7A; constant equal to -0.00830136052 (-8.30136 * 10e-3, roughly -1/5)
	.DB	$E6, $A0, $2A, $7C; constant equal to 0.04165735095 (roughly 1/4)
	.DB	$50, $AA, $AA, $7E; constant equal to -0.16666531543 (roughly -1/3)
	.DB	$FF, $FF, $7F, $7F; constant equal to 0.49999996981 (roughly 1/2)
	.DB	$00, $00, $80, $81; constant equal to -1.0
	.DB	$00, $00, $00, $81; constant equal to 1.0
;
; ----------------------------------------------------------------------
; 149A-14C8 – MATH ROUTINE – “POLYX”
;   This is a general purpose summation routine which computes the series
;   C0*X+C1*X^3+C2*X^5+C3*X^7+…+C(N)*X^(2*N+1) for I=0 to N when entered
;   at 149AH If entered at 14A9H the series changes to
;   SUM ((((x*c0+c1)x*c2)x+c3)x+.cN. On entry, the x is held in BC/DE and
;   HL points to a list containing the number of terms followed by the coefficients.
; ----------------------------------------------------------------------
POLYX:	call	PUSHF		;149a
	ld	de,FMULTT	;149d - Load Register Pair DE with the return address of the FMULTT routine …
	push	de		;14a0
	push	hl		;14a1
	call	MOVRF		;14a2
	call	FMULT		;14a5
	pop	hl		;14a8
; ----------------------------------------------------------------------
; 14A9 – MATH ROUTINE – “POLY”
;   General polynomial evaluator routine. Pointer to degree+1 is in (HL),
;   and that gets updated through the computation. The Constants follow
;   the degree and should be stored in reverse order. The ACCumulator has
;   the X. The formula is c0+c1*x+c2*x^2+c3*x^3+…+c(n-1)*x^(n-1)+c(n)*x^n
; ----------------------------------------------------------------------
POLY:	call	PUSHF		;14a9
	ld	a,(hl)		;14ac
	inc	hl		;14ad
	call	MOVFM		;14ae
;
; Z-80 Trick! If passing through, this will simply alter
;Register B and the next instruction of POP AF will not be processed.
	.DB	LDBNN		;14b1
;
POLY1:	pop	af		;14b2
	pop	bc		;14b3
	pop	de		;14b4
	dec	a		;14b5
	ret	z		;14b6
	push	de		;14b7
	push	bc		;14b8
	push	af		;14b9
	push	hl		;14ba
	call	FMULT		;14bb
	pop	hl		;14be
	call	MOVRM		;14bf
	push	hl		;14c2
	call	FADD		;14c3
	pop	hl		;14c6
	jr	POLY1		;14c7
;
; ----------------------------------------------------------------------
; 14C9-1540 – LEVEL II BASIC RND(n) ROUTINE – “FNRND”.
;   If the passed argument is 0, the last random number generated is returned.
;   If the argument is < 0, a new sequence of random numbers is started using the argument.
; ----------------------------------------------------------------------
FNRND:	call	FRCINT		;14c9
	ld	a,h		;14cc
	or	a		;14cd
	jp	m,FCERR		;14ce
	or	l		;14d1
	jp	z,RND0		;14d2
	push	hl		;14d5
	call	RND0		;14d6
	call	MOVRF		;14d9
	ex	de,hl		;14dc
	ex	(sp),hl		;14dd
	push	bc		;14de
	call	CONSIH		;14df
	pop	bc		;14e2
	pop	de		;14e3
	call	FMULT		;14e4
	ld	hl,FONE		;14e7
	call	FADDS		;14ea
	jp	IINT		;14ed
;
; ----------------------------------------------------------------------
; 14F0 – This routine calculates RND(0) – “RND0”.
; ----------------------------------------------------------------------
RND0:	ld	hl,MULTR	;14f0
	push	hl		;14f3
	ld	de,$0000	;14f4
	ld	c,e		;14f7
	ld	h,$03		;14f8
RND00:	ld	l,$08		;14fa
RND01:	ex	de,hl		;14fc
	add	hl,hl		;14fd
	ex	de,hl		;14fe
	ld	a,c		;14ff
	rla			;1500
	ld	c,a		;1501
	ex	(sp),hl		;1502
	ld	a,(hl)		;1503
	rlca			;1504
	ld	(hl),a		;1505
	ex	(sp),hl		;1506
	jp	nc,RND02	;1507
	push	hl		;150a
	ld	hl,(RNDX)	;150b
	add	hl,de		;150e
	ex	de,hl		;150f
	ld	a,(RNDX+2)	;1510
	adc	a,c		;1513
	ld	c,a		;1514
	pop	hl		;1515
RND02:	dec	l		;1516
	jp	nz,RND01	;1517
	ex	(sp),hl		;151a
	inc	hl		;151b
	ex	(sp),hl		;151c
	dec	h		;151d
	jp	nz,RND00	;151e
	pop	hl		;1521
	ld	hl,$B065	;1522
	add	hl,de		;1525
	ld	(RNDX),hl	;1526
	call	VALSNG		;1529
	ld	a,$05		;152c
	adc	a,c		;152e
	ld	(RNDX+2),a	;152f
	ex	de,hl		;1532
	ld	b,$80		;1533
	ld	hl,FACSGN	;1535
	ld	(hl),b		;1538
	dec	hl		;1539
	ld	(hl),b		;153a
	ld	c,a		;153b
	ld	b,$00		;153c
	jp	NORMAL		;153e
;
; ======================================================================
; 1541 – LEVEL II BASIC COS - FUNCTION "FNCOS"
;
;   Single-precision only.(ACCumulator = COS(ACCumulator)). A call to 1541H
;   computes the cosine for an angle given in radians. The angle must be a
;   floating point value in ACCumulator; the cosine will be returned in
;   ACCumulator as a floating point value.
; ----------------------------------------------------------------------
FNCOS:	ld	hl,PI2		;1541
	call	FADDS		;1544
;
; ======================================================================
; 1547 – LEVEL II BASIC SIN ROUTINE – “SIN”
;
;   Returns the sine as a single precision value in WRA1. The
;   sine must be given in radians in WRA1.
;   Single-precision only.(ACCumulator = SIN(ACCumulator)).
; ----------------------------------------------------------------------
FNSIN:	call	PUSHF		;1547
	ld	bc,$8349	;154a -exponent and the MSB of a single precision constant
	ld	de,$0FDB	;154d -NMSB and the LSB of a single precision constant
	call	MOVFR		;1550
	pop	bc		;1553
	pop	de		;1554
	call	FDIV		;1555
	call	PUSHF		;1558
	call	IINT		;155b
	pop	bc		;155e
	pop	de		;155f
	call	FSUB		;1560
	ld	hl,FR4		;1563
	call	FSUBS		;1566
	call	SIGN		;1569
	scf			;156c
	jp	p,SIN1		;156d
	call	FADDH		;1570
	call	SIGN		;1573
	or	a		;1576
SIN1:	push	af		;1577
	call	p,NNEG		;1578
	ld	hl,FR4		;157b
	call	FADDS		;157e
	pop	af		;1581
	call	nc,NNEG		;1582
	ld	hl,SINCON	;1585
	jp	POLYX		;1588
;
; ----------------------------------------------------------------------
; 158B-158E – SINGLE PRECISION CONSTANT STORAGE LOCATION – “PI2”
; ----------------------------------------------------------------------
PI2:	.DB	$DB, $0F, $49, $81
; ----------------------------------------------------------------------
; 158F-1592 – SINGLE PRECISION CONSTANT STORAGE LOCATION – “FR4”
; ----------------------------------------------------------------------
FR4:	.DB	$00, $00, $00, $7F
; ----------------------------------------------------------------------
; 1593-15A7 – SINGLE PRECISION CONSTANTS STORAGE LOCATION – “SINCON”
; ----------------------------------------------------------------------
;
SINCON:	.DB	05H		; The number of single precision constants (05) which follows
; These are the coefficients used in the power series to compute SIN(x)
	.DB	$BA, $D7, $1E, $86; 39.7106704708
	.DB	$64, $26, $99, $87; -76.5749816893
	.DB	$58, $34, $23, $87; 81.6022338865
	.DB	$E0, $5D, $A5, $86; -41.3416748045
	.DB	$DA, $0F, $49, $83; 6.28318500497
;
; ======================================================================
; 15A8 – LEVEL II BASIC TAN(n) ROUTINE – “FNTAN”
;   Computes the tangent of an angle in radians. The angle must be specified
;   as a single precision value in WRA1. The tangent will be left in WRA1
;   Single-precision only.(ACCumulator = TAN(ACCumulator)).
; ----------------------------------------------------------------------
FNTAN:	call	PUSHF		;15a8
	call	FNSIN		;15ab
	pop	bc		;15ae
	pop	hl		;15af
	call	PUSHF		;15b0
	ex	de,hl		;15b3
	call	MOVFR		;15b4
	call	FNCOS		;15b7
	jp	FDIVT		;15ba
;
; ======================================================================
; 15BD – LEVEL II BASIC ATN(n) ROUTINE – “ATN”.
;   Returns the angle in radians, for the floating point tangent value in WRA1.
;   The angle will be left as a single precision value in WRA1
;   Single-precision only.(ACCumulator = ATN(ACCumulator)).
; ----------------------------------------------------------------------
ATAN:	call	SIGN		;15bd
	call	m,PSHNEG	;15c0
	call	m,NNEG		;15c3
	ld	a,(FAC)		;15c6
	cp	$81		;15c9
	jr	c,ATAN2		;15cb
	ld	bc,$8100	;15cd
	ld	d,c		;15d0
	ld	e,c		;15d1
	call	FDIV		;15d2
	ld	hl,FSUBS	;15d5
	push	hl		;15d8
ATAN2:	ld	hl,ATNCON	;15d9
	call	POLYX		;15dc
	ld	hl,PI2		;15df
	ret			;15e2
;
; ----------------------------------------------------------------------
; 15E3-1607 – SINGLE PRECISION CONSTANTS STORAGE LOCATION – “ATNCON”
; ----------------------------------------------------------------------
ATNCON:	.DB	$09		; number constants which follows
	.DB	$4A, $D7, $3B, $78; 0.00286622549
	.DB	$02, $6E, $84, $7B; -0.01616573699
	.DB	$FE, $C1, $2F, $7C; 0.04290961441
	.DB	$74, $31, $9A, $7D; 0.07528963666
	.DB	$84, $3D, $5A, $7D; 0.10656264407
	.DB	$C8, $7F, $91, $7E; -0.14208900905
	.DB	$E4, $BB, $4C, $7E; 0.19993549561
	.DB	$6C, $AA, $AA, $7F; -0.33333146561
	.DB	$00, $00, $00, $81; 1.0
;
; ----------------------------------------------------------------------
; 1608-18C8 – LIST OF BASIC RESERVED WORDS, TOKENS, AND ENTRY LOCATIONS
; ----------------------------------------------------------------------
;  The original ROM source code makes an interesting note about the order
;  of these reserved words. Some reserved words are contained in other
;  reserved words, which will cause a problem.
; ----------------------------------------------------------------------
;
; ----------------------------------------------------------------------
; 1608-164F - Function Dispatch Table
;           - for functions stating at token $D7 (SGN) to $FA (MID$)
; ----------------------------------------------------------------------
FUNDSP:
	.DW	FNSGN		; SGN() - ($D7)
	.DW	FNINT		; INT()
	.DW	FNABS		; ABS()
	.DW	FNFRE		; FRE
	.DW	FNINP		; INP
	.DW	FNPOS		; POS()
	.DW	FNSQR		; SQR()
	.DW	FNRND		; RND()
	.DW	FNLOG		; LOG()
	.DW	FNEXP		; EXP()
	.DW	FNCOS		; COS()
	.DW	FNSIN		; SIN()
	.DW	FNTAN		; TAN()
	.DW	ATAN		; ATAN()
	.DW	PEEK		; PEEK - ($E5)
;
; DISK IO FUNCTIONS (VECTORS) offset from base
	.DW	DVCVI		; CVI - ($E6)
	.DW	DVCVS		; CVS
	.DW	DVCVD		; CVD
	.DW	DVEOF		; EOF
	.DW	DVLOC		; LOC
	.DW	DVLOF		; LOF
	.DW	DVMKI		; MKI
	.DW	DVMKS		; MKS
	.DW	DVMKD		; MKD - ($EE)
; END of DISK IO Functions
;
	.DW	FRCINT		; CINT() - ($EF)
	.DW	FRCSNG		; CSNG()
	.DW	FRCDBL		; CDBL
	.DW	FNFIX		; FIX
	.DW	FNLEN		; LEN
	.DW	FNSTR		; STR$
	.DW	FNVAL		; VAL
	.DW	FNASC		; ASC
	.DW	FNCHR		; CHR$
	.DW	FNLEFT		; LEFT$
	.DW	FNRGT		; RIGHT$
	.DW	FNMID		; MID$ - Disk Basic Token - ($FA)
;
; ----------------------------------------------------------------------
; 1650-1821 - Reserved key word list (in token order)
;       * first character ored with 80h to denote start of new token
;       * token ID's start from $80 and increment
;	* token ID is in the comments for reference purposes
;	* table is broken into statments, followed by functions
; ----------------------------------------------------------------------
RESLST:
	.DB	$C5,"ND"	; END   - $80
	.DB	$C6,"OR"	; FOR   - $81
	.DB	$D2,"ESET"	; RESET - $82
	.DB	$D3,"ET"	; SET   - $83
	.DB	$C3,"LS"	; CLS
	.DB	$C3,"MD"	; CMD (disk) - $85
	.DB	$D2,"ANDOM"	; RANDOM
	.DB	$CE,"EXT"	; NEXT  - $87
	.DB	$C4,"ATA"	; DATA  - $88
	.DB	$C9,"NPUT"	; INPUT
	.DB	$C4,"IM"	; DIM
	.DB	$D2,"EAD"	; READ
	.DB	$CC,"ET"	; LET
	.DB	$C7,"OTO"	; GOTO  - $8D
	.DB	$D2,"UN"	; RUN
	.DB	$C9,"F"		; IF    - $8F
	.DB	$D2,"ESTORE"	; RESTORE
	.DB	$C7,"OSUB"	; GOSUB - $91
	.DB	$D2,"ETURN"	; RETURN
	.DB	$D2,"EM"	; REM   - $93
	.DB	$D3,"TOP"	; STOP
	.DB	$C5,"LSE"	; ELSE  - $95
	.DB	$D4,"RON"	; TRON
	.DB	$D4,"ROFF"	; TROFF
	.DB	$C4,"EFSTR"	; DEFSTR
	.DB	$C4,"EFINT"	; DEFINT
	.DB	$C4,"EFSNG"	; DEFSNG
	.DB	$C4,"EFDBL"	; DEFDBL
	.DB	$CC,"INE"	; LINE (disk) - $9C
	.DB	$C5,"DIT"	; EDIT
	.DB	$C5,"RROR"	; ERROR  - $9E
	.DB	$D2,"ESUME"	; RESUME - $9F
	.DB	$CF,"UT"	; OUT
	.DB	$CF,"N"		; ON     - $A1
	.DB	$CF,"PEN"	; OPEN (disk) - $A2
	.DB	$C6,"IELD"	; FIELD (disk)
	.DB	$C7,"ET"	; GET (disk)
	.DB	$D0,"UT"	; PUT (disk)
	.DB	$C3,"LOSE"	; CLOSE (disk)
	.DB	$CC,"OAD"	; LOAD (disk)
	.DB	$CD,"ERGE"	; MERGE (disk)
	.DB	$CE,"AME"	; NAME (disk)
	.DB	$CB,"ILL"	; KILL (disk)
	.DB	$CC,"SET"	; LSET (disk)
	.DB	$D2,"SET"	; RSET (disk)
	.DB	$D3,"AVE"	; SAVE (disk) - $AD
	.DB	$D3,"YSTEM"	; SYSTEM
	.DB	$CC,"PRINT"	; LPRINT
	.DB	$C4,"EF"	; DEF (disk) - $B0
	.DB	$D0,"OKE"	; POKE
	.DB	$D0,"RINT"	; PRINT - $B2
	.DB	$C3,"ONT"	; CONT
	.DB	$CC,"IST"	; LIST
	.DB	$CC,"LIST"	; LLIST
	.DB	$C4,"ELETE"	; DELETE
	.DB	$C1,"UTO"	; AUTO
	.DB	$C3,"LEAR"	; CLEAR
	.DB	$C3,"LOAD"	; CLOAD
	.DB	$C3,"SAVE"	; CSAVE
	.DB	$CE,"EW"	; NEW   - $BB
	;
	; The following are Functions
	;
	.DB	$D4,"AB("	; TAB()     - $BC
	.DB	$D4,"O"		; TO        - $BD
	.DB	$C6,"N"		; FN (disk) - $BE
	.DB	$D5,"SING"	; USING     - $BF
	.DB	$D6,"ARPTR"	; VARPTR
	.DB	$D5,"SR"	; USR
	.DB	$C5,"RL"	; ERL
	.DB	$C5,"RR"	; ERR
	.DB	$D3,"TRING$"	; STRING$
	.DB	$C9,"NSTR"	; INSTR
	.DB	$D0,"OINT"	; POINT
	.DB	$D4,"IME$"	; TIME$ (disk) - $C7
	.DB	$CD,"EM"	; MEM
	.DB	$C9,"NKEY$"	; INKEY$
	.DB	$D4,"HEN"	; THEN
	.DB	$CE,"OT"	; NOT  - $CB
	.DB	$D3,"TEP"	; STEP - $CC
;
	.DB	$AB		; + ($CD)
	.DB	$AD		; - ($CE)
	.DB	$AA		; *
	.DB	$AF		; /
	.DB	$DB		; [ - (up arrow)
;
	.DB	$C1,"ND"	; AND - $D2
	.DB	$CF,"R"		; OR  - $D3
;
	.DB	$BE		; > ($D4)
	.DB	$BD		; =
	.DB	$BC		; < ($D6)
;
	.DB	$D3,"GN"	; SGN - $D7
	.DB	$C9,"NT"	; INT - $D8
	.DB	$C1,"BS"	; ABS
	.DB	$C6,"RE"	; FRE
	.DB	$C9,"NP"	; INP
	.DB	$D0,"OS"	; POS
	.DB	$D3,"QR"	; SQR
	.DB	$D2,"ND"	; RND
	.DB	$CC,"OG"	; LOG
	.DB	$C5,"XP"	; EXP
	.DB	$C3,"OS"	; COS
	.DB	$D3,"IN"	; SIN
	.DB	$D4,"AN"	; TAN
	.DB	$C1,"TN"	; ATN
	.DB	$D0,"EEK"	; PEEK
	.DB	$C3,"VI"	; CVI (disk) - $E6
	.DB	$C3,"VS"	; CVS (disk)
	.DB	$C3,"VD"	; CVD (disk)
	.DB	$C5,"OF"	; EOF (disk)
	.DB	$CC,"OC"	; LOC (disk)
	.DB	$CC,"OF"	; LOF (disk)
	.DB	$CD,"KI$"	; MKI$ (disk)
	.DB	$CD,"KS$"	; MKS$ (disk)
	.DB	$CD,"KD$"	; MKD$ (disk) - $ED
	.DB	$C3,"INT"	; CINT
	.DB	$C3,"SNG"	; CSNG
	.DB	$C3,"DBL"	; CDBL
	.DB	$C6,"IX"	; FIX
	.DB	$CC,"EN"	; LEN
	.DB	$D3,"TR$"	; STR$
	.DB	$D6,"AL"	; VAL
	.DB	$C1,"SC"	; ASC
	.DB	$C3,"HR$"	; CHR$
	.DB	$CC,"EFT$"	; LEFT$  - $F8
	.DB	$D2,"IGHT$"	; RIGHT$ - $F9
	.DB	$CD,"ID$"	; MID$   - $FA
;
	.DB	$A7		; ' (REM)- $FB
;
	.DB	80h		; TERMINATOR.
;
; ----------------------------------------------------------------------
; 1822-1898 - Statement Dispatch Table (command addresses)
;           - in token order staring at token $80 - ending at $BB
; ----------------------------------------------------------------------
STMDSP:
	.DW	END		; END - ID = $80
	.DW	FOR		; FOR
	.DW	RESET		; RESET
	.DW	SET		; SET
	.DW	CLS		; CLS
	.DW	DVCMD		; CMD ( Command Vector )
	.DW	RANDOM		; RANDOM
	.DW	NEXT		; NEXT
	.DW	DATA		; DATA
	.DW	INPUT		; INPUT
	.DW	DIM		; DIM
	.DW	READ		; READ
	.DW	LET		; LET
	.DW	GOTO		; GOTO
	.DW	RUN		; RUN
	.DW	IF		; IF
	.DW	RESTORE		; RESTORE
	.DW	GOSUB		; GOSUB
	.DW	RETURN		; RETURN
	.DW	REM		; REM
	.DW	STOP		; STOP
	.DW	REM		; ELSE (ELSE is not a standalone command)
	.DW	TRON		; TRON
	.DW	TROFF		; TROFF
	.DW	DEFSTR		; DEFSTR
	.DW	DEFINT		; DEFINT
	.DW	DEFREA		; DEFSNG
	.DW	DEFDBL		; DEFDBL
	.DW	DVLINE		; LINE ( Command Vector )
	.DW	EDIT		; EDIT
	.DW	ERRORS		; ERRORS
	.DW	RESUME		; RESUME
	.DW	FNOUT		; FNOUT
	.DW	ONGOTO		; ON
	.DW	DVOPEN		; OPEN ( Command Vector )
	.DW	DVFIEL		; FIELD ( Command Vector )
	.DW	DVGET		; GET ( Command Vector )
	.DW	DVPUT		; PUT ( Command Vector )
	.DW	DVCLOS		; CLOSE ( Command Vector )
	.DW	DVLOAD		; LOAD ( Command Vector )
	.DW	DVMERG		; MERGE ( Command Vector )
	.DW	DVNAME		; NAME ( Command Vector )
	.DW	DVKILL		; KILL ( Command Vector )
	.DW	DVLSET		; LSET ( Command Vector )
	.DW	DVREST		; RSET ( Command Vector )
	.DW	DVSAVE		; SAVE ( Command Vector )
	.DW	SYSTEM		; SYSTEM
	.DW	LPRINT		; LPRINT
	.DW	DVDEF		; DEF ( Command Vector )
	.DW	POKE		; POKE
	.DW	PRINT		; PRINT
	.DW	CONT		; CONT
	.DW	LIST		; LIST
	.DW	LLIST		; LLIST
	.DW	DELETE		; DELETE
	.DW	AUTO		; AUTO
	.DW	CLEAR		; CLEAR
	.DW	SNERR		; CLOAD - no longer supported (1.4)
	.DW	SNERR		; CSAVE - no longer supported (1.4)
	.DW	SCRATH		; NEW - ID = $BB
;
; ----------------------------------------------------------------------
; 189A-18A0 - Operation Precedent Table
; ----------------------------------------------------------------------
OPTAB:
	.DB	$79		; -
	.DB	$79		; +
	.DB	$7C		; /
	.DB	$7C		; *
	.DB	$7F		; EXPONENT (up arrow)
	.DB	$50		; AND
	.DB	$46		; OR
;
; ----------------------------------------------------------------------
; 18A1-18AA - Conversion functions
; ----------------------------------------------------------------------
FRCTBL:
	.DW	FRCDBL		; double conversion
	.DW	0
	.DW	FRCINT		; integer conversion
	.DW	CHKSTR		; string conversion
	.DW	FRCSNG		; single precision
;
; ----------------------------------------------------------------------
; 18AB-18B4 - Double precision math
; ----------------------------------------------------------------------
DBLDSP:
	.DW	DADD		; dp additiion
	.DW	DSUB		; dp sutraction
	.DW	DMULT		; dp multiplication
	.DW	DDIV		; dp division
	.DW	DCOMP		; dp compare
;
; ----------------------------------------------------------------------
; 18B5-18BE - Single precision math
; ----------------------------------------------------------------------
SNGDSP:
	.DW	FADD		; sp addition
	.DW	FSUB		; sp sutraction
	.DW	FMULT		; sp multiplication
	.DW	FDIV		; sp division
	.DW	FCOMP		; sp compare
;
; ----------------------------------------------------------------------
; 18BF-18C8 - Integer math
; ----------------------------------------------------------------------
INTDSP:
	.DW	IADD		; int addition
	.DW	ISUB		; int sutraction
	.DW	IMULT		; int multiplication
	.DW	INTDIV		; int division
	.DW	ICOMP		; int compare
;
; ----------------------------------------------------------------------
; 18C9-18F6 – STORAGE LOCATION FOR LEVEL II BASIC ERROR MESSAGES – "ERRTAB"
; table of error strings (2 char each)
; ----------------------------------------------------------------------
ERRTAB:
	.DB	"NF"		; NEXT without FOR 	(00H)
	.DB	"SN"		; Syntax Error 		(02H)
	.DB	"RG"		; RETURN without GOSUB 	(04H)
	.DB	"OD"		; Out of DATA 		(06H)
	.DB	"FC"		; Illegal Function Call (08H)
	.DB	"OV"		; Overflow 		(0AH)
	.DB	"OM"		; Out of Memory 	(0CH)
	.DB	"UL"		; Underfined Line Number (0EH)
	.DB	"BS"		; Subscript out of Range (10H)
	.DB	"DD"		; Redimensioned Array 	(12H)
	.DB	"/0"		; Division by Zero 	(14H)
	.DB	"ID"		; Illegal Direct Operation (16H)
	.DB	"TM"		; Type Mismatch 	(18H)
	.DB	"OS"		; Out of String Message (1AH)
	.DB	"LS"		; Out of Memory 	(1CH)
	.DB	"ST"		; String Too Long 	(1EH)
	.DB	"CN"		; Can’t Continue 	(20H)
	.DB	"NR"		; No RESUME 		(22H)
	.DB	"RW"		; RESUME Without Error 	(24H)
	.DB	"UE"		; Unprintable Error 	(26H)
	.DB	"MO"		; Missing Operand 	(28H)
	.DB	"FD"		; Bad file Data 	(2AH)
	.DB	"L3"		; Disk BASIC Command 	(2CH)
;
; ----------------------------------------------------------------------
; 18F7-1904 – STORAGE LOCATION FOR THE SINGLE PRECISION DIVISION ROUTINE
;  This code is moved from 18F7-191CH to 4080H-40A5H during non-disk initial setup.
; ----------------------------------------------------------------------
; Single Point Division Routine (4080 - 408D)
CONSTR:	sub	$00		;4080 (FDIVC) - Note Argument is set into working RAM
	ld	l,a		;4082
	ld	a,h		;4083
	sbc	a,$00		;4084 (FDIVB) - Note Argument is set into worikng RAM
	ld	h,a		;4086
	ld	a,b		;4087
	sbc	a,$00		;4088 (FDIVA) - Note Argument is set into working RAM
	ld	b,a		;408A
	ld	a,$00		;408B (FDIVG) - Note Argument is set into working RAM
	ret			;408D
;
	.DW	FCERR		;408E (USRTAB) - Vector for to USR(0) routine
	.DB	$40, $E6, $4D	;4090 (MULTR) - Random number seed
;
	in	a,($00)		;4093 (STAINP) - Input Port Routine. Arg Set in RAM
	ret			;4095
	out	($00),a		;4096 (OUTWRD) - Output port routine. Arg Set in RAM
	ret			;4098
;
	.DB	0		;4099 (CHARC) - Inkey $ Storage
	.DB	0		;409A (ERRFLG) - current error flag
	.DB	0		;409B (LPTPOS) - current tab position
	.DB	0		;409C (PRTFLG) - device output flag
	.DB	64		;409D (LINLEN) - max chars on video disp line
	.DB	48		;409E (CLMLST) - Size of print line
	.DB	0		;409F - RESERVED
	.DW	MEMEND+$14C	;40A0 (STKTOP) - String Storage Area (434C)
	.DW	$FFFE		;40A2 (CURLIN) - Current BASIC Line Number
	.DW	MEMEND+$E9	;40A4 (TXTTAB) - BASIC Program Statement Table Pointer
;
CONSTR2:
;
; ----------------------------------------------------------------------
; 191D-1923 – MESSAGE STORAGE LOCATION – "ERR"
; ----------------------------------------------------------------------
m_ERR:	.DB	" Error"
	.DB	0
;
; Message IN
m_INTX:	.DB	" in "
	.DB	0
;
; 1929-192F – MESSAGE STORAGE LOCATION – "REDDY"
m_REDDY: .DB	"READY"
	.DB	ENTER
	.DB	0
;
; 1930-1935 – MESSAGE STORAGE LOCATION – "BRKTXT"
BNKTXT:	.DB	"Break"
	.DB	0
;
; ----------------------------------------------------------------------
; 1936-1954 – SCAN STACK ROUTINE – “FNDFOR”
;   This routine is called with DE as the address of the NEXT index.
;   It scans the STACK backwards looking for a FOR push. If one is found,
;   it gets the address of the index and compares with the DE that was in
;   place when this routine was called. If it is equal, then it exits
;   with A=0 and HL=Address of the variable. If it is not equal it will
;   keep scanning until no FOR push is found and then exit with A<>0.
; ----------------------------------------------------------------------
FNDFOR:	ld	hl,$0004	;1936
	add	hl,sp		;1939
LOOPER:	ld	a,(hl)		;193a
	inc	hl		;193b
	cp	TKFOR		;193c - Check (which is the current STACK pointer – 4) is a FOR token to make sure that the item in the STACK was associated with a FOR loop
	ret	nz		;193e
	ld	c,(hl)		;193f
	inc	hl		;1940
	ld	b,(hl)		;1941
	inc	hl		;1942
	push	hl		;1943
	ld	l,c		;1944
	ld	h,b		;1945
	ld	a,d		;1946
	or	e		;1947
	ex	de,hl		;1948
	jr	z,POPGOF	;1949
	ex	de,hl		;194b
	CPDEHL			;194c
POPGOF:	ld	bc,$000E	;194d
	pop	hl		;1950
	ret	z		;1951
	add	hl,bc		;1952
	jr	LOOPER		;1953
; ----------------------------------------------------------------------
; 1955-1962 – DATA MOVEMENT ROUTINE – “BLTU”
;   This routine moves a variable into another area specified by the caller.
;   On entry BC is set as the end address of the list to move (which is
;   the upper limit); DE is set as the start address of the list to move;
;   and HL is the end of the area to move it to.
; ----------------------------------------------------------------------
BLTU:	call	REASON		;1955
BLTUC:	push	bc		;1958
	ex	(sp),hl		;1959
	pop	bc		;195a
BLTLOP:	CPDEHL			;195b
	ld	a,(hl)		;195c
	ld	(bc),a		;195d
	ret	z		;195e
	dec	bc		;195f
	dec	hl		;1960
	jr	BLTLOP		;1961
; ----------------------------------------------------------------------
; 1963-197D – MEMORY CHECK ROUTINE – “GETSTK”
;   This routine computes the amount of space between HL and the end of memory
;   at FFC6. On entry, Register C should hold the number of desired bytes.
; ----------------------------------------------------------------------
GETSTK:	push	hl		;1963
	ld	hl,(STREND)	;1964
	ld	b,$00		;1967
	add	hl,bc		;1969
	add	hl,bc		;196a
;
	.DB	LDANN		;196b - Z80 Trick - LD A,nn - skip next 1 byte instruction
;
REASON:	push	hl		;196c
	ld	a,$C6		;196d
	sub	l		;196f
	ld	l,a		;1970
	ld	a,$FF		;1971
	sbc	a,h		;1973
	jr	c,OMERR		;1974
	ld	h,a		;1976
	add	hl,sp		;1977
	pop	hl		;1978
	ret	c		;1979
;
; ----------------------------------------------------------------------
; 197AH – ?OM ERROR ENTRY POINT – “OMERR”
; ----------------------------------------------------------------------
OMERR:	ld	e,ERROM		;197a
	jr	ERROR		;197c
;
; ----------------------------------------------------------------------
; 197E-1AF7 – LEVEL II BASIC COMMAND MODE ERROR HANDLING – “PRGEND”
; ----------------------------------------------------------------------
PRGEND:	ld	hl,(CURLIN)	;197e
	ld	a,h		;1981
	and	l		;1982
	inc	a		;1983
	jr	z,ENDCNJ	;1984
	ld	a,(ONEFLG)	;1986
	or	a		;1989
	ld	e,ERRNR		;198a
	jr	nz,ERROR	;198c
ENDCNJ:	jp	ENDCON		;198e
DATSNE:	ld	hl,(DATLIN)	;1991
	ld	(CURLIN),hl	;1994
; ----------------------------------------------------------------------
; 1997H – ?SN ERROR ENTRY POINT – “SNERR”
; ----------------------------------------------------------------------
SNERR:	ld	e,ERRSN		;1997 - ?SN ERROR
;
; ----------------------------------------------------------------------
; 1999A – ?D0 ERROR ENTRY POINT – “DV0ERR”
; ----------------------------------------------------------------------
	.DB	LDBCNN		;1999 Z80 Trick LD BC,nnnn - skips the next 2 byte instruction
DV0ERR:	ld	e,ERRD0		;199A - ?/0 ERROR
;
; ----------------------------------------------------------------------
; 199DH – ?NF ERROR ENTRY POINT – “NFERR”
; ----------------------------------------------------------------------
	.DB	LDBCNN		;199c  Z80 Trick LD BC,nnnn - skips the next 2 byte instruction
NFERR:	ld	e,ERRNF		;199d - ?NF ERROR
;
; ----------------------------------------------------------------------
; 19A0H – ?OV ERROR ENTRY POINT – “REERR”
; ----------------------------------------------------------------------
	.DB	LDBCNN		;199f  Z80 Trick LD BC,nnnn - skips the next 2 byte instruction
REERR:	ld	e,ERRRW		;19A0 - ?RW ERROR
;
; ----------------------------------------------------------------------
; 19A2 - Entry Point For Errors
; ----------------------------------------------------------------------
ERROR:	ld	hl,(CURLIN)	;19a2
	ld	(ERRLIN),hl	;19a5
	ld	(DOT),hl	;19a8
ERRESM:	ld	bc,ERRMOR	;19ab - ret addr - continuation address after reinit
;
; ----------------------------------------------------------------------
; 19AE - ALTERNATE ENTRY TO BASIC "READY"
; This will work with both the Model I and the Model III
; To use this routine, load the BC with 1A18H, then JP the 19AE
; ----------------------------------------------------------------------
ERESET:	ld	hl,(SAVSTK)	;19ae
	jp	STKERR		;19b1
;
; ----------------------------------------------------------------------
; 19B4 – LEVEL II BASIC COMMAND MODE ERROR HANDLING – “ERRMOR”
; ----------------------------------------------------------------------
ERRMOR:	pop	bc		;19b4
	ld	a,e		;19b5
	ld	c,e		;19b6
	ld	(ERRFLG),a	;19b7
	ld	hl,(SAVTXT)	;19ba
	ld	(ERRTXT),hl	;19bd
	ex	de,hl		;19c0
	ld	hl,(ERRLIN)	;19c1
	ld	a,h		;19c4
	and	l		;19c5
	inc	a		;19c6
	jr	z,NTMDCN	;19c7
	ld	(OLDLIN),hl	;19c9
	ex	de,hl		;19cc
	ld	(OLDTXT),hl	;19cd
NTMDCN:	ld	hl,(ONELIN)	;19d0
	ld	a,h		;19d3
	or	l		;19d4
	ex	de,hl		;19d5
	ld	hl,ONEFLG	;19d6
	jr	z,NOTRAP	;19d9
	and	(hl)		;19db
	jr	nz,NOTRAP	;19dc
	dec	(hl)		;19de
	ex	de,hl		;19df
	jp	GONE4		;19e0
; ----------------------------------------------------------------------
; 19E3 – LEVEL II BASIC COMMAND MODE ERROR HANDLING – “NOTRAP”
; ----------------------------------------------------------------------
NOTRAP:	xor	a		;19e3
	ld	(hl),a		;19e4
	ld	e,c		;19e5
	call	CRDONZ		;19e6
	ld	hl,ERRTAB	;19e9
	call	EXDSKR		;19ec - dos err handling
	ld	d,a		;19ef
	ld	a,'?'		;19f0
	call	OUTDO		;19f2
	add	hl,de		;19f5
	ld	a,(hl)		;19f6
	call	OUTDO		;19f7
	GETCHR			;19fa - rst 10h
	call	OUTDO		;19fb
	ld	hl,m_ERR	;19fe
	push	hl		;1a01
	ld	hl,(ERRLIN)	;1a02
	ex	(sp),hl		;1a05
ERRFIN:	call	STROUT		;1a06
	pop	hl		;1a09
	ld	de,$FFFE	;1a0a
	CPDEHL			;1a0d
	jp	z,INIT		;1a0e
	ld	a,h		;1a11
	and	l		;1a12
	inc	a		;1a13
	call	nz,INPRT	;1a14
;
	.DB	LDANN		; Z80 Trick - LD A,nn - skip next 1 byte instruction
;
STPRDY:	pop	bc		;1a18
;
; ======================================================================
; 1A19 - OFFICIAL" RETURN TO BASIC "READY"
;  The disadvantage of using this entry is that it will often return
;   an "Out Memory Error" message response to the next command typed
;   in, even though the condition does not exist.
;  Often 06CCH or 0072H are used as alternatives, but these dont work on M3
;  See 19AE which also provides a good entry point and works on M1 and M3
; ======================================================================
READY:	call	FINLPT		;1a19 - set the current output device to the video display
	call	PRGFIN		;1a1c - dos exit for BASIC startup
	call	CTOFF		;1a1f - turn off the cassette recorder
	call	CRDONZ		;1a22 - display a carriage return if necessary
	ld	hl,m_REDDY	;1a25 - the starting address of word “READY”
	call	STROUT		;1a28 - Display the word “READY”
	ld	a,(ERRFLG)	;1a2b - load A with the value of the current error code
	sub	ERRSN		;1a2e - compare with SYNTAX ERROR
	call	z,ERREDT	;1a30 - If an SN ERR, enter EDIT mode on that line
;
;
; ======================================================================
; ======================================================================
; 1A33-1A5F – MAIN LEVEL II BASIC INTERPRETER ENTRY – “MAIN”
;
;   If the jump here was from an AUTO call, (40E4H) will have the increment
;   number, (40E1H) will be 0 if no AUTO and non-zero if AUTO, and (40E2H)
;   will have the starting line number.
; ----------------------------------------------------------------------
MAIN:	ld	hl,$FFFF	;1a33
	ld	(CURLIN),hl	;1a36
	ld	a,(AUTFLG)	;1a39
	or	a		;1a3c
	jr	z,NTAUTO	;1a3d
	ld	hl,(AUTLIN)	;1a3f
	push	hl		;1a42
	call	LINPRT		;1a43
	pop	de		;1a46
	push	de		;1a47
	call	FNDLIN		;1a48
	ld	a,'*'		;1a4b
	jr	c,AUTELN	;1a4d
	ld	a,SPACE		;1a4f
AUTELN:	call	OUTDO		;1a51
	call	INLIN		;1a54
	pop	de		;1a57
	jr	nc,AUTGOD	;1a58
AUTRES:	xor	a		;1a5a
	ld	(AUTFLG),a	;1a5b
	jr	READY		;1a5e
; ----------------------------------------------------------------------
; 1A60H-1A73 – Part of the AUTO command – “AUTGOD”
; ----------------------------------------------------------------------
AUTGOD:	ld	hl,(AUTINC)	;1a60
	add	hl,de		;1a63
	jr	c,AUTRES	;1a64
	push	de		;1a66
	ld	de,$FFF9	;1a67
	CPDEHL			;1a6a
	pop	de		;1a6b
	jr	nc,AUTRES	;1a6c
	ld	(AUTLIN),hl	;1a6e
	or	$FF		;1a71
	jp	EDITRT		;1a73
; ----------------------------------------------------------------------
; 1A76H-1AF7 – Part of the AUTO command – “NTAUTO”
; ----------------------------------------------------------------------
NTAUTO:	ld	a,'>'		;1a76
	call	OUTDO		;1a78
	call	INLIN		;1a7b
	jp	c,MAIN		;1a7e
	GETCHR			;1a81 - rst 10h
	inc	a		;1a82
	dec	a		;1a83
	jp	z,MAIN		;1a84
	push	af		;1a87
	call	LINGET		;1a88
BAKSP:	dec	hl		;1a8b
	ld	a,(hl)		;1a8c
	cp	SPACE		;1a8d
	jr	z,BAKSP		;1a8f
	inc	hl		;1a91
	ld	a,(hl)		;1a92
	cp	SPACE		;1a93
	call	z,INXHRT	;1a95
EDENT:	push	de		;1a98
	call	CRUNCH		;1a99
	pop	de		;1a9c
	pop	af		;1a9d
	ld	(SAVTXT),hl	;1a9e
	call	DIRDO		;1aa1 - Check to see if DOS should be taking this over
	jp	nc,GONE1	;1aa4
	push	de		;1aa7
	push	bc		;1aa8
	xor	a		;1aa9
	ld	(BFKLFL),a	;1aaa
	GETCHR			;1aad - rst 10h
	or	a		;1aae
	push	af		;1aaf
	ex	de,hl		;1ab0
	ld	(DOT),hl	;1ab1
	ex	de,hl		;1ab4
	call	FNDLIN		;1ab5
	push	bc		;1ab8
	call	c,DELDEL	;1ab9
	pop	de		;1abc
	pop	af		;1abd
	push	de		;1abe
	jr	z,FINI		;1abf
	pop	de		;1ac1
	ld	hl,(VARTAB)	;1ac2
	ex	(sp),hl		;1ac5
	pop	bc		;1ac6
	add	hl,bc		;1ac7
	push	hl		;1ac8
	call	BLTU		;1ac9
	pop	hl		;1acc
	ld	(VARTAB),hl	;1acd
	ex	de,hl		;1ad0
	ld	(hl),h		;1ad1
	pop	de		;1ad2
	push	hl		;1ad3
	inc	hl		;1ad4
	inc	hl		;1ad5
	ld	(hl),e		;1ad6
	inc	hl		;1ad7
	ld	(hl),d		;1ad8
	inc	hl		;1ad9
	ex	de,hl		;1ada
	ld	hl,(BUFPNT)	;1adb
	ex	de,hl		;1ade
	dec	de		;1adf
	dec	de		;1ae0
MLOOPR:	ld	a,(de)		;1ae1
	ld	(hl),a		;1ae2
	inc	hl		;1ae3
	inc	de		;1ae4
	or	a		;1ae5
	jr	nz,MLOOPR	;1ae6
FINI:	pop	de		;1ae8
	call	CHEAD		;1ae9
	call	EXFIND		;1aec
	call	RUNC		;1aef
	call	EXFIN2		;1af2
	jp	MAIN		;1af5
; ----------------------------------------------------------------------
; 1AF8-1B0F – LINE POINTERS ROUTINE – “LINKER”
;   This routine fixes the line pointers in a BASIC program.
;   This is useful, for instance for a renumber program which has to move
;   BASIC program lines from one location in memory to an other, which
;   means that the line pointers would no longer be valid. This routine
;   will fix them. Registers A, HL and DE are used
; ----------------------------------------------------------------------
LINKER:	ld	hl,(TXTTAB)	;1af8
	ex	de,hl		;1afb
CHEAD:	ld	h,d		;1afc
	ld	l,e		;1afd
	ld	a,(hl)		;1afe
	inc	hl		;1aff
	or	(hl)		;1b00
	ret	z		;1b01
	inc	hl		;1b02
	inc	hl		;1b03
	inc	hl		;1b04
	xor	a		;1b05
CZLOOP:	cp	(hl)		;1b06
	inc	hl		;1b07
	jr	nz,CZLOOP	;1b08
	ex	de,hl		;1b0a
	ld	(hl),e		;1b0b
	inc	hl		;1b0c
	ld	(hl),d		;1b0d
	jr	CHEAD		;1b0e
; ----------------------------------------------------------------------
; 1B10-1B48 – EVALUATE LINE NUMBERS – “SCNLINE”
;   This is called by LIST and DELETE. It converts the starting and ending
;   line numbers (X-Y) to binary and saves the ending line number on the STACK.
;   Then the code locates the program table address for the starting line.
;   The routine leaves the address of the starting line in BC and the ending
;   line number in the STACK.
; ----------------------------------------------------------------------
SCNLINE: ld	de,$0000	;1b10
	push	de		;1b13
	jr	z,ALLLST	;1b14
	pop	de		;1b16
	call	LINSPC		;1b17
	push	de		;1b1a
	jr	z,SNGLIN	;1b1b
	SYNTAX	(TKMNUS)	;1b1d - rst 08h
ALLLST:	ld	de,$FFFA	;1b1f
	call	nz,LINSPC	;1b22
	jp	nz,SNERR	;1b25
SNGLIN:	ex	de,hl		;1b28
	pop	de		;1b29
FNDLN1:	ex	(sp),hl		;1b2a
	push	hl		;1b2b
; ----------------------------------------------------------------------
; 1B2CH – SEARCH FOR A LINE NUMBER – “FNDLIN”
;   FNDLIN routine searches the program text for the line whose line
;   number is held in Register Pair DE. DE is preserved.
; ----------------------------------------------------------------------
FNDLIN:	ld	hl,(TXTTAB)	;1b2c
FNLOOP:	ld	b,h		;1b2f
	ld	c,l		;1b30
	ld	a,(hl)		;1b31
	inc	hl		;1b32
	or	(hl)		;1b33
	dec	hl		;1b34
	ret	z		;1b35
	inc	hl		;1b36
	inc	hl		;1b37
	ld	a,(hl)		;1b38
	inc	hl		;1b39
	ld	h,(hl)		;1b3a
	ld	l,a		;1b3b
	CPDEHL			;1b3c
	ld	h,b		;1b3d
	ld	l,c		;1b3e
	ld	a,(hl)		;1b3f
	inc	hl		;1b40
	ld	h,(hl)		;1b41
	ld	l,a		;1b42
	ccf			;1b43
	ret	z		;1b44
	ccf			;1b45
	ret	nc		;1b46
	jr	FNLOOP		;1b47
;
; ----------------------------------------------------------------------
; 1B49-1B5C – LEVEL II BASIC NEW ROUTINE – “SCRATH”
; ----------------------------------------------------------------------
SCRATH:	ret	nz		;1b49
; ----------------------------------------------------------------------
; 1B4A - Does a NEW as well as clearing the screen
; ----------------------------------------------------------------------
	call	CLS		;1b4a
; ----------------------------------------------------------------------
; 1B4D - NEW - This routine will wipe out the BASIC program currently
;    in memory by resetting the pointers associated with it .
; ----------------------------------------------------------------------
SCRTCH:	ld	hl,(TXTTAB)	;1b4d
	call	TROFF		;1b50
	ld	(AUTFLG),a	;1b53
	ld	(hl),a		;1b56
	inc	hl		;1b57
	ld	(hl),a		;1b58
	inc	hl		;1b59
	ld	(VARTAB),hl	;1b5a
;
; ----------------------------------------------------------------------
; 1B5D-1BB2 – LEVEL II BASIC RUN ROUTINE – “RUNC”
;   This is called by "RUN" routine when NO Line number is specified
;
;   This routine does a lot of variable resets and other things that are
;   common to NEW as well, so NEW just does the special NEW stuff
;   and than passes right through to here to reset the rest.
; ----------------------------------------------------------------------
RUNC:	ld	hl,(TXTTAB)	;1b5d - the PST (the start of the BASIC program pointer).
	dec	hl		;1b60
;
; ----------------------------------------------------------------------
; 1B61H – Subroutine which initializes a lot of stuff – “CLEARC”
;   Initialize he variable and array space by resetting
;   ARYTAB (which is the end of the the simple variable spac) and
;   STREND (which is the end of the array storage).
;   It then falls into STKINI which resets the STACK. HL is preserved.
; ----------------------------------------------------------------------
CLEARC:	ld	(TEMP),hl	;1b61
	ld	b,26		;1b64 - number of variable names to be initialized
	ld	hl,DEFTBL	;1b66
LOFDPT:	ld	(hl),$04	;1b69
	inc	hl		;1b6b
	djnz	LOFDPT		;1b6c
	xor	a		;1b6e
	ld	(ONEFLG),a	;1b6f
	ld	l,a		;1b72
	ld	h,a		;1b73
	ld	(ONELIN),hl	;1b74
	ld	(OLDTXT),hl	;1b77
	ld	hl,(MEMSIZ)	;1b7a
	ld	(FRETOP),hl	;1b7d
	call	RESTORE		;1b80
	ld	hl,(VARTAB)	;1b83
	ld	(ARYTAB),hl	;1b86
	ld	(STREND),hl	;1b89
	call	CLSALL		;1b8c
;
; ----------------------------------------------------------------------
; 1B8F – Subroutine which initializes Stack and others – "STKINI"
;   this routine resets the STACK point, which will also destroy all GOSUBs and FORs.
;   String temporaries are freed, SUBFLG is reset, CONT is forbidden,
;   and a dummy entry is put on the STACK, so that FNDFOR will always find a NON-"FOR"
;   entry at the bottom of the STACK. A will be reset to 0 and Register Pair DE is preserved.
; ----------------------------------------------------------------------
STKINI:	pop	bc		;1b8f - get return address off stack
	ld	hl,(STKTOP)	;1b90 - MEMSIZE-32
	dec	hl		;1b93
	dec	hl		;1b94 - now room for a FNDFOR stopper value to be put on the STACK
	ld	(SAVSTK),hl	;1b95 - save pointer
	inc	hl		;1b98
	inc	hl		;1b99 - back to being the start of the string space pointer
STKERR:	ld	sp,hl		;1b9a - MAIN SET SP with the start of the string space pointer
	ld	hl,TEMPST	;1b9b - start of the string work area
	ld	(TEMPPT),hl	;1b9e - init string temps - the next available location in the string work area
	call	FINLPT		;1ba1 - set the current output device to the video display
	call	FINPRT		;1ba4 - turn off the cassette recorder
	xor	a		;1ba7
	ld	h,a		;1ba8
	ld	l,a		;1ba9
	ld	(SUBFLG),a	;1baa - Clear the FOR statement flag.
	push	hl		;1bad - put FNDFOR stopper value on the STACK
	push	bc		;1bae - Save the RETURN ADDRESS back on the STACK
	ld	hl,(TEMP)	;1baf - Restore Register Pair HL so it is preserved
	ret			;1bb2
;
; ======================================================================
; 1BB3 – KEYBOARD INPUT ROUTINE – “QINLIN”
;
;   This is the last of the general purpose input routines. This routine
;   functions identically to the 0361H routine with the exception that it
;   prints a ? on the screen (like INPUT does with BASIC) before allowing
;   input from the keyboard.
; ----------------------------------------------------------------------
QINLIN:	ld	a,'?'		;1bb3
	call	OUTDO		;1bb5
	ld	a,SPACE		;1bb8
	call	OUTDO		;1bba
	jp	INLIN		;1bbd
;
; ----------------------------------------------------------------------
; 1BC0-1C8F – TOKENIZE INPUT ROUTINE – “CRUNCH”
;   This routine translates all “reserved words” into single bytes with the
;   MSB on. This saves space and time by allowing for table dispatch during
;   execution, and, as such, all statements appear together in the ; reserved
;   word list in the same ; order they appear in in STMDSP.
; ----------------------------------------------------------------------
CRUNCH:	xor	a		;1bc0
	ld	(DORES),a	;1bc1
	ld	c,a		;1bc4
	ex	de,hl		;1bc5
	ld	hl,(BUFPNT)	;1bc6
	dec	hl		;1bc9
	dec	hl		;1bca
	ex	de,hl		;1bcb
KLOOP:	ld	a,(hl)		;1bcc
	cp	SPACE		;1bcd
	jp	z,STUFFH	;1bcf
	ld	b,a		;1bd2
	cp	DQUOTE		;1bd3 - Check to see if the current character is a "
	jp	z,STRNG		;1bd5
	or	a		;1bd8
	jp	z,CRDONE	;1bd9
	ld	a,(DORES)	;1bdc
	or	a		;1bdf
	ld	a,(hl)		;1be0
	jp	nz,STUFFH	;1be1
	cp	'?'		;1be4 - Check to see if is a ? (PRINT statement)
	ld	a,TKPRNT	;1be6
	jp	z,STUFFH	;1be8
	ld	a,(hl)		;1beb
	cp	'0'		;1bec - if less than a zero character (alpha numeric)
	jr	c,MUSTCR	;1bee - meaning it is not a digit or letter
	cp	'<'		;1bf0 - is less than < character (if it is 0–9, :, ;, <)
	jp	c,STUFFH	;1bf2 - char is 0–9, :, ;, <, constant or special character
MUSTCR:	push	de		;1bf5
	ld	de,RESLST-1	;1bf6 - reserved words list (first instruction in the LOPSKP is to INC)
	push	bc		;1bf9
	ld	bc,NOTRES	;1bfa
	push	bc		;1bfd
	ld	b,$7F		;1bfe
	ld	a,(hl)		;1c00
	cp	'a'		;1c01 - if the character is lower-case
	jr	c,TRYAGA	;1c03
	cp	'z'+1		;1c05 - is within the lower-case range
	jr	nc,TRYAGA	;1c07
	and	$5F		;1c09 - Covert the lowercase to upper-case
	ld	(hl),a		;1c0b
TRYAGA:	ld	c,(hl)		;1c0c
	ex	de,hl		;1c0d
LOPSKP:	inc	hl		;1c0e
	or	(hl)		;1c0f
	jp	p,LOPSKP	;1c10
	inc	b		;1c13
	ld	a,(hl)		;1c14
	and	$7F		;1c15
	ret	z		;1c17
	cp	c		;1c18
	jr	nz,LOPSKP	;1c19
	ex	de,hl		;1c1b
	push	hl		;1c1c
LOPPSI:	inc	de		;1c1d
	ld	a,(de)		;1c1e
	or	a		;1c1f
	jp	m,FOUND		;1c20
	ld	c,a		;1c23
	ld	a,b		;1c24
	cp	TKGOTO		;1c25 - Check to see if the current reserved word is GOTO
	jr	nz,NTGOTO	;1c27
	GETCHR			;1c29 - rst 10h
	dec	hl		;1c2a
NTGOTO:	inc	hl		;1c2b
	ld	a,(hl)		;1c2c
	cp	$61		;1c2d
	jr	c,NOTLW1	;1c2f
	and	$5F		;1c31
NOTLW1:	cp	c		;1c33
	jr	z,LOPPSI	;1c34
	pop	hl		;1c36
	jr	TRYAGA		;1c37
FOUND:	ld	c,b		;1c39
	pop	af		;1c3a
	ex	de,hl		;1c3b
	ret			;1c3c
; ----------------------------------------------------------------------
; 1C3D – Part of the tokeninzing routine – “NOTRES”
; ----------------------------------------------------------------------
NOTRES:	ex	de,hl		;1c3d
	ld	a,c		;1c3e
	pop	bc		;1c3f
	pop	de		;1c40
	ex	de,hl		;1c41
	cp	TKELSE		;1c42
	ld	(hl),':'	;1c44
	jr	nz,CKSNGO	;1c46
	inc	c		;1c48
	inc	hl		;1c49
CKSNGO:	cp	$FB		;1c4a
	jr	nz,NTSNGT	;1c4c
	ld	(hl),':'	;1c4e
	inc	hl		;1c50
	ld	b,TKREM		;1c51
	ld	(hl),b		;1c53
	inc	hl		;1c54
	ex	de,hl		;1c55
	inc	c		;1c56
	inc	c		;1c57
	jr	STRNG		;1c58
; ----------------------------------------------------------------------
; 1C5A – Part of the tokeninzing routine – “NTSNGT” and “STUFFH”
; ----------------------------------------------------------------------
NTSNGT:	ex	de,hl		;1c5a
STUFFH:	inc	hl		;1c5b
	ld	(de),a		;1c5c
	inc	de		;1c5d
	inc	c		;1c5e
	sub	':'		;1c5f ;  is a : to flag a multi-statement line
	jr	z,COLIS		;1c61
	cp	$4E		;1c63
	jr	nz,NODATT	;1c65
COLIS:	ld	(DORES),a	;1c67
NODATT:	sub	$59		;1c6a
	jp	nz,KLOOP	;1c6c
	ld	b,a		;1c6f
STR1:	ld	a,(hl)		;1c70
	or	a		;1c71
	jr	z,CRDONE	;1c72
	cp	b		;1c74
	jr	z,STUFFH	;1c75
STRNG:	inc	hl		;1c77
	ld	(de),a		;1c78
	inc	c		;1c79
	inc	de		;1c7a
	jr	STR1		;1c7b
; ----------------------------------------------------------------------
;  1C7D – Part of the tokeninzing routine – Jumped here when an EOL is found
; ----------------------------------------------------------------------
CRDONE:	ld	hl,$0005	;1c7d - add 5 bytes to the tokenized character count
	ld	b,h		;1c80
	add	hl,bc		;1c81
	ld	b,h		;1c82
	ld	c,l		;1c83
	ld	hl,(BUFPNT)	;1c84
	dec	hl		;1c87
	dec	hl		;1c88
	dec	hl		;1c89
	ld	(de),a		;1c8a
	inc	de		;1c8b
	ld	(de),a		;1c8c
	inc	de		;1c8d
	ld	(de),a		;1c8e
	ret			;1c8f
;
; ======================================================================
; 1C90-1C95 – RST 0018H CODE – “DCOMPR”
;
;   The RST 18H code is located here. Unsigned compare (HL-DE), which
;   numerically compares DE and HL. Will not work for signed integers
;   (except positive ones). Uses the A-register only. The result of the
;   comparison is returned in the status Register as:
;   CARRY SET=HL<DE; NO CARRY=HL>DE; NZ=Unequal; Z=Equal).
; ----------------------------------------------------------------------
DCOMPR:	ld	a,h		;1c90
	sub	d		;1c91
	ret	nz		;1c92
	ld	a,l		;1c93
	sub	e		;1c94
	ret			;1c95
;
; ======================================================================
; 1C96-1CA0 – RST 0008H CODE – “SYNCHR”
;
;   The RST 8H code is located here. This is the COMPARE SYMBOL routine
;   which comparess the symbol in the input string pointed to by HL Register
;   to the value in the location following the RST 08 call. If there is a
;   match, control is returned to address of the RST 08 instruction 2 with
;   the next symbol in in Register A and HL incremented by one. If the two
;   characters do not match, a syntax error message is given and control
;   returns to the Input Phase).
; ----------------------------------------------------------------------
SYNCHR:	ld	a,(hl)		;1c96
	ex	(sp),hl		;1c97
	cp	(hl)		;1c98
	inc	hl		;1c99
	ex	(sp),hl		;1c9a
	jp	z,CHRGTR	;1c9b
	jp	SNERR		;1c9e
;
; ----------------------------------------------------------------------
; 1CA1-1D1D – Level II BASIC FOR ROUTINE – “FOR”
; ----------------------------------------------------------------------
FOR:	ld	a,$64		;1ca1
	ld	(SUBFLG),a	;1ca3
	call	LET		;1ca6
	ex	(sp),hl		;1ca9
	call	FNDFOR		;1caa
	pop	de		;1cad
	jr	nz,NOTOL	;1cae
	add	hl,bc		;1cb0
	ld	sp,hl		;1cb1
	ld	(SAVSTK),hl	;1cb2
NOTOL:	ex	de,hl		;1cb5
	ld	c,$08		;1cb6
	call	GETSTK		;1cb8
	push	hl		;1cbb
	call	DATA		;1cbc
	ex	(sp),hl		;1cbf
	push	hl		;1cc0
	ld	hl,(CURLIN)	;1cc1
	ex	(sp),hl		;1cc4
	SYNTAX	(TKTO)		;1cc5 - rst 08h
	TSTDAT			;1cc7
	jp	z,TMERR		;1cc8
	jp	nc,TMERR	;1ccb
	push	af		;1cce
	call	FRMEVL		;1ccf
	pop	af		;1cd2
	push	hl		;1cd3
	jp	p,SNGFOR	;1cd4
	call	FRCINT		;1cd7
	ex	(sp),hl		;1cda
	ld	de,1		;1cdb
	ld	a,(hl)		;1cde
	cp	TKSTEP		;1cdf
	call	z,GETINT	;1ce1
	push	de		;1ce4
	push	hl		;1ce5
	ex	de,hl		;1ce6
	call	ISIGN		;1ce7
	jr	STPSGN		;1cea
;
; ----------------------------------------------------------------------
; 1CECH – Part of the FOR routine – “SNGFOR”
; ----------------------------------------------------------------------
SNGFOR:	call	FRCSNG		;1cec
	call	MOVRF		;1cef
	pop	hl		;1cf2
	push	bc		;1cf3
	push	de		;1cf4
	ld	bc,$8100	;1cf5
	ld	d,c		;1cf8
	ld	e,d		;1cf9
	ld	a,(hl)		;1cfa
	cp	TKSTEP		;1cfb
	ld	a,$01		;1cfd
	jr	nz,ONEON	;1cff
	call	FRMCHK		;1d01
	push	hl		;1d04
	call	FRCSNG		;1d05
	call	MOVRF		;1d08
	call	SIGN		;1d0b
STPSGN:	pop	hl		;1d0e
ONEON:	push	bc		;1d0f
	push	de		;1d10
	ld	c,a		;1d11
	TSTDAT			;1d12
	ld	b,a		;1d13
	push	bc		;1d14
	push	hl		;1d15
	ld	hl,(TEMP)	;1d16
	ex	(sp),hl		;1d19
NXTCON:	ld	b,TKFOR		;1d1a
	push	bc		;1d1c
	inc	sp		;1d1d
; ----------------------------------------------------------------------
; 1D1E-1D77 – LEVEL II BASIC INTERPRETER – “NEWSTT”
;   this is where we go for a new statement. The character on the BASIC
;   program line pointed to by Register Pair HL should be either a “:”
;   or an END OF LINE. The address of this routine is left on the STACK so
;   that when a statement is executed and done, the RETurn comes back here.
; ----------------------------------------------------------------------
NEWSTT:	call	ISCHAR		;1d1e
	or	a		;1d21
	call	nz,CNTCCN	;1d22
	ld	(SAVTXT),hl	;1d25
	ld	(SAVSTK),sp	;1d28
	ld	a,(hl)		;1d2c
	cp	':'		;1d2d
	jr	z,GONE1		;1d2f
	or	a		;1d31
	jp	nz,SNERR	;1d32
	inc	hl		;1d35
GONE4:	ld	a,(hl)		;1d36
	inc	hl		;1d37
	or	(hl)		;1d38
	jp	z,PRGEND	;1d39
	inc	hl		;1d3c
	ld	e,(hl)		;1d3d
	inc	hl		;1d3e
	ld	d,(hl)		;1d3f
	ex	de,hl		;1d40
	ld	(CURLIN),hl	;1d41
	ld	a,(TRCFLG)	;1d44
	or	a		;1d47
	jr	z,NOTTRC	;1d48
	push	de		;1d4a
	ld	a,'<'		;1d4b
	call	OUTDO		;1d4d
	call	LINPRT		;1d50
	ld	a,'>'		;1d53
	call	OUTDO		;1d55
	pop	de		;1d58
NOTTRC:	ex	de,hl		;1d59
GONE1:	GETCHR			;1d5a - rst 10h
	ld	de,NEWSTT	;1d5b
	push	de		;1d5e
GONE3:	ret	z		;1d5f
GONE2:	sub	TKOFF		;1d60 - Check for a token >= 80H
	jp	c,LET		;1d62 - this must be a LET so jump to 1F21H
	cp	TKTAB-TKOFF	;1d65 - if the token is below the TAB( token
	jp	nc,ISMID	;1d67 - If the token >= TAB token
	rlca			;1d6a - Multiply the token value in Register A by two
	ld	c,a		;1d6b
	ld	b,$00		;1d6c - address offset into BC
	ex	de,hl		;1d6e - save the BASIC program pointer DE into HL
	ld	hl,STMDSP	;1d6f - list of BASIC execution addresses (Statement Dispatch Table)
	add	hl,bc		;1d72 - add the offset
	ld	c,(hl)		;1d73 - get low order byte
	inc	hl		;1d74
	ld	b,(hl)		;1d75 - het high order byte
	push	bc		;1d76 - Save execution address in BC to the STACK
	ex	de,hl		;1d77 - restore the BASIC program pointer into DE
;
; ======================================================================
; 1D78-1D90 – RST 0010H CODE – “CHRGTR”
;
;   The RST 10H code is located here. This is the EXAMINE NEXT SYMBOL
;   routine which loads the next character from the string pointed to by
;   the HL Register set into the A-register and clears the CARRY flag if
;   it is alphabetic, or sets it if is alphanumeric. Blanks and control
;   codes 09 and OB are ignored causing the following character to be
;   loaded and tested. The HL Register will be incremented before loading
;   any character therefore on the first call the HL Register should contain
;   the string address minus one. The string must be terminated by a byte
;   of zeros).
; ----------------------------------------------------------------------
CHRGTR:	inc	hl		;1d78 - Bump the BASIC program pointer to next char
	ld	a,(hl)		;1d79
	cp	':'		;1d7a - is greater than or equal to a :
	ret	nc		;1d7c - Return if char >= to a : meaning :, ;, < . Y, Z
	cp	SPACE		;1d7d - is a SPACE
	jp	z,CHRGTR	;1d7f - loop if a space
	cp	VERTAB		;1d82 - is >= 0BH (not a control code)
	jr	nc,NOTLFT	;1d84 - JP if greater than or equal to 0BH
	cp	TAB		;1d86 - is >= 09H (meaning a line feed or tab)
	jp	nc,CHRGTR	;1d88 - Loop if the char is >= to 09H
NOTLFT:	cp	'0'		;1d8b - is >= a zero character
	ccf			;1d8d - Set the carry flag if is numeric (i.e., greater than or equal to 30H)
	inc	a		;1d8e
	dec	a		;1d8f
	ret			;1d90
;
; ----------------------------------------------------------------------
; 1D91-1D9A – LEVEL II BASIC RESTORE ROUTINE – “RESTORE”
; ----------------------------------------------------------------------
RESTORE: ex	de,hl		;1d91
	ld	hl,(TXTTAB)	;1d92
	dec	hl		;1d95
RESFIN:	ld	(DATPTR),hl	;1d96
	ex	de,hl		;1d99
	ret			;1d9a
;
; ----------------------------------------------------------------------
; 1D9B-1DAD – SCAN KEYBOARD ROUTINE – “ISCNTC”
; ----------------------------------------------------------------------
ISCNTN:	call	ISCHAR		;1d9b
	or	a		;1d9e
	ret	z		;1d9f
CNTCCN:	cp	$60		;1da0
	call	z,INCHR		;1da2
	ld	(CHARC),a	;1da5
	dec	a		;1da8
;
; ----------------------------------------------------------------------
; 1DA9-1DAD – LEVEL II BASIC STOP ROUTINE – “STOP”
; ----------------------------------------------------------------------
STOP:	ret	nz		;1da9
	inc	a		;1daa
	jp	CONSTP		;1dab
;
; ----------------------------------------------------------------------
; 1DAE-1DE3 – LEVEL II BASIC END ROUTINE – “END”
; ----------------------------------------------------------------------
END:	ret	nz		;1dae
	push	af		;1daf
	call	z,CLSALL	;1db0
	pop	af		;1db3
CONSTP:	ld	(SAVTXT),hl	;1db4
	ld	hl,TEMPST	;1db7
	ld	(TEMPPT),hl	;1dba
;
	.DB	LDHLNN		;1dbd Z-80 Trick - LD HL,nnnn - next 2 instructions skipped
;
STPEND:	or	$FF		;1dbe A is NZ so as to force the printing of the BREAK message
	pop	bc		;1dc0
;
ENDCON:	ld	hl,(CURLIN)	;1dc1
	push	hl		;1dc4
	push	af		;1dc5
	ld	a,l		;1dc6
	and	h		;1dc7
	inc	a		;1dc8
	jr	z,DIRIS		;1dc9
	ld	(OLDLIN),hl	;1dcb
	ld	hl,(SAVTXT)	;1dce
	ld	(OLDTXT),hl	;1dd1
DIRIS:	call	FINLPT		;1dd4 - set the current output device to video
	call	CRDONZ		;1dd7
	pop	af		;1dda
	ld	hl,BNKTXT	;1ddb
	jp	nz,ERRFIN	;1dde
	jp	STPRDY		;1de1
;
; ----------------------------------------------------------------------
; 1DE4-1DF6 – LEVEL II BASIC CONT ROUTINE – “CONT”
; ----------------------------------------------------------------------
CONT:	ld	hl,(OLDTXT)	;1de4
	ld	a,h		;1de7
	or	l		;1de8
	ld	e,ERRCN		;1de9
	jp	z,ERROR		;1deb
	ex	de,hl		;1dee
	ld	hl,(OLDLIN)	;1def
	ld	(CURLIN),hl	;1df2
	ex	de,hl		;1df5
	ret			;1df6
;
; ----------------------------------------------------------------------
; 1DF7-1DF8 - TRON ENTRY POINT - "TRON"
; ----------------------------------------------------------------------
TRON:	.DB	LDANN		;1df7 - Z80 Trick LD A,nn where nn is the next XOR instruction byte
; which is nn zero, thus we store a non-ZERO, ON state
;
; ----------------------------------------------------------------------
; 1DF8 - TROFF ENTRY POINT - "TROFF"
; ----------------------------------------------------------------------
TROFF:	xor	a		;1df8
	ld	(TRCFLG),a	;1df9
	ret			;1dfc
;
; ----------------------------------------------------------------------
; 1DFD-1DFF - DISK ROUTINE NOT USED BY LEVEL II BASIC - "POPAHT".
; ----------------------------------------------------------------------
POPAHT:	pop	af		;1dfd
	pop	hl		;1dfe
	ret			;1dff
;
; ----------------------------------------------------------------------
; 1E00-1E02 - DEFSTR ENTRY POINT - "DEFSTR"
; ----------------------------------------------------------------------
DEFSTR:	ld	e,VTSTR		;1e00
	.DB	LDBCNN		;1e02 - Z80 Trick (LD BC,nnnn) skip next 2 byte instruction
;
; ----------------------------------------------------------------------
; 1E03-1E05 - DEFINT ENTRY POINT - "DEFINT"
; ----------------------------------------------------------------------
DEFINT:	ld	e,VTINT		;1e03
	.DB	LDBCNN		;1e05 - Z80 Trick (LD BC,nnnn) skip next 2 byte instruction
;
; ----------------------------------------------------------------------
; 1E06-1E08 - DEFSNG ENTRY POINT - "DEFREA" (DEFSNG)
; ----------------------------------------------------------------------
DEFREA:	ld	e,VTSNG		;1e06
	.DB	LDBCNN		;1e08 - Z80 Trick (LD BC,nnnn) skip next 2 byte instruction
;
; ----------------------------------------------------------------------
; 1E09-1E0A - DEFDBL ENTRY POINT - "DEFDBL"
; ----------------------------------------------------------------------
DEFDBL:	ld	e,VTDBL		;1e09
;
; ----------------------------------------------------------------------
; 1E0B-1E3C - COMMON CODE SHARED BY DEFSTR/DEFINT/DEFSNG/DEFDBL - "DEFCON".
;   All of those can either have a - for a range of values or be separated
;   by ,. This code needs to figure out the variables that followed the
;   DEF??? instruction and then set the variable type (which is currently
;   sitting in Register E) in the variable table
; ----------------------------------------------------------------------
DEFCON:	call	ISLET		;1e0b
	ld	bc,SNERR	;1e0e
	push	bc		;1e11
	ret	c		;1e12
	sub	$41		;1e13
	ld	c,a		;1e15
	ld	b,a		;1e16
	GETCHR			;1e17 - rst 10h
	cp	TKMNUS		;1e18 - a "-" TOKEN
	jr	nz,NOTRNG	;1e1a
	GETCHR			;1e1c - rst 10h
	call	ISLET		;1e1d
	ret	c		;1e20
	sub	$41		;1e21
	ld	b,a		;1e23
	GETCHR			;1e24 - rst 10h
NOTRNG:	ld	a,b		;1e25
	sub	c		;1e26
	ret	c		;1e27
	inc	a		;1e28
	ex	(sp),hl		;1e29
	ld	hl,DEFTBL	;1e2a
	ld	b,$00		;1e2d
	add	hl,bc		;1e2f
LPDCHG:	ld	(hl),e		;1e30
	inc	hl		;1e31
	dec	a		;1e32
	jr	nz,LPDCHG	;1e33
	pop	hl		;1e35
	ld	a,(hl)		;1e36
	cp	','		;1e37
	ret	nz		;1e39
	GETCHR			;1e3a - rst 10h
	jr	DEFCON		;1e3b
; ----------------------------------------------------------------------
; 1E3D-1E44 - EXAMINE VARIABLE - "ISLET"
;   This routine tests the value pointed to by the HL Register Pair and
;   sets the C FLAG if it is an ASCII letter value; and otherwise the
;   NC FLAG is set.
; ----------------------------------------------------------------------
ISLET:	ld	a,(hl)		;1e3d
	cp	$41		;1e3e
	ret	c		;1e40
	cp	'Z'+1		;1e41 - is greater than a "Z"
	ccf			;1e43 - Complement the value of the Carry flag
	ret			;1e44
;
; ----------------------------------------------------------------------
; 1E45-1E4E - EXAMINE VARIABLE - "INTIDX"
;   this routine reads a formula from the current position and turns it
;   into a positive integer, with the result put into Register Pair DE.
;   Negative arguments are not allowed. On exit, Register Pair HL wil
;   point to the terminating character of the formula on the BASIC
;   program line being examined
; ----------------------------------------------------------------------
INTIDX:	GETCHR			;1e45 - rst 10h
INTID2:	call	GETIN2		;1e46
	ret	p		;1e49
;
; ----------------------------------------------------------------------
; 1E4AH - ?FC ERROR ENTRY POINT - "FCERR"
; ----------------------------------------------------------------------
FCERR:	ld	e,ERRFC		;1e4a
	jp	ERROR		;1e4c
;
; ----------------------------------------------------------------------
; 1E4F-1E79 - Line Number Conversion Routine 1 - "LINSPC"
;   LINSPC and LINGET are identical except that LINSPC also permits the
;   use of a '.' to act as the current line number. Otherwise, They read
;   the line number from the current position in the BASIC program.
;   Possible line numbers are 00000-65529. On exit, DE holds the line
;   number, and HL is updated to point to the terminating character,
;   and Register A will contain the terminating character with the
;   FLAGs set based on Register A's value.
; ----------------------------------------------------------------------
LINSPC:	ld	a,(hl)		;1e4f
	cp	$2E		;1e50
	ex	de,hl		;1e52
	ld	hl,(DOT)	;1e53
	ex	de,hl		;1e56
	jp	z,CHRGTR	;1e57
;
; ======================================================================
; 1E5A - ASCII To Integer - "LINGET"
;   Converts numeric ASCII string pointed to by the HL Register Pair,
;   and places the result in the DE Register Pair
;   Conversion will cease when the first non-numeric character
;   is found. A value of zero is returned if no numeric value is found
;   Maximum allowable value is 65529
; ----------------------------------------------------------------------
LINGET:	dec	hl		;1e5a
LINGT2:	ld	de,$0000	;1e5b
MORLIN:	GETCHR			;1e5e - rst 10h
	ret	nc		;1e5f
	push	hl		;1e60
	push	af		;1e61
	ld	hl,6552		;1e62
	CPDEHL			;1e65
	jp	c,SNERR		;1e66
	ld	h,d		;1e69
	ld	l,e		;1e6a
	add	hl,de		;1e6b
	add	hl,hl		;1e6c
	add	hl,de		;1e6d
	add	hl,hl		;1e6e
	pop	af		;1e6f
	sub	'0'		;1e70 - Convert the ASCII digit to binary
	ld	e,a		;1e72
	ld	d,$00		;1e73 - DE will be binary 0000 through 0009
	add	hl,de		;1e75
	ex	de,hl		;1e76
	pop	hl		;1e77
	jr	MORLIN		;1e78
;
; ----------------------------------------------------------------------
; 1E7A-1EA0 - LEVEL II BASIC CLEAR ROUTINE - "CLEAR"
;   this will change the amount
;   of string space allowed. If no formula is given, the amount of string
;   space will remain unchanged. On entry, if the Z flag is set,
;   there was no parameter present
; ----------------------------------------------------------------------
CLEAR:	jp	z,CLEARC	;1e7a
	call	INTID2		;1e7d
	dec	hl		;1e80
	GETCHR			;1e81 - rst 10h
	ret	nz		;1e82
	push	hl		;1e83
	ld	hl,(MEMSIZ)	;1e84
	ld	a,l		;1e87
	sub	e		;1e88
	ld	e,a		;1e89
	ld	a,h		;1e8a
	sbc	a,d		;1e8b
	ld	d,a		;1e8c
	jp	c,OMERR		;1e8d
	ld	hl,(VARTAB)	;1e90
	ld	bc,$0028	;1e93 least amount of space needed for BASIC program variables
	add	hl,bc		;1e96
	CPDEHL			;1e97
	jp	nc,OMERR	;1e98
	ex	de,hl		;1e9b
	ld	(STKTOP),hl	;1e9c
	pop	hl		;1e9f
	jp	CLEARC		;1ea0
;
; ----------------------------------------------------------------------
; 1EA3-1EB0 - LEVEL II BASIC RUN ROUTINE - "RUN"
;   This is the MAIN entry Point
;   On entry, if the Z flag is set, there was no parameter present
; ----------------------------------------------------------------------
RUN:	jp	z,RUNC		;1ea3 - Jump if there isn't a line number specified after the RUN
	call	LRUN		;1ea6 - see if DOS wants to do anything?
	call	CLEARC		;1ea9 - initialize RUN time variables
	ld	bc,NEWSTT	;1eac - BC with the continuation address in the execution driver, RETurn to NEWSTT
	jr	RUNC2		;1eaf - Use GOTO code to begin execution at specified line
;
; ----------------------------------------------------------------------
; 1EB1-1EC1 - LEVEL II BASIC GOSUB ROUTINE - "GOSUB"
; ----------------------------------------------------------------------
GOSUB:	ld	c,$03		;1eb1
	call	GETSTK		;1eb3
	pop	bc		;1eb6
	push	hl		;1eb7
	push	hl		;1eb8
	ld	hl,(CURLIN)	;1eb9
	ex	(sp),hl		;1ebc
	ld	a,TKGOSU	;1ebd - Load A with a GOSUB token
	push	af		;1ebf
	inc	sp		;1ec0
RUNC2:	push	bc		;1ec1
;
; ----------------------------------------------------------------------
; 1EC2-1EDD - LEVEL II BASIC GOTO ROUTINE - "GOTO"
; ----------------------------------------------------------------------
GOTO:	call	LINGET		;1ec2
GOTO2:	call	REM		;1ec5
	push	hl		;1ec8
	ld	hl,(CURLIN)	;1ec9
	CPDEHL			;1ecc
	pop	hl		;1ecd
	inc	hl		;1ece
	call	c,FNLOOP	;1ecf
	call	nc,FNDLIN	;1ed2
	ld	h,b		;1ed5
	ld	l,c		;1ed6
	dec	hl		;1ed7
	ret	c		;1ed8
; ----------------------------------------------------------------------
; 1ED9H - ?UL ERROR ENTRY POINT - "USERR"
; ----------------------------------------------------------------------
USERR:	ld	e,ERRUL		;1ed9
	jp	ERROR		;1edb
;
; ----------------------------------------------------------------------
; 1EDE-1E04 - LEVEL II BASIC RETURN ROUTINE - "RETURN"
;   Returns control to the BASIC statement following the last GOSUB call
; ----------------------------------------------------------------------
RETURN:	ret	nz		;1ede
	ld	d,$FF		;1edf
	call	FNDFOR		;1ee1
	ld	sp,hl		;1ee4
	ld	(SAVSTK),hl	;1ee5
	cp	TKGOSU		;1ee8 - Check if is a GOSUB token
	ld	e,ERRRG		;1eea
	jp	nz,ERROR	;1eec
	pop	hl		;1eef
	ld	(CURLIN),hl	;1ef0
	inc	hl		;1ef3
	ld	a,h		;1ef4
	or	l		;1ef5
	jr	nz,GOBACK	;1ef6
	ld	a,(BFKLFL)	;1ef8
	or	a		;1efb
	jp	nz,STPRDY	;1efc
GOBACK:	ld	hl,NEWSTT	;1eff
	ex	(sp),hl		;1f02
;
	.DB	LDANN		;1f03 - Z80 Trick LD A,nn - skp next instruction - load it into A
;
DATAH:	pop	hl		;1f04
;
; ----------------------------------------------------------------------
; 1F05-1F20 - SCAN ROUTINE - "DATA"
; ----------------------------------------------------------------------
DATA:	.DB	LDBCNN, $3A	;1f05 - Z80 Trick - LD BC,$nn3A - skip the next 1 byte - Then a NOP
REM:	ld	c,$00		;1f07 - z80 Trick - noting second byte here is 0 which is a NOP
	ld	b,$00		;1f09
EXCHQT:	ld	a,c		;1f0b
	ld	c,b		;1f0c
	ld	b,a		;1f0d
REMER:	ld	a,(hl)		;1f0e
	or	a		;1f0f
	ret	z		;1f10
	cp	b		;1f11
	ret	z		;1f12
	inc	hl		;1f13
	cp	DQUOTE		;1f14 - Check to see if is a quote "
	jr	z,EXCHQT	;1f16
	sub	TKIF		;1f18 - Check to see if is a IF token
	jr	nz,REMER	;1f1a
	cp	b		;1f1c
	adc	a,d		;1f1d
	ld	d,a		;1f1e
	jr	REMER		;1f1f
;
; ----------------------------------------------------------------------
; 1F21-1F6B - LEVEL II BASIC LET ROUTINE - "LET"
; ----------------------------------------------------------------------
LET:	call	PTRGET		;1f21
	SYNTAX	(TKEQL)		;1f24 - rst 08h Test if the variable name is followed by a = token
	ex	de,hl		;1f26
	ld	(TEMP),hl	;1f27
	ex	de,hl		;1f2a
	push	de		;1f2b
	TSTDAT			;1f2c
	push	af		;1f2d
	call	FRMEVL		;1f2e
	pop	af		;1f31
	ex	(sp),hl		;1f32
INPCOM:	add	a,$03		;1f33
	call	DOCNVF		;1f35
	call	VDFACS		;1f38
	push	hl		;1f3b
	jr	nz,COPNUM	;1f3c
	ld	hl,(FACLO)	;1f3e
	push	hl		;1f41
	inc	hl		;1f42
	ld	e,(hl)		;1f43
	inc	hl		;1f44
	ld	d,(hl)		;1f45
	ld	hl,(TXTTAB)	;1f46
	CPDEHL			;1f49
	jr	nc,INBUFC	;1f4a
	ld	hl,(STKTOP)	;1f4c
	CPDEHL			;1f4f
	pop	de		;1f50
	jr	nc,DNTCPY	;1f51
	ld	hl,(VARTAB)	;1f53
	CPDEHL			;1f56
	jr	nc,DNTCPY	;1f57
;
	.DB	LDANN		;1f58 Z80 Trick - LD A,nn - skip next instruction
;
INBUFC:	pop	de		;1f5a
	call	FRETMS		;1f5b
	ex	de,hl		;1f5e
	call	STRCPY		;1f5f
DNTCPY:	call	FRETMS		;1f62
	ex	(sp),hl		;1f65
COPNUM:	call	VMOVE		;1f66
	pop	de		;1f69
	pop	hl		;1f6a
	ret			;1f6b
;
; ----------------------------------------------------------------------
; 1F6C-1FAE - LEVEL II BASIC ERROR ON ROUTINE - "ONGOTO"
; ----------------------------------------------------------------------
ONGOTO:	cp	TKERRO		;1f6c - is an ERROR token (meant to be ON ERROR)
	jr	nz,NTOERR	;1f6e - Not ON ERROR check for other ON statements
	GETCHR			;1f70 - rst 10h
	SYNTAX	(TKGOTO)	;1f71 - rst 08h
	call	LINGET		;1f73
	ld	a,d		;1f76
	or	e		;1f77
	jr	z,RESTRP	;1f78
	call	FNDLN1		;1f7a
	ld	d,b		;1f7d
	ld	e,c		;1f7e
	pop	hl		;1f7f
	jp	nc,USERR	;1f80
RESTRP:	ex	de,hl		;1f83
	ld	(ONELIN),hl	;1f84
	ex	de,hl		;1f87
	ret	c		;1f88
	ld	a,(ONEFLG)	;1f89
	or	a		;1f8c
	ret	z		;1f8d
	ld	a,(ERRFLG)	;1f8e
	ld	e,a		;1f91
	jp	ERRESM		;1f92
; ----------------------------------------------------------------------
; We know it isn't ON ERROR. We now need to deal with the possibility
; that it was an ON n GOTO or ON n GOSUB
; ----------------------------------------------------------------------
NTOERR:	call	GETBYT		;1f95
	ld	a,(hl)		;1f98
	ld	b,a		;1f99
	cp	TKGOSU		;1f9a - IS Register A a GOSUB token
	jr	z,ISGOSU	;1f9c - Skip the next 2 opcodes since a GOSUB
	SYNTAX	(TKGOTO)	;1f9e - rst 08h
	dec	hl		;1fa0
ISGOSU:	ld	c,e		;1fa1
LOOPON:	dec	c		;1fa2
	ld	a,b		;1fa3
	jp	z,GONE2		;1fa4
	call	LINGT2		;1fa7
	cp	','		;1faa
	ret	nz		;1fac
	jr	LOOPON		;1fad
; ----------------------------------------------------------------------
; 1FAF-1FF3 - LEVEL II BASIC RESUME ROUTINE - "RESUME"
; ----------------------------------------------------------------------
RESUME:	ld	de,ONEFLG	;1faf
	ld	a,(de)		;1fb2
	or	a		;1fb3
	jp	z,REERR		;1fb4
	inc	a		;1fb7
	ld	(ERRFLG),a	;1fb8
	ld	(de),a		;1fbb
	ld	a,(hl)		;1fbc
	cp	TKNEXT		;1fbd - Check to see if it is a NEXT token
	jr	z,RESNXT	;1fbf
	call	LINGET		;1fc1
	ret	nz		;1fc4
	ld	a,d		;1fc5
	or	e		;1fc6
	jp	nz,GOTO2	;1fc7
	inc	a		;1fca
	jr	RESTXT		;1fcb
;
; ----------------------------------------------------------------------
; 1FCDH - Part of the RESUME routine - "RESNXT"
; ----------------------------------------------------------------------
RESNXT:	GETCHR			;1fcd - rst 10h
	ret	nz		;1fce
; ----------------------------------------------------------------------
; 1FCF - This is the RESUME 0 routine - "RESTXT"
; ----------------------------------------------------------------------
RESTXT:	ld	hl,(ERRTXT)	;1fcf
	ex	de,hl		;1fd2
	ld	hl,(ERRLIN)	;1fd3
	ld	(CURLIN),hl	;1fd6
	ex	de,hl		;1fd9
	ret	nz		;1fda
	ld	a,(hl)		;1fdb
	or	a		;1fdc
	jr	nz,NOTBGL	;1fdd
	inc	hl		;1fdf
	inc	hl		;1fe0
	inc	hl		;1fe1
	inc	hl		;1fe2
NOTBGL:	inc	hl		;1fe3
	ld	a,d		;1fe4
	and	e		;1fe5
	inc	a		;1fe6
	jp	nz,DATA		;1fe7
	ld	a,(BFKLFL)	;1fea
	dec	a		;1fed
	jp	z,STPEND	;1fee
	jp	DATA		;1ff1
; ----------------------------------------------------------------------
; 1FF4H-2007 - LEVEL II BASIC ERROR ROUTINE - "ERRORS"
;   This evaluates n for ERROR n
; ----------------------------------------------------------------------
ERRORS:	call	GETBYT		;1ff4
	ret	nz		;1ff7
	or	a		;1ff8
	jp	z,FCERR		;1ff9
	dec	a		;1ffc
	add	a,a		;1ffd
	ld	e,a		;1ffe
	cp	$2D		;1fff
	jr	c,GOERR		;2001
; ----------------------------------------------------------------------
; 2003H - ?UE ERROR ENTRY POINT - "UEERR"
; ----------------------------------------------------------------------
UEERR:	ld	e,ERRUE		;2003
GOERR:	jp	ERROR		;2005
;
; ----------------------------------------------------------------------
; 2008-2038 – LEVEL II BASIC AUTO ROUTINE – “AUTO”
;   the AUTO [begin,[inc]]
;   command is used to generate line number for lines to be inserted.
; ----------------------------------------------------------------------
AUTO:	ld	de,000AH	;2008
	push	de		;200b
	jr	z,SNGAUT	;200c
	call	LINSPC		;200e
	ex	de,hl		;2011
	ex	(sp),hl		;2012
; At this point, DE points to the current character in the BASIC line
; being processed, “10” is in HL, and the initial number is on the STACK.
	jr	z,SNGAU1	;2013
	ex	de,hl		;2015
	SYNTAX	(',')		;2016 - rst 08h
	ex	de,hl		;2018
	ld	hl,(AUTINC)	;2019
	ex	de,hl		;201c
	jr	z,SNGAUT	;201d
	call	LINGET		;201f
	jp	nz,SNERR	;2022
SNGAUT:	ex	de,hl		;2025
SNGAU1:	ld	a,h		;2026
	or	l		;2027
	jp	z,FCERR		;2028
	ld	(AUTINC),hl	;202b
	ld	(AUTFLG),a	;202e
	pop	hl		;2031
	ld	(AUTLIN),hl	;2032
	pop	bc		;2035
	jp	MAIN		;2036
;
; ----------------------------------------------------------------------
; 2039-2066 – LEVEL II BASIC IF ROUTINE – “IF”
; ----------------------------------------------------------------------
IF:	call	FRMEVL		;2039
	ld	a,(hl)		;203c
	cp	','		;203d
	call	z,CHRGTR	;203f
	cp	TKTHEN		;2042
	call	z,CHRGTR	;2044
	dec	hl		;2047
	push	hl		;2048
	call	VSIGN		;2049
	pop	hl		;204c
	jr	z,FALSIF	;204d
DOCOND:	GETCHR			;204f - rst 10h
	jp	c,GOTO		;2050
	jp	GONE3		;2053
;
; ----------------------------------------------------------------------
; 2056H – LEVEL II BASIC ELSE ROUTINE – “FALSIF”
; ----------------------------------------------------------------------
FALSIF:	ld	d,$01		;2056
SKPMRF:	call	DATA		;2058
	or	a		;205b
	ret	z		;205c
	GETCHR			;205d - rst 10h
	cp	TKELSE		;205e - else token
	jr	nz,SKPMRF	;2060
	dec	d		;2062
	jr	nz,SKPMRF	;2063
	jr	DOCOND		;2065
; ----------------------------------------------------------------------
; 2067-206E – LEVEL II BASIC LPRINT ROUTINE – FOR v1.0 ONLY– “LPRINT”
; ----------------------------------------------------------------------
LPRINT:	ld	a,DEV1PRT	;2067 - Device PRINTER
	ld	(PRTFLG),a	;2069 - set the output device code - printer
LPRIN1:	jp	NEWCHR		;206c * * *
; ----------------------------------------------------------------------
; 206F-2177 – LEVEL II BASIC PRINT@ ROUTINE – FOR v1.0 ONLY – “PRINT”
; ----------------------------------------------------------------------
PRINT:	call	FILGET		;206f
	cp	'#'		;2072
	jr	nz,PNOTAT	;2074
	call	CWRTON		;2076 Write header on cassette file
	ld	(PRTFLG),a 	;2079 Set current system device to cassette
PNOTAT:
NEWCHR:	dec	hl 		;207C Backspace over previous symbol in code string
	GETCHR	 		;207D rst 10h Re-examine previous char in code string
	call	z,CRDO 		;207E If end of string write a Carriage Return
PRINTC:	jp	z,FINPRT	;2081 If end of string turn off cassette and return
	or	$20		;2084 Not end of string. Convert possible 40 to 60
 	cp	BQUOTE	 	;2086 Compare against a "'", which is actually a @ with OR $20
	jr	nz,PRINTD	;2088 Jmp if not PRINT @
 	call	GETINT 		;208A Evaluate @ expression, result in DE * PRINT @ routine
	cp	$04		;208D A = MSB, test for @ value > 1023
 	jp	nc,FCERR	;208E FC error if @ position > 1023
	push	hl	 	;2092  Save current code string addr
	ld	hl,vidmem	;2093 HL = starting addr of video buffer
	add	hl,de		;2096  Add tab position
 	ld	(CURSOR),hl	;2097 And save addr in video DCB as cursor addr
	ld	a,e		;209A Then get position within line
	and	$3F		;209B And truncate it to 63
 	ld	(TTYPOS),a 	;209D Then save as current position within line
	pop	hl		;20A0 Restore code string addr (starting addr of item list)
	SYNTAX	(',')		;20A1 rst 08h But make sure a comma follows the tab position
	jr	LPRIN1		;20A3 Go get first variable from item list
PRINTD:	ld	a,(hl)		;20A5 Reload next element from code string
	cp	TKUSNG		;20A6 Test for USING token
	jp	z,PRINUS	;20A8 Jmp if USING token
	cp	TKTAB		;20AB Test for TAB token
	jp	z,TABER		;20AD  Jmp if TAB token
	push	hl		;20B0  Save current code string addr
	cp	','		;20B1 Test for a comma
	jr	z,COMPRT	;20B3 Go get next item if a comma
 	cp	SEMICO		;20B5 Not comma, test for semi-colon
	jr	z,NTCAS0	;20B7 Go get next item if semi-colon
	call	FRMEVL		;20B9 Evaluate next item to be printed
 	ex	(sp),hl		;20BC Save current code string addr HL = addr of current item
	TSTDAT			;20bd
	jr	z,STRDON	;20be
	call	FOUT		;20c0
	call	STRLIT		;20c3
	call	EXDSKL		;20c6
	ld	hl,(FACLO)	;20c9
	ld	a,(PRTFLG)	;20cc - Get the output device type flag into A
	or	a		;20cf - set flags
	jp	m,LINCH2	;20d0 - If we writing to a cassette
	jr	z,ISTTY		;20d3 - If NOT LPRINT
	ld	a,(LPTPOS)	;20d5 - We have a LPRINT, Get carriage POS
	add	a,(hl)		;20d8
	cp	132		;20d9 - Is the adjusted length greater than 132
	jr	LINCHK		;20db
; ----------------------------------------------------------------------
; 20DDH – LEVEL II BASIC PRINT@ ROUTINE – “ISTTY”
;   Jumped here if we are sure we are using the display
; ----------------------------------------------------------------------
ISTTY:	ld	a,(LINLEN)	;20dd
	ld	b,a		;20e0 - the video line size
	ld	a,(TTYPOS)	;20e1 - current video line position
	add	a,(hl)		;20e4 - Add the len of string to be displayed
	cp	b		;20e5 - compare with line size
LINCHK:	call	nc,CRDO		;20e6 - the new line will overflow the buffer -> CR
LINCH2:	call	STRPRT		;20e9
	ld	a,SPACE		;20ec
	call	OUTDO		;20ee
	or	a		;20f1
STRDON:	call	z,STRPRT	;20f2
	pop	hl		;20f5
	jp	NEWCHR		;20f6
CRDONZ:	ld	a,(TTYPOS)	;20f9
	or	a		;20fc
	ret	z		;20fd
; ----------------------------------------------------------------------
; 20FE – This routine outputs a carriage return (0DH)
;   to a device determined by flag stored at (409CH) – “CRDO”
; ----------------------------------------------------------------------
CRDO:	ld	a,ENTER		;20fe
	call	OUTDO		;2100
CRFIN:	call	EXDSCR		;2103
	xor	a		;2106
	ret			;2107
; ----------------------------------------------------------------------
; 2108 – This is the jump point for a continuation of the PRINT# code – “COMPRT”.
; ----------------------------------------------------------------------
COMPRT:	call	EXPDOS		;2108
	ld	a,(PRTFLG)	;210b - the current output device flag
	or	a		;210e - Set The Flags
	jp	p,NTCAS		;210f - if the printer or the video display
	ld	a,','		;2112
	call	OUTDO		;2114
NTCAS0:	jr	NOTABR		;2117
NTCAS:	jr	z,ISCTTY	;2119 - is it the video display
	ld	a,(LPTPOS)	;211b - the current carriage position.
	cp	$70		;211e
	jp	CHKCOM		;2120
ISCTTY:	ld	a,(CLMLST)	;2123 - output device is the video display
	ld	b,a		;2126
	ld	a,(TTYPOS)	;2127
	cp	b		;212a
CHKCOM:	call	nc,CRDO		;212b
	jr	nc,NOTABR	;212e
MORCOM:	sub	$10		;2130
	jr	nc,MORCOM	;2132
	cpl			;2134
	jr	ASPA2		;2135
; ----------------------------------------------------------------------
; 2137 – TAB logic – “TABER”
;   This routine is the TAB function for video or printer (flag at 409CH).
;   On entry: E Register contains desired TAB position,
;   HL points to start of message to be displayed
; ----------------------------------------------------------------------
TABER:	call	GTBYTC		;2137 - evaluate the tab number, and return with the result in A
	and	$7F		;213a - Result in A-reg. Do not let it exceed 127
	; and	$3F		;213a - Do not let it exceed 63 (V1.2)
	ld	e,a		;213c
	SYNTAX	(')')		;213d - rst 08h
	dec	hl		;213f
; ----------------------------------------------------------------------
	push	hl		;2140
	call	EXPDOS		;2141
	ld	a,(PRTFLG)	;2144 - the current output device flag
	or	a		;2147 - set the flags
	jp	m,FCERR		;2148 - cannot send a tab to cassette, FC ERR
	jp	z,TTYIST	;214b - is Video
	ld	a,(LPTPOS)	;214e - printer get carriage position
	jr	DOSIST		;2151
TTYIST:	ld	a,(TTYPOS)	;2153
DOSIST:	cpl			;2156
	add	a,e		;2157
	jr	nc,NOTABR	;2158
ASPA2:	inc	a		;215a
	ld	b,a		;215b
	ld	a,SPACE		;215c
REPOUT:	call	OUTDO		;215e
	dec	b		;2161
	jr	nz,REPOUT	;2162
NOTABR:	pop	hl		;2164
	GETCHR			;2165 - rst 10h
	jp	PRINTC		;2166
; ----------------------------------------------------------------------
; 2169 – FINPRT - This routine resets the device type flag at 409CH to
;        zero (output to video display), also turns off cassette drive if
;        necessary. CALLs Disk BASIC link at 41BEH prior to return.
; ----------------------------------------------------------------------
FINPRT:
	ld	a,(PRTFLG)	;2169 - current output device flag
	or	a		;216c - check the flags
	call	m,CTOFF		;216d - If cassette, turn it off
	xor	a		;2170
	ld	(PRTFLG),a	;2171 - set current output device type = VIDEO
	call	FINDRT		;2174 - DOS Exit Point
	ret			;2177
; ----------------------------------------------------------------------
; 2178-217E – MESSAGE STORAGE LOCATION FOR REDO MESSAGE – “TRYAGN”
; ----------------------------------------------------------------------
TRYAGN:	.DB	"?REDO"
	.DB	ENTER
	.DB	0
; ----------------------------------------------------------------------
; 217F-2285 – INPUT AND READ ROUTINES– “TRMNOK”
; ----------------------------------------------------------------------
TRMNOK:	ld	a,(FLGINP)	;217f
	or	a		;2182
	jp	nz,DATSNE	;2183
	ld	a,(CASFLG)	;2186
	or	a		;2189
	ld	e,ERRFD		;218a
	jp	z,ERROR		;218c
	pop	bc		;218f
	ld	hl,TRYAGN	;2190
	call	STROUT		;2193
	ld	hl,(SAVTXT)	;2196
	ret			;2199
;
; ----------------------------------------------------------------------
; 219A-21EE – LEVEL II BASIC INPUT ROUTINE – “INPUT”
; ----------------------------------------------------------------------
INPUT:	call	ERRDIR		;219a
	ld	a,(hl)		;219d
	call	EXUNKN		;219e
	sub	'#'		;21a1 - compare with #
	ld	(CASFLG),a	;21a3
	ld	a,(hl)		;21a6
	jr	nz,INTCAS	;21a7
	call	CSRDON		;21a9
	push	hl		;21ac
	ld	b,250		;21ad - Max characters which can be read
	ld	hl,(BUFPNT)	;21af - input buffer
FILBUF:	call	CASIN		;21b2
	ld	(hl),a		;21b5
	inc	hl		;21b6
	cp	ENTER		;21b7
	jr	z,ENDREC	;21b9
	djnz	FILBUF		;21bb
ENDREC:	dec	hl		;21bd
	ld	(hl),$00	;21be
	call	CTOFF		;21c0
	ld	hl,(BUFPNT)	;21c3
	dec	hl		;21c6
	jr	INPCN3		;21c7
INTCAS:	ld	bc,NOTQTI	;21c9
	push	bc		;21cc
	cp	DQUOTE		;21cd
	ret	nz		;21cf
	call	STRLTI		;21d0
	SYNTAX	(SEMICO)	;21d3 - rst 08h compare with semicolin ';'
	push	hl		;21d5
	call	STRPRT		;21d6
	pop	hl		;21d9
	ret			;21da
NOTQTI:	push	hl		;21db
	call	QINLIN		;21dc - Print '?' - and get the input from the keyboard
	pop	bc		;21df
	jp	c,STPEND	;21e0
; -----------------------------------------------------------------------
; 21E3 - ASSIGN STRING(S) TO BASIC VARIABLE(S) (TAS)
;   This routine is part of the BASIC INPUT command routine , and can be
;   used to process input obtained from CALLing one of the keyboard input
;   routines at 1BB3H, 0361H, etc. On entry, BC must point to the first
;   character of a string that contains the variable name(s) (if more than
;   one variable name is used the names must be separatedby commas, and a
;   zero byte or colon must be placed after the last variable name). HL
;   must point to the byte just prior to the beginning of the input string
;   (this is where placed by the above - mentioned input routines -
;   that this byte is altered by this routine), and the string may
;   contain input for more than one variable (items must be separated by
;   commas).
; -----------------------------------------------------------------------
	inc	hl		;21e3
	ld	a,(hl)		;21e4
	or	a		;21e5
	dec	hl		;21e6
	push	bc		;21e7
	jp	z,DATAH		;21e8
INPCN3:	ld	(hl),','	;21eb
	jr	INPCON		;21ed
;
; ----------------------------------------------------------------------
; 21EF – READ logic – “READ”
READ:	push	hl		;21ef
	ld	hl,(DATPTR)	;21f0
;
	.DB	ORNN		;21f3 - Z80 Trick - OR nn - skip next 1 byte
;
INPCON:	xor	a		;21f4
	ld	(FLGINP),a	;21f5
	ex	(sp),hl		;21f8
	jr	LOPDAT		;21f9
LOPDT2:	SYNTAX	(',')		;21fb - rst 08h
LOPDAT:	call	PTRGET		;21fd
	ex	(sp),hl		;2200
	push	de		;2201
	ld	a,(hl)		;2202
	cp	','		;2203
	jr	z,DATBK		;2205
	ld	a,(FLGINP)	;2207
	or	a		;220a
	jp	nz,DATLOP	;220b
	ld	a,(CASFLG)	;220e
	or	a		;2211
	ld	e,ERROD		;2212
	jp	z,ERROR		;2214
	ld	a,'?'		;2217
	call	OUTDO		;2219
	call	QINLIN		;221c
	pop	de		;221f
	pop	bc		;2220
	jp	c,STPEND	;2221
	inc	hl		;2224
	ld	a,(hl)		;2225
	or	a		;2226
	dec	hl		;2227
	push	bc		;2228
	jp	z,DATAH		;2229
	push	de		;222c
DATBK:	call	FILIND		;222d
	TSTDAT			;2230
	push	af		;2231
	jr	nz,NUMINS	;2232
	GETCHR			;2234 - rst 10h
	ld	d,a		;2235
	ld	b,a		;2236
	cp	DQUOTE		;2237
	jr	z,NOWGETR	;2239
	ld	d,':'		;223b
	ld	b,','		;223d
	dec	hl		;223f
NOWGETR: call	STRLT2		;2240
DOASIG:	pop	af		;2243
	ex	de,hl		;2244
	ld	hl,STRDN2	;2245
	ex	(sp),hl		;2248
	push	de		;2249
	jp	INPCOM		;224a
NUMINS:	GETCHR			;224d - rst 10h
	pop	af		;224e
	push	af		;224f
	ld	bc,DOASIG	;2250
	push	bc		;2253
	jp	c,FIN		;2254
	jp	nc,FINDBL	;2257
STRDN2:	dec	hl		;225a
	GETCHR			;225b - rst 10h
	jr	z,TRMOK		;225c
	cp	','		;225e
	jp	nz,TRMNOK	;2260
TRMOK:	ex	(sp),hl		;2263
	dec	hl		;2264
	GETCHR			;2265 - rst 10h
	jp	nz,LOPDT2	;2266
	pop	de		;2269
; ----------------------------------------------------------------------
; Removed in ROM v1.2 because this was not needed.
; ----------------------------------------------------------------------
	nop			;226a
	nop			;226b
	nop			;226c
	nop			;226d
	nop			;226e
; ----------------------------------------------------------------------
	ld	a,(FLGINP)	;226f
	or	a		;2272
	ex	de,hl		;2273
	jp	nz,RESFIN	;2274
	push	de		;2277
	call	EXCHDS		;2278
	or	(hl)		;227b
	ld	hl,EXIGNT	;227c
	call	nz,STROUT	;227f
	pop	hl		;2282
	jp	FINPRT		;2283
; ----------------------------------------------------------------------
; 2286-2295 – MESSAGE STORAGE LOCATION – “EXIGNT”
; ----------------------------------------------------------------------
EXIGNT:	.DB	"?Extra ignored"
	.DB	ENTER, $00
; ----------------------------------------------------------------------
; 2296-22B5 – FIND THE NEXT DATA STATEMENT ROUTINE – “DATLOP”
;   The original ROM source notes that the search is mad by uising
;   the execution code for DATA to skp over statements.
; ----------------------------------------------------------------------
DATLOP:	call	DATA		;2296
DATFND:	or	a		;2299
	jr	nz,NOWLIN	;229a
	inc	hl		;229c
	ld	a,(hl)		;229d
	inc	hl		;229e
	or	(hl)		;229f
	ld	e,ERROD		;22a0
	jp	z,ERROR		;22a2
	inc	hl		;22a5
	ld	e,(hl)		;22a6
	inc	hl		;22a7
	ld	d,(hl)		;22a8
	ex	de,hl		;22a9
	ld	(DATLIN),hl	;22aa
	ex	de,hl		;22ad
NOWLIN:	GETCHR			;22ae - rst 10h
	cp	TKDATA		;22af - data token
	jr	nz,DATLOP	;22b1
	jp	DATBK		;22b3
;
; ----------------------------------------------------------------------
; 22B6-2336 – LEVEL II BASIC NEXT ROUTINE – “NEXT”
; ----------------------------------------------------------------------
NEXT:	ld	de,$0000	;22b6
NEXTC:	call	nz,PTRGET	;22b9
	ld	(TEMP),hl	;22bc
	call	FNDFOR		;22bf
	jp	nz,NFERR	;22c2
	ld	sp,hl		;22c5
	ld	(SAVSTK),hl	;22c6
	push	de		;22c9
	ld	a,(hl)		;22ca
	inc	hl		;22cb
	push	af		;22cc
	push	de		;22cd
	ld	a,(hl)		;22ce
	inc	hl		;22cf
	or	a		;22d0
	jp	m,INTNXT	;22d1
	call	MOVFM		;22d4
	ex	(sp),hl		;22d7
	push	hl		;22d8
	call	FADDS		;22d9
	pop	hl		;22dc
	call	MOVMF		;22dd
	pop	hl		;22e0
	call	MOVRM		;22e1
	push	hl		;22e4
	call	FCOMP		;22e5
	jr	FINNXT		;22e8
;
; ----------------------------------------------------------------------
; 22EAH - Part of the NEXT code, process the variable as an int “INTNXT”
; ----------------------------------------------------------------------
INTNXT:	inc	hl		;22ea
	inc	hl		;22eb
	inc	hl		;22ec
	inc	hl		;22ed
	ld	c,(hl)		;22ee
	inc	hl		;22ef
	ld	b,(hl)		;22f0
	inc	hl		;22f1
	ex	(sp),hl		;22f2
	ld	e,(hl)		;22f3
	inc	hl		;22f4
	ld	d,(hl)		;22f5
	push	hl		;22f6
	ld	l,c		;22f7
	ld	h,b		;22f8
	call	IADD		;22f9
	ld	a,(VALTYP)	;22fc
	cp	VTSNG		;22ff - Compare with Single Precision
	jp	z,OVERR		;2301 - Is it Single precision
	ex	de,hl		;2304
	pop	hl		;2305
	ld	(hl),d		;2306
	dec	hl		;2307
	ld	(hl),e		;2308
	pop	hl		;2309
	push	de		;230a
	ld	e,(hl)		;230b
	inc	hl		;230c
	ld	d,(hl)		;230d
	inc	hl		;230e
	ex	(sp),hl		;230f
	call	ICOMP		;2310
; ----------------------------------------------------------------------
; 2313H	- Part of the NEXT code, continue after skipping over the int processing “FINNXT”
; ----------------------------------------------------------------------
FINNXT:	pop	hl		;2313
	pop	bc		;2314
	sub	b		;2315
	call	MOVRM		;2316
	jr	z,LOOPDN	;2319
	ex	de,hl		;231b
	ld	(CURLIN),hl	;231c
	ld	l,c		;231f
	ld	h,b		;2320
	jp	NXTCON		;2321
; ----------------------------------------------------------------------
; 2324H	– Part of the NEXT code, jumped if we haven’t hit the TO counter yet “LOOPDN”
; ----------------------------------------------------------------------
LOOPDN:	ld	sp,hl		;2324
	ld	(SAVSTK),hl	;2325
	ld	hl,(TEMP)	;2328
	ld	a,(hl)		;232b
	cp	','		;232c
	jp	nz,NEWSTT	;232e
	GETCHR			;2331 - rst 10h
	call	NEXTC		;2332
;
; ----------------------------------------------------------------------
; 2335-27C8 – EVALUATE EXPRESSION – “FRMPRN” and “FRMEVL”
;   this routine starts with HL
;   pointing to the first character of a formula. At the end of the routine
;   HL points to the terminator, and ACC holds the result. Important to
;   note that on exit Register A does not necessarily reflect the term char
; ----------------------------------------------------------------------
FRMPRN:	SYNTAX	('(')		;2335 - rst 08h
;----------------------------------------------------------------------
; FRMEVL evaluates a BASIC expression pointed to by the HL register pair and
; stores the result in the ACC. The expression must be terminated with zero byte,
; comma, right bracket or colon. After execution, HL will point to the delimiter and,
; in the case of string expressions, the ACC will contain the address of the first of
; three bytes that contain string length and string address. Note that the stack is used
; frequently and the machine should be formatted for RUN mode in order to use this
; routine. (See sample program in Appendix 1 for an application of this routine).
;----------------------------------------------------------------------
FRMEVL:	dec	hl		;2337
FRMCHK:	ld	d,$00		;2338
LPOPER:	push	de		;233a
	ld	c,$01		;233b
	call	GETSTK		;233d
	call	EVAL		;2340
	ld	(TEMP2),hl	;2343
RETAOP:	ld	hl,(TEMP2)	;2346
TSTOP:	pop	bc		;2349
	ld	a,(hl)		;234a
	ld	d,$00		;234b
LOPREL:	sub	TKGT		;234d - greatr than > Token
	jr	c,ENDREL	;234f
	cp	$03		;2351
	jr	nc,ENDREL	;2353
	cp	$01		;2355
	rla			;2357
	xor	d		;2358
	cp	d		;2359
	ld	d,a		;235a
	jp	c,SNERR		;235b
	ld	(TEMP3),hl	;235e
	GETCHR			;2361 - rst 10h
	jr	LOPREL		;2362
ENDREL:	ld	a,d		;2364
	or	a		;2365
	jp	nz,FINREL	;2366
	ld	a,(hl)		;2369
	ld	(TEMP3),hl	;236a
	sub	TKPLUS		;236d - plus token
	ret	c		;236f
	cp	$07		;2370
	ret	nc		;2372
	ld	e,a		;2373
	ld	a,(VALTYP)	;2374
	sub	VTSTR		;2377 - Adjust Type -1 INT, 0 STR, 1 SP, 5 DP.
	or	e		;2379 - Combine with operator value in Register E
	jp	z,CAT		;237a - If String addition.
	ld	hl,OPTAB	;237d - operation precidence table
	add	hl,de		;2380
	ld	a,b		;2381
	ld	d,(hl)		;2382
	cp	d		;2383
	ret	nc		;2384
	push	bc		;2385
	ld	bc,RETAOP	;2386
	push	bc		;2389
	ld	a,d		;238a
	cp	$7F		;238b
	jp	z,EXPSTK	;238d
	cp	$51		;2390
	jp	c,ANDORD	;2392
; the following will push the current value
; in the ACC onto the STACK EXCEPT in the case of a string, in which case it will throw
; a TYPE MISMATCH error. Registers D and E are preserved. This routine is also used in
; the user-defined function value savings
NUMREL:	ld	hl,FACLO	;2395
	or	a		;2398
	ld	a,(VALTYP)	;2399
	dec	a		;239c
	dec	a		;239d
	dec	a		;239e - Now A will be -1=Int, 0=Str, 1=SP, 5=DP
	jp	z,TMERR		;239f
	ld	c,(hl)		;23a2
	inc	hl		;23a3
	ld	b,(hl)		;23a4
	push	bc		;23a5
	jp	m,VPUSHD	;23a6
	inc	hl		;23a9
	ld	c,(hl)		;23aa
	inc	hl		;23ab
	ld	b,(hl)		;23ac
	push	bc		;23ad
	push	af		;23ae
	or	a		;23af
	jp	po,VPSHD1	;23b0
	pop	af		;23b3
	inc	hl		;23b4
	jr	c,PUSDVR	;23b5
	ld	hl,DFACLO	;23b7
PUSDVR:	ld	c,(hl)		;23ba
	inc	hl		;23bb
	ld	b,(hl)		;23bc
	inc	hl		;23bd
	push	bc		;23be
	ld	c,(hl)		;23bf
	inc	hl		;23c0
	ld	b,(hl)		;23c1
	push	bc		;23c2
;
	.DB	LDBNN		;23c3 - Z80 Trick - LD B,nn - Skip next 1 byte instrution
;
VPSHD1:	pop	af		;23c4
VPUSHD:	add	a,$03		;23c5
	ld	c,e		;23c7
	ld	b,a		;23c8
	push	bc		;23c9
	ld	bc,APPLOP	;23ca
FINTMP:	push	bc		;23cd
	ld	hl,(TEMP3)	;23ce
	jp	LPOPER		;23d1
;
; ----------------------------------------------------------------------
; 23D4-23D6 – Part of the Evaluation Routine – “EPSTK”
;   Per the original ROM source, for exponentiation, we want to force
;   the current value in the ACCumulator to be single precision.
;   When application time comes, we force the right hand operand to
;   single precision as well.
; ----------------------------------------------------------------------
EXPSTK:	call	FRCSNG		;23d4
	call	PUSHF		;23d7
	ld	bc,FPWRQ	;23da
	ld	d,$7F		;23dd
	jr	FINTMP		;23df
; ----------------------------------------------------------------------
; 23D4-23D6 – Part of the Evaluation Routine – “ANDORD”
;   for AND and OR and \ and MOD
;   we want to force the current value in the ACCumulator to be an integer,
;   and at application time force the right hand operator to be an integer as well.
; ----------------------------------------------------------------------
ANDORD:	push	de		;23e1
	call	FRCINT		;23e2
	pop	de		;23e5
	push	hl		;23e6
	ld	bc,DANDOR	;23e7
	jr	FINTMP		;23ea
; ----------------------------------------------------------------------
; 23D4-23D6 – Part of the Evaluation Routine – “FINREL”
;   this routine will build an
;   entry for a relational operator strings are treated specially.
;   Numeric compares are different from most operator entries only
;   in the fact that at the bottom instead of having RETAOP, DOCMP
;   and the relational bits are stored. Strings have STRCMP, the pointer
;   at the string descriptor, DOCMP and the relational bits.
; ----------------------------------------------------------------------
FINREL:	ld	a,b		;23ec
	cp	$64		;23ed
	ret	nc		;23ef
	push	bc		;23f0
	push	de		;23f1
	ld	de,$6404	;23f2
	ld	hl,DOCMP	;23f5
	push	hl		;23f8
	TSTDAT			;23f9
	jp	nz,NUMREL	;23fa
	ld	hl,(FACLO)	;23fd
	push	hl		;2400
	ld	bc,STRCMP	;2401
	jr	FINTMP		;2404
; ----------------------------------------------------------------------
; 2406 – Part of the Evaluation Routine – “APPLOP”
;   APPLOP is returned to when
;   it is time to apply an arithmetic or numeric comparison operation.
;   The STACK has a double byte entry with the operator number and the
;   NTF of the value on the STACK. APPLOP decides what value level
;   the operation will occur at, and converts the arguments.
; ----------------------------------------------------------------------
APPLOP:	pop	bc		;2406
	ld	a,c		;2407
	ld	(DORES),a	;2408
	ld	a,b		;240b
	cp	VTDBL		;240c - Is type of the number in the STACK Double
	jr	z,STKDBL	;240e - force the number in the ACC to Double
	ld	a,(VALTYP)	;2410
	cp	VTDBL		;2413 - Is it a Double Precision
	jp	z,FACDBL	;2415
	ld	d,a		;2418
	ld	a,b		;2419
	cp	VTSNG		;241a ; number type in the STACK is single precision
	jp	z,STKSNG	;241c
	ld	a,d		;241f ; number type for ACCumulator
	cp	VTSTR		;2420 ; Compare with String
	jp	z,TMERR		;2422 ; If String Then TM ERR
	jp	nc,FACSNG	;2425 ; If Single or Double Precsion
	ld	hl,INTDSP	;2428 - Integer Function lookup table
	ld	b,$00		;242b
	add	hl,bc		;242d
	add	hl,bc		;242e
	ld	c,(hl)		;242f
	inc	hl		;2430
	ld	b,(hl)		;2431
	pop	de		;2432
	ld	hl,(FACLO)	;2433
	push	bc		;2436
	ret			;2437
; ----------------------------------------------------------------------
; 2438 – Part of the Evaluation Routine – “STKDBL”
;   at this point we know
;   the STACK operand is double precision, so the number in the ACC
;   must be forced into double precision, then moved into ARG and the
;   STACK value POPped into ACC.
; ----------------------------------------------------------------------
STKDBL:	call	FRCDBL		;2438
	call	VMOVAF		;243b
	pop	hl		;243e
	ld	(DFACLO+2),hl	;243f
	pop	hl		;2442
	ld	(DFACLO),hl	;2443
SNGDBL:	pop	bc		;2446
	pop	de		;2447
	call	MOVFR		;2448
SETDBL:	call	FRCDBL		;244b
	ld	hl,DBLDSP	;244e - Double Precision Math Table
DODSP:	ld	a,(DORES)	;2451
	rlca			;2454
	push	bc		;2455
	ld	c,a		;2456
	ld	b,$00		;2457
	add	hl,bc		;2459
	pop	bc		;245a
	ld	a,(hl)		;245b
	inc	hl		;245c
	ld	h,(hl)		;245d
	ld	l,a		;245e
	jp	(hl)		;245f
; ----------------------------------------------------------------------
; 2460H – Part of the Evaluation Routine – “FACDBL”
;   at this point the ACCumulator
;   holds a double precision numbe, and the STACK holds either an integer
;   or a single precision number, so we need to convert it.
; ----------------------------------------------------------------------
FACDBL:	push	bc		;2460
	call	VMOVAF		;2461
	pop	af		;2464
	ld	(VALTYP),a	;2465
	cp	VTSNG		;2468 - compare with single precision
	jr	z,SNGDBL	;246a
	pop	hl		;246c
	ld	(FACLO),hl	;246d
	jr	SETDBL		;2470
; ----------------------------------------------------------------------
; 2472H – Part of the Evaluation Routine – “STKSNG”
;   at this point the STACK
;   holds a single precision number, we know that the ACCumulator holds
;   either an integer or a single precision number, so we need to convert it.
; ----------------------------------------------------------------------
STKSNG:	call	FRCSNG		;2472
	pop	bc		;2475
	pop	de		;2476
SNGDO:	ld	hl,SNGDSP	;2477  - address of the SP arithmetic table
	jr	DODSP		;247a
; ----------------------------------------------------------------------
; 247CH – Part of the Evaluation Routine – “FACSNG”
;   at this point the ACCuumulator
;   holds a single precision number and the STACK holds an integer.
; ----------------------------------------------------------------------
FACSNG:	pop	hl		;247c
	call	PUSHF		;247d
	call	CONSIH		;2480
	call	MOVRF		;2483
	pop	hl		;2486
	ld	(FAC-1),hl	;2487
	pop	hl		;248a
	ld	(FACLO),hl	;248b
	jr	SNGDO		;248e
;
; ======================================================================
; 2490 – LEVEL II BASIC INTEGER DIVIDE – “INTDIV”
;
;   (ACC=DE / HL) Result will be in single-precision (NTF=4) in the ACC.
;    Divides DE by HL. Both values are converted to single precision before
;   the division is started. The quotient is left in REG l; the mode flag
;   is updated. The orginal contents of the DE and HL Register sets are lost
; ----------------------------------------------------------------------
INTDIV:	push	hl		;2490
	ex	de,hl		;2491
	call	CONSIH		;2492
	pop	hl		;2495
	call	PUSHF		;2496
	call	CONSIH		;2499
	jp	FDIVT		;249c
;
; ----------------------------------------------------------------------
; 249F – Evaluate a Variable, Constant, or Function Call – “EVAL”
; ----------------------------------------------------------------------
EVAL:	GETCHR			;249f - rst 10h
	ld	e,ERRMO		;24a0
	jp	z,ERROR		;24a2
	jp	c,FIN		;24a5
	call	ISLET		;24a8
	jp	nc,ISVAR	;24ab
	cp	TKPLUS		;24ae - + token
	jr	z,EVAL		;24b0
	cp	'.'		;24b2
	jp	z,FIN		;24b4
	cp	TKMNUS		;24b7 - - token
	jp	z,DOMIN		;24b9
	cp	DQUOTE		;24bc - " character
	jp	z,STRLTI	;24be
	cp	TKNOT		;24c1 - NOT token
	jp	z,NOTER		;24c3
	cp	'&'		;24c6
	jp	z,DVAND		;24c8 - & Disk Basic Vector
	cp	TKERR		;24cb
	jr	nz,NTERC	;24cd
	GETCHR			;24cf - rst 10h
	ld	a,(ERRFLG)	;24d0
	push	hl		;24d3
	call	SNGFLT		;24d4
	pop	hl		;24d7
	ret			;24d8
NTERC:	cp	TKERL		;24d9 - ERL token
	jr	nz,NTERL	;24db
	GETCHR			;24dd - rst 10h
	push	hl		;24de
	ld	hl,(ERRLIN)	;24df
	call	INEG2		;24e2
	pop	hl		;24e5
	ret			;24e6
; ----------------------------------------------------------------------
; 24E7-24FE VARPTR logic – “NTERL”
; ----------------------------------------------------------------------
NTERL:	cp	TKVARP		;24e7 - varptr
	jr	nz,NTVARP	;24e9
	GETCHR			;24eb - rst 10h
	SYNTAX	('(')		;24ec - rst 08h
	call	PTRGET		;24ee
VARRET:	SYNTAX	(')')		;24f1 - rst 08h
	push	hl		;24f3
	ex	de,hl		;24f4
	ld	a,h		;24f5
	or	l		;24f6
	jp	z,FCERR		;24f7
	call	MAKINT		;24fa
	pop	hl		;24fd
	ret			;24fe
; ----------------------------------------------------------------------
; 24FF – Other Function Routine – Jumped here if it wasn’t VARPTR to
; see what else it might have been – “NTVARP”
; ----------------------------------------------------------------------
NTVARP:	cp	TKUSR		;24ff - USR Function
	jp	z,USRFN		;2501
	cp	TKINST		;2504 - INSTR Function
	jp	z,DVINST	;2506
	cp	TKMEM		;2509 - MEM Function
	jp	z,MEM		;250b
	cp	TKTIME		;250e - TIME$
	jp	z,DVTIME	;2510
	cp	TKPOIN		;2513 - POINT
	jp	z,POINT		;2515
	cp	TKINKY		;2518 - INKEY$
	jp	z,INKEY		;251a
	cp	TKSTRG		;251d - STRING$
	jp	z,STRNGS	;251f
	cp	TKFN		;2522
	jp	z,DVFN		;2524 - FN Handler
	sub	ONEFUN		;2527 - Is a function starting at SGN
	jp	nc,ISFUN	;2529 - Jump if is a SGN to MID$ token
; ----------------------------------------------------------------------
; 252CH – Other Function Routine – If we pass through to here, the only
; other possibility is that it is a function in parenthesis – “PARCHK”
;
; EVALUATE PARENTHESIZED EXPRESSION (TAS)
;   Call here to Evaluate a basic expression enclosed in parenthesis ()
; ----------------------------------------------------------------------
PARCHK:	call	FRMPRN		;252c - Evaluation expression starting with (
	SYNTAX	(')')		;252f - rst 08h = check for closing )
	ret			;2531
; ----------------------------------------------------------------------
; 2532 – Binary Minus Routine – “DOMIN”
; ----------------------------------------------------------------------
DOMIN:	ld	d,$7D		;2532
	call	LPOPER		;2534
	ld	hl,(TEMP2)	;2537
	push	hl		;253a
	call	VNEG		;253b
LABBCK:	pop	hl		;253e
	ret			;253f
; ----------------------------------------------------------------------
; 2540 – MATH ROUTINE – “ISVAR”
;   LOAD ACCUM WITH VALUE OF BASIC VARIABLE (TAS)
;   Get value of BASIC variable and put in ACCUM (also put precision of
;   variable in NFT) On entry HL mush point to first char of var name
;   On exit HL will point to first char following var name
; ----------------------------------------------------------------------
ISVAR:	call	PTRGET		;2540
RETVAR:	push	hl		;2543
	ex	de,hl		;2544
	ld	(FACLO),hl	;2545
	TSTDAT			;2548
	call	nz,VMOVFM	;2549
	pop	hl		;254c
	ret			;254d
; ----------------------------------------------------------------------
; 254E – This routine processes an expression for SNG( to MID$( – “ISFUN”
; ----------------------------------------------------------------------
ISFUN:	ld	b,$00		;254e
	rlca			;2550 - Set A to be 2 * (token – D7H)
	ld	c,a		;2551
	push	bc		;2552
	GETCHR			;2553 - rst 10h
	ld	a,c		;2554
	;2555 - Test the adjusted token to see if it is past 2 * LASNUM – 2 * ONEFUN + 1
	cp	$41
	jr	c,OKNORM	;2557 - Jump if the token is SGN( to CHR$(.
	call	FRMPRN		;2559 - If not, it is a LEFT$ – MID$
; ----------------------------------------------------------------------
	SYNTAX	(',')		;255c - rst 08h
	call	CHKSTR		;255e
	ex	de,hl		;2561
	ld	hl,(FACLO)	;2562
	ex	(sp),hl		;2565
	push	hl		;2566
	ex	de,hl		;2567
	call	GETBYT		;2568
	ex	de,hl		;256b
	ex	(sp),hl		;256c
	jr	FINGO		;256d
OKNORM:	call	PARCHK		;256f
	ex	(sp),hl		;2572
; ----------------------------------------------------------------------
	ld	a,l		;2573
	;2574 - Check to see if the operator token in Register A is one less than SQR - $0C
	cp	(TKSQR-ONEFUN)*2
	jr	c,NOTFRF	;2576 - Jump to avoid forcing the argument if is SGN to SQR
	;2578 - Check to see if the operator token in Register A is bigger than ATN() - $1B
	cp	(TKATN-ONEFUN)*2+1
	push	hl		;257a
	call	c,FRCSNG	;257b
	pop	hl		;257e
NOTFRF:	ld	de,LABBCK	;257f
	push	de		;2582
FINGO:	ld	bc,FUNDSP	;2583
DISPAT:	add	hl,bc		;2586
	ld	c,(hl)		;2587
	inc	hl		;2588
	ld	h,(hl)		;2589
	ld	l,c		;258a
	jp	(hl)		;258b
; ----------------------------------------------------------------------
; 258C – Part of the Formula Evaluation Code – “STRCMP”
;   this routine will compare two strings, one with the description in
;   Register DE and the other in FACLO/FACLO+1. On exit:
;     A = 0 if the strings are equal
;     A = 377 if BCDE > FACLO
;     A = 1 if BCDE < FACLO
; ----------------------------------------------------------------------
STRCMP:	call	FRESTR		;258c
	ld	a,(hl)		;258f
	inc	hl		;2590
	ld	c,(hl)		;2591
	inc	hl		;2592
	ld	b,(hl)		;2593
	pop	de		;2594
	push	bc		;2595
	push	af		;2596
	call	FRETMP		;2597
	pop	de		;259a
	ld	e,(hl)		;259b
	inc	hl		;259c
	ld	c,(hl)		;259d
	inc	hl		;259e
	ld	b,(hl)		;259f
	pop	hl		;25a0
; ----------------------------------------------------------------------
; 25A1 - Compare 2 strings in Memory
;   On entry HL must point to String 1, while BC must point to string 2
;   the D and E registers must point to the lengths of string 1 and 2.
;   On exit A register will 0, 1, FF, with Z and C flags set accordingly
; ----------------------------------------------------------------------
CSLOOP:	ld	a,e		;25a1
	or	d		;25a2
	ret	z		;25a3
	ld	a,d		;25a4
	sub	$01		;25a5
	ret	c		;25a7
	xor	a		;25a8
	cp	e		;25a9
	inc	a		;25aa
	ret	nc		;25ab
	dec	d		;25ac
	dec	e		;25ad
	ld	a,(bc)		;25ae
	cp	(hl)		;25af
	inc	hl		;25b0
	inc	bc		;25b1
	jr	z,CSLOOP	;25b2
	ccf			;25b4
	jp	SIGNS		;25b5
DOCMP:	inc	a		;25b8
	adc	a,a		;25b9
	pop	bc		;25ba
	and	b		;25bb
	add	a,$FF		;25bc
	sbc	a,a		;25be
	call	CONIA		;25bf
	jr	RETAPG		;25c2
; ----------------------------------------------------------------------
; 25C4 – NOT Routine – “NOTER”
; ----------------------------------------------------------------------
NOTER:	ld	d,$5A		;25c4
	call	LPOPER		;25c6
	call	FRCINT		;25c9
	ld	a,l		;25cc
	cpl			;25cd
	ld	l,a		;25ce
	ld	a,h		;25cf
	cpl			;25d0
	ld	h,a		;25d1
	ld	(FACLO),hl	;25d2
	pop	bc		;25d5
RETAPG:	jp	RETAOP		;25d6
;
; ======================================================================
; 25D9 – The RST 20H code – “GETYPR”
;
;   This is the TEST DATA MODE, which determines the type of the current
;   value in ACCumulator and returns a combination of STATUS flags and
;   unique numeric values in the A Register according to the data mode flag (40AFH).
;      TYPE   CODE   ZERO   CARRY   NEG   PARITY   A-Register
;      INT     02     NZ      C      N      E         -1
;      STR     03      Z      C      P      E          0
;      SNG     04     NZ      C      P      O          1
;      DBL     08     NZ     NC      P      E          5
; ----------------------------------------------------------------------
GETYPR:	ld	a,(VALTYP)	;25d9
	cp	VTDBL		;25dc - compare with Double Precision
	jr	nc,NCASE	;25de - If double precision
	sub	VTSTR		;25e0 - adjust -1=Int, 0=String, 1=Single
	or	a		;25e2 - Set the status flags of the adjusted number type flag
	scf			;25e3 - and Set Carry
	ret			;25e4
NCASE:	sub	VTSTR		;25e5 - If Double adjust = 5
	or	a		;25e7 - And set DBL Flags
	ret			;25e8
; ----------------------------------------------------------------------
; 25E9 – AND and OR Routines – “DANDOR”
;   this routine applies the AND
;   and OR operators and should be used to implement all logical operators
;   Whenever an operator is applied, its precedence is in Register B
;   This fact is used to distinguish between AND and OR
; ----------------------------------------------------------------------
DANDOR:	push	bc		;25e9
	call	FRCINT		;25ea
	pop	af		;25ed
	pop	de		;25ee
	ld	bc,GIVINT	;25ef
	push	bc		;25f2
	cp	$46		;25f3
	jr	nz,NOTOR	;25f5
; ----------------------------------------------------------------------
; 25F7 – OR logic.
; ----------------------------------------------------------------------
	ld	a,e		;25f7
	or	l		;25f8
	ld	l,a		;25f9
	ld	a,h		;25fa
	or	d		;25fb
	ret			;25fc
; ----------------------------------------------------------------------
; 25FD – AND logic – “NOTOR”
; ----------------------------------------------------------------------
NOTOR:	ld	a,e		;25fd
	and	l		;25fe
	ld	l,a		;25ff
	ld	a,h		;2600
	and	d		;2601
	ret			;2602
;
; ----------------------------------------------------------------------
; 2603 – Dimension and Variable Searching Routine – “DIMCON”
; ----------------------------------------------------------------------
DIMCON:	dec	hl		;2603
	GETCHR			;2604 - rst 10h
	ret	z		;2605
	SYNTAX	(',')		;2606 - rst 08h
;
; ----------------------------------------------------------------------
; 2608 – DIM logic – “DIM”
;   The original ROM source code states that this DIM code sets DIMFLG
;   and then falls into the variable search routine, which then looks
;   at DIMFLG at three different points:
; ----------------------------------------------------------------------
DIM:	ld	bc,DIMCON	;2608
	push	bc		;260b
;
	.DB	ORNN		;260c - Z80 Trick - OR nn - causes NZ flag - skip next instruction
;
; ----------------------------------------------------------------------
; 260D – LOCATE OR CREATE A BASIC VARIABLE
;   Variable location and creation logic – “PTRGET”
;   locate storage area for existing variable if not exists will create
;   On entry HL must point to first char of variable name
;   On exit HL will point to next char after var name
;   and DE will point to the address of the variable storage
; ----------------------------------------------------------------------
PTRGET:	xor	a		;260d
	ld	(DIMFLG),a	;260e
	ld	b,(hl)		;2611
	call	ISLET		;2612
	jp	c,SNERR		;2615
	xor	a		;2618
	ld	c,a		;2619
	GETCHR			;261a - rst 10h
	jr	c,ISSEC		;261b
	call	ISLET		;261d
	jr	c,NOSEC		;2620
ISSEC:	ld	c,a		;2622
EATEM:	GETCHR			;2623 - rst 10h
	jr	c,EATEM		;2624
	call	ISLET		;2626
	jr	nc,EATEM	;2629
NOSEC:	ld	de,HAVTYP	;262b
	push	de		;262e - Save return address HAVTYP to stack
	ld	d,VTINT		;262f - Integer Value Type
	cp	'%'		;2631 - % Integer data type
	ret	z		;2633
	inc	d		;2634 - String Value type
	cp	'$'		;2635 - $ String data type
	ret	z		;2637
	inc	d		;2638 - Single Precision Value type
	cp	'!'		;2639 - ! Single precision
	ret	z		;263b
	ld	d,VTDBL		;263c - double value type = 8
	cp	'#'		;263e - # Double data type
	ret	z		;2640
	ld	a,b		;2641 - first character of the variable name
	sub	'A'		;2642 - Adjust so that it is 0 to 25 for a table offset
	and	$7F		;2644 - Get rid of the user-defined function bit
	ld	e,a		;2646
	ld	d,$00		;2647 - DE now contains the table offset
	push	hl		;2649
	ld	hl,DEFTBL	;264a - address of the variable declaration table.
	add	hl,de		;264d - Add the offset to the top of the table
	ld	d,(hl)		;264e - the number type from the variable declaration table
	pop	hl		;264f
	dec	hl		;2650
	ret			;2651
HAVTYP:	ld	a,d		;2652 - the number type
	ld	(VALTYP),a	;2653 - save the num type flag
	GETCHR			;2656 - rst 10h
	ld	a,(SUBFLG)	;2657
	or	a		;265a
	jp	nz,NOARYS	;265b
	ld	a,(hl)		;265e
	sub	'('		;265f - '(' - test for an array
	jp	z,ISARY		;2661
NOARYS:	xor	a		;2664
	ld	(SUBFLG),a	;2665
	push	hl		;2668
	push	de		;2669
	ld	hl,(VARTAB)	;266a
LOPFND:	ex	de,hl		;266d
	ld	hl,(ARYTAB)	;266e
	CPDEHL			;2671
	pop	hl		;2672
	jr	z,NOTFNS	;2673
	ld	a,(de)		;2675
	ld	l,a		;2676
	cp	h		;2677
	inc	de		;2678
	jr	nz,NOTIT1	;2679
	ld	a,(de)		;267b
	cp	c		;267c
	jr	nz,NOTIT1	;267d
	inc	de		;267f
	ld	a,(de)		;2680
	cp	b		;2681
	jp	z,FINPTR	;2682
;
	.DB	LDANN		;2685 - Z80 Trick - LD a,nn - and skip next byte
;
NOTIT1:	inc	de		;2686
	inc	de		;2687
	push	hl		;2688
	ld	h,$00		;2689
	add	hl,de		;268b
	jr	LOPFND		;268c
NOTFNS:	ld	a,h		;268e
	pop	hl		;268f
	ex	(sp),hl		;2690
	push	af		;2691
	push	de		;2692
	ld	de,VARRET	;2693
	CPDEHL			;2696
	jr	z,VARNOT	;2697
	ld	de,RETVAR	;2699
	CPDEHL			;269c
	pop	de		;269d
	jr	z,FINZER	;269e
	pop	af		;26a0
	ex	(sp),hl		;26a1
	push	hl		;26a2
	push	bc		;26a3
	ld	c,a		;26a4
	ld	b,$00		;26a5
	push	bc		;26a7
	inc	bc		;26a8
	inc	bc		;26a9
	inc	bc		;26aa
	ld	hl,(STREND)	;26ab
	push	hl		;26ae
	add	hl,bc		;26af
	pop	bc		;26b0
	push	hl		;26b1
	call	BLTU		;26b2
	pop	hl		;26b5
	ld	(STREND),hl	;26b6
	ld	h,b		;26b9
	ld	l,c		;26ba
	ld	(ARYTAB),hl	;26bb
ZEROER:	dec	hl		;26be
	ld	(hl),$00	;26bf
	CPDEHL			;26c1
	jr	nz,ZEROER	;26c2
	pop	de		;26c4
	ld	(hl),e		;26c5
	inc	hl		;26c6
	pop	de		;26c7
	ld	(hl),e		;26c8
	inc	hl		;26c9
	ld	(hl),d		;26ca
	ex	de,hl		;26cb
FINPTR:	inc	de		;26cc
	pop	hl		;26cd
	ret			;26ce
VARNOT:	ld	d,a		;26cf
	ld	e,a		;26d0
	pop	af		;26d1
	pop	af		;26d2
	ex	(sp),hl		;26d3
	ret			;26d4
;
; ----------------------------------------------------------------------
; 26D5 – This routine is ZERO out all variable types and skip any RETurn – “FINZER”
; ----------------------------------------------------------------------
FINZER:	ld	(FAC),a		;26d5
	pop	bc		;26d8
	ld	h,a		;26d9
	ld	l,a		;26da
	ld	(FACLO),hl	;26db
	TSTDAT			;26de
	jr	nz,POPHR2	;26df
	ld	hl,m_REDDY-1	;26e1
	ld	(FACLO),hl	;26e4
POPHR2:	pop	hl		;26e7
	ret			;26e8
; ----------------------------------------------------------------------
; 26E9 – This routine handles a subscripted variables – “ISARY”
;   On entry D = the type of variable, B = the 1st character of the variable name,
;   C = the 2nd character of the variable name, and HL = the current position
;   in the input string.
; ----------------------------------------------------------------------
ISARY:	push	hl		;26e9
	ld	hl,(DIMFLG)	;26ea
	ex	(sp),hl		;26ed
	ld	d,a		;26ee
INDLOP:	push	de		;26ef
	push	bc		;26f0
	call	INTIDX		;26f1
	pop	bc		;26f4
	pop	af		;26f5
	ex	de,hl		;26f6
	ex	(sp),hl		;26f7
	push	hl		;26f8
	ex	de,hl		;26f9
	inc	a		;26fa
	ld	d,a		;26fb
	ld	a,(hl)		;26fc
	cp	','		;26fd
	jr	z,INDLOP	;26ff
	SYNTAX	(')')		;2701 - rst 08h
	ld	(TEMP2),hl	;2703
	pop	hl		;2706
	ld	(DIMFLG),hl	;2707
	push	de		;270a
	ld	hl,(ARYTAB)	;270b
;
	.DB	LDANN		;270d - Z80 Trick - LD A,nn - skipping next byte
;
LOPFDA:	add	hl,de		;270f
	ex	de,hl		;2710
	ld	hl,(STREND)	;2711
	ex	de,hl		;2714
	CPDEHL			;2715
	ld	a,(VALTYP)	;2716
	jr	z,NOTFDD	;2719
	cp	(hl)		;271b
	inc	hl		;271c
	jr	nz,NMARY2	;271d
	ld	a,(hl)		;271f
	cp	c		;2720
	inc	hl		;2721
	jr	nz,NMARY1	;2722
	ld	a,(hl)		;2724
	cp	b		;2725
;
	.DB	LDANN		;2726 - Z80 Trick - LD A,nn - skipping next byte
;
NMARY2:	inc	hl		;2727
NMARY1:	inc	hl		;2728
	ld	e,(hl)		;2729
	inc	hl		;272a
	ld	d,(hl)		;272b
	inc	hl		;272c
	jr	nz,LOPFDA	;272d
	ld	a,(DIMFLG)	;272f
	or	a		;2732
	ld	e,ERRDD		;2733
	jp	nz,ERROR	;2735
	pop	af		;2738
	sub	(hl)		;2739
	jp	z,GETDEF	;273a
; ----------------------------------------------------------------------
; 273DH – ?BS ERROR ENTRY POINT – “BSERR”
; ----------------------------------------------------------------------
BSERR:	ld	e,ERRBS		;273d
	jp	ERROR		;273f
; ----------------------------------------------------------------------
; 2742 – Part of the ARRAY routines. – “NOTFDD”
;   Jumped here when a variable isn’t found in the ARRAY table
; -----------------------------------------------------------------------
NOTFDD:	ld	(hl),a		;2742
	inc	hl		;2743
	ld	e,a		;2744
	ld	d,$00		;2745
	pop	af		;2747
	ld	(hl),c		;2748
	inc	hl		;2749
	ld	(hl),b		;274a
	inc	hl		;274b
	ld	c,a		;274c
	call	GETSTK		;274d
	inc	hl		;2750
	inc	hl		;2751
	ld	(TEMP3),hl	;2752
	ld	(hl),c		;2755
	inc	hl		;2756
	ld	a,(DIMFLG)	;2757
	rla			;275a
	ld	a,c		;275b
LOPPTA:	ld	bc,$000B	;275c - Top of a loop assuming we did not get here from "DIM". Load BC with the default number of 11, which is the most entries an array can have without a DIM
	jr	nc,NOTDIM	;275f
	pop	bc		;2761
	inc	bc		;2762
NOTDIM:	ld	(hl),c		;2763
	inc	hl		;2764
	ld	(hl),b		;2765
	inc	hl		;2766
	push	af		;2767
	call	UMULT		;2768
	pop	af		;276b
	dec	a		;276c
	jr	nz,LOPPTA	;276d
	push	af		;276f
	ld	b,d		;2770
	ld	c,e		;2771
	ex	de,hl		;2772
	add	hl,de		;2773
	jr	c,BSERR		;2774
	call	REASON		;2776
	ld	(STREND),hl	;2779
ZERITA:	dec	hl		;277c
	ld	(hl),$00	;277d
	CPDEHL			;277f
	jr	nz,ZERITA	;2780
	inc	bc		;2782
	ld	d,a		;2783
	ld	hl,(TEMP3)	;2784
	ld	e,(hl)		;2787
	ex	de,hl		;2788
	add	hl,hl		;2789
	add	hl,bc		;278a
	ex	de,hl		;278b
	dec	hl		;278c
	dec	hl		;278d
	ld	(hl),e		;278e
	inc	hl		;278f
	ld	(hl),d		;2790
	inc	hl		;2791
	pop	af		;2792
	jr	c,FINNOW	;2793
; -----------------------------------------------------------------------
; At this point, HL points beyond the SIZE of the array
; to the NUMBER OF DIMENSIONS in the array.
; -----------------------------------------------------------------------
GETDEF:	ld	b,a		;2795
	ld	c,a		;2796
	ld	a,(hl)		;2797
	inc	hl		;2798
;
	.DB	LDDNN		;2799 - Z80 Trick - LD D,nn - skipping next byte
;
INLPNM:	pop	hl		;279a
	ld	e,(hl)		;279b
	inc	hl		;279c
	ld	d,(hl)		;279d
	inc	hl		;279e
	ex	(sp),hl		;279f
	push	af		;27a0
	CPDEHL			;27a1
	jp	nc,BSERR	;27a2
	call	UMULT		;27a5
	add	hl,de		;27a8
	pop	af		;27a9
	dec	a		;27aa
	ld	b,h		;27ab
	ld	c,l		;27ac
	jr	nz,INLPNM	;27ad
	ld	a,(VALTYP)	;27af
	ld	b,h		;27b2
	ld	c,l		;27b3
	add	hl,hl		;27b4
	sub	VTSNG		;27b5 - Compare with Single Precision
	jr	c,DMLVAL	;27b7 - If it is an Integer or String
	add	hl,hl		;27b9
	jr	z,DONMUL	;27ba
	add	hl,hl		;27bc
DMLVAL:	or	a		;27bd
	jp	po,DONMUL	;27be
	add	hl,bc		;27c1
DONMUL:	pop	bc		;27c2
	add	hl,bc		;27c3
	ex	de,hl		;27c4
FINNOW:	ld	hl,(TEMP2)	;27c5
	ret			;27c8
; ----------------------------------------------------------------------
; 27C9-27D3 – LEVEL II BASIC MEM ROUTINE – “MEM”
;   This is the RETURN AMOUNT OF FREE MEMORY routine at 27C9H which computes
;   the amount of memory remaining between the end of the variable list
;   and the end of the STACK and puts the result in ACCumulator
;   as a SINGLE PRECISION number.
; ----------------------------------------------------------------------
MEM:	xor	a		;27c9
	push	hl		;27ca
	ld	(VALTYP),a	;27cb
	call	FNFRE		;27ce
	pop	hl		;27d1
	GETCHR			;27d2 - rst 10h
	ret			;27d3
; ----------------------------------------------------------------------
; 27D4-27F4 – LEVEL II BASIC FRE ROUTINE – “FNFRE”
; ----------------------------------------------------------------------
FNFRE:	ld	hl,(STREND)	;27d4
	ex	de,hl		;27d7
	ld	hl,$0000	;27d8
	add	hl,sp		;27db
	TSTDAT			;27dc
	jr	nz,GIVDBL	;27dd
; ----------------------------------------------------------------------
; 27DF - Get number of bytes free string space to ACCUM (TAS)
; ----------------------------------------------------------------------
	call	FREFAC		;27df
	call	GARBA2		;27e2
	ld	hl,(STKTOP)	;27e5
	ex	de,hl		;27e8
	ld	hl,(FRETOP)	;27e9
GIVDBL:	ld	a,l		;27ec
	sub	e		;27ed
	ld	l,a		;27ee
	ld	a,h		;27ef
	sbc	a,d		;27f0
	ld	h,a		;27f1
	jp	INEG2		;27f2
; ----------------------------------------------------------------------
; 27F5-27FD – LEVEL II BASIC POS() ROUTINE – “FNPOS”
; ----------------------------------------------------------------------
FNPOS:
	ld	a,(TTYPOS)	;27f5 - Load A with the current cursor line position.
SNGFLT:	ld	l,a		;27f8 - Load Value into L
	xor	a		;27f9 - Zero A
GIVINT:	ld	h,a		;27fa - HL now contains the Value
	jp	MAKINT		;27fb - Convert the value to an unsigned Int
; ----------------------------------------------------------------------
; 27FE-2818 – LEVEL II BASIC USR(x) ROUTINE – “USRFN”
; ----------------------------------------------------------------------
USRFN:	call	USROUT		;27fe - dos usr n handling
	GETCHR			;2801 - rst 10h
	call	PARCHK		;2802
	push	hl		;2805
	ld	hl,POPHRT	;2806
	push	hl		;2809
	ld	a,(VALTYP)	;280a
	push	af		;280d
	cp	VTSTR		;280e - Compare value type - is it a String
	call	z,FREFAC	;2810
	pop	af		;2813
	ex	de,hl		;2814
	ld	hl,(USRTAB)	;2815
	jp	(hl)		;2818
; ----------------------------------------------------------------------
; 2819-2827 – MATH CONVERSION ROUTINE– “DOCNVF”
;   Usually called by LET to convert the result of arithmetic
;   routines to the proper destination type.
; ----------------------------------------------------------------------
DOCNVF:	push	hl		;2819
	and	$07		;281a
	ld	hl,FRCTBL	;281c - Operation Converation Table
	ld	c,a		;281f
	ld	b,$00		;2820
	add	hl,bc		;2822
	call	DISPAT		;2823
	pop	hl		;2826
	ret			;2827
; ----------------------------------------------------------------------
; 2828-2835 – Routine to see if we are in DIRECT MODE and ERROR OUT if so – “ERRDIR”
;   Usually called from the INPUT routine. On entry HL has the current line number in binary.
; ----------------------------------------------------------------------
ERRDIR:	push	hl		;2828
	ld	hl,(CURLIN)	;2829
	inc	hl		;282c
	ld	a,h		;282d
	or	l		;282e
	pop	hl		;282f
	ret	nz		;2830
; ----------------------------------------------------------------------
; 2831H – ID? ERROR ENTRY POINT - "IDERR"
; ----------------------------------------------------------------------
IDERR:	ld	e,ERRID		;2831
	jp	ERROR		;2833
; ----------------------------------------------------------------------
; 2836-2856 – STRING ROUTINE – STR$ logic– “FNSTR”
;   Convert number in ACCUM to string.
;   On entry, the number to be converted to a string must be in the ACCUM
;   with the NTF set appropriately. PUSH the return address onto the
;   stack, PUSH HL, and BC (HL and BC are restored on exit from the
;   routine) . Then jump to 2836H (don't CALL).
;   On exit the VARPTR to the string created by this routine will be
;   found in the ACCUM, with the NTF set to 3
; ----------------------------------------------------------------------
FNSTR:	call	FOUT		;2836
	call	STRLIT		;2839
	call	FREFAC		;283c
	ld	bc,FINBCK	;283f
	push	bc		;2842
; ----------------------------------------------------------------------
; The next routine, STRCPY, creates a copy of the string pointed to by
; Reg Pair HL. On exit, DE points to DSCTMP which has the string info.
; ----------------------------------------------------------------------
STRCPY:	ld	a,(hl)		;2843
	inc	hl		;2844
	push	hl		;2845
	call	GETSPA		;2846
	pop	hl		;2849
	ld	c,(hl)		;284a
	inc	hl		;284b
	ld	b,(hl)		;284c
	call	STRAD2		;284d
	push	hl		;2850
	ld	l,a		;2851
	call	MOVSTR		;2852
	pop	de		;2855
	ret			;2856
; ----------------------------------------------------------------------
; 2857-2864 – STRING ROUTINE– “STRINI”
; ----------------------------------------------------------------------
STRINI:	call	GETSPA		;2857
STRAD2:	ld	hl,DSCTMP	;285a
	push	hl		;285d
	ld	(hl),a		;285e
	inc	hl		;285f
	ld	(hl),e		;2860
	inc	hl		;2861
	ld	(hl),d		;2862
	pop	hl		;2863
	ret			;2864
; ----------------------------------------------------------------------
; 2865-28A5 – STRING ROUTINE– “STRLIT”
;   STRLT2 takes the string literal whose first character is pointed by HL+1
;   and builds a descriptor for it. Leading quotes should be skipped before
;   the CALL to this routine.
; ----------------------------------------------------------------------
STRLIT:	dec	hl		;2865
STRLTI:	ld	b,DQUOTE	;2866
	ld	d,b		;2868
STRLT2:	push	hl		;2869
	ld	c,$FF		;286a
STRGET:	inc	hl		;286c
	ld	a,(hl)		;286d
	inc	c		;286e
	or	a		;286f
	jr	z,STRFIN	;2870
	cp	d		;2872
	jr	z,STRFIN	;2873
	cp	b		;2875
	jr	nz,STRGET	;2876
STRFIN:	cp	DQUOTE		;2878
	call	z,CHRGTR	;287a
	ex	(sp),hl		;287d
	inc	hl		;287e
	ex	de,hl		;287f
	ld	a,c		;2880
	call	STRAD2		;2881
PUTNEW:	ld	de,DSCTMP	;2884
;
       	.DB	LDANN		;2887 - Z80 Trick LD A,nn - skip next instruction - load it into A
;
; ----------------------------------------------------------------------
; PUTTMP - A JUMP point in DOS Basic to process a new string in the
; DEF FN routine. When JUMPed to 2888H, a PUSH DE is processed
; ----------------------------------------------------------------------
PUTTMP:
	push	de		;2888 - Save a pointer to the stat of the string to the STACK
;
	ld	hl,(TEMPPT)	;2889
	ld	(FACLO),hl	;288c
	ld	a,VTSTR		;288f - value type String
	ld	(VALTYP),a	;2891
	call	VMOVE		;2894
	ld	de,FRETOP	;2897
	CPDEHL			;289a
	ld	(TEMPPT),hl	;289b
	pop	hl		;289e
	ld	a,(hl)		;289f
	ret	nz		;28a0
; ----------------------------------------------------------------------
; 28A1H – ST? ERROR ENTRY POINT - "STERR"
; ----------------------------------------------------------------------
STERR:	ld	e,ERRST		;28a1
	jp	ERROR		;28a3
;
; ----------------------------------------------------------------------
; 28A6-28BE – DISPLAY MESSAGE ROUTINE– “STROUI”
;
;   this routine will print the string pointed to by Register Pair HL.
;   The string MUST be terminated by a 00H. If the string exists below DSCTMP,
;   then it is copied into string space first.
;
;   this routine will print the string
;   pointed to by Register Pair HL. The string MUST be terminated by a 00H.
;   If the string exists below DSCTMP, then it is copied into string space first.
; ----------------------------------------------------------------------
;
STROUI:	inc	hl		;28a6
;
STROUT:	call	STRLIT		;28a7
;
STRPRT:	call	FREFAC		;28aa
	call	GETBCD		;28ad
	inc	d		;28b0
STRPR2:	dec	d		;28b1
	ret	z		;28b2
	ld	a,(bc)		;28b3
	call	OUTDO		;28b4
	cp	ENTER		;28b7
	call	z,CRFIN		;28b9
	inc	bc		;28bc
	jr	STRPR2		;28bd
;
; ----------------------------------------------------------------------
; 28BF-28D9 – STRING ROUTINE– “GETSPA”
; ----------------------------------------------------------------------
GETSPA:	or	a		;28bf
;
	.DB	LDCNN		;28c0 - Z80 Trick - LD C,nn - skipping next byte
;
TRYGI2:	pop	af		;28c1
	push	af		;28c2
	ld	hl,(STKTOP)	;28c3
	ex	de,hl		;28c6
	ld	hl,(FRETOP)	;28c7
	cpl			;28ca
	ld	c,a		;28cb
	ld	b,$FF		;28cc
	add	hl,bc		;28ce
	inc	hl		;28cf
	CPDEHL			;28d0
	jr	c,GARBAG	;28d1
	ld	(FRETOP),hl	;28d3
	inc	hl		;28d6
	ex	de,hl		;28d7
PPSWRT:	pop	af		;28d8
	ret			;28d9
; ----------------------------------------------------------------------
; 28DA-298E – STRING ROUTINE – “GARBAG”
; ----------------------------------------------------------------------
GARBAG:	pop	af		;28da
	ld	e,ERROS		;28db
	jp	z,ERROR		;28dd
	cp	a		;28e0
	push	af		;28e1
	ld	bc,TRYGI2	;28e2 - push address
	push	bc		;28e5
GARBA2:	ld	hl,(MEMSIZ)	;28e6
FNVVAR:	ld	(FRETOP),hl	;28e9
	ld	hl,$0000	;28ec
	push	hl		;28ef
	ld	hl,(STKTOP)	;28f0
	push	hl		;28f3
	ld	hl,TEMPST	;28f4
TVAR:	ex	de,hl		;28f7
	ld	hl,(TEMPPT)	;28f8
	ex	de,hl		;28fb
	CPDEHL			;28fc
	ld	bc,TVAR		;28fd
	jp	nz,DVAR2	;2900
	ld	hl,(VARTAB)	;2903
SVAR:	ex	de,hl		;2906
	ld	hl,(ARYTAB)	;2907
	ex	de,hl		;290a
	CPDEHL			;290b
	jr	z,ARYVAR	;290c
	ld	a,(hl)		;290e
	inc	hl		;290f
	inc	hl		;2910
	inc	hl		;2911
	cp	$03		;2912
	jr	nz,SKPVAR	;2914
	call	DVAR		;2916
	xor	a		;2919
SKPVAR:	ld	e,a		;291a
	ld	d,$00		;291b
	add	hl,de		;291d
	jr	SVAR		;291e
ARYVA2:	pop	bc		;2920
ARYVAR:	ex	de,hl		;2921
	ld	hl,(STREND)	;2922
	ex	de,hl		;2925
	CPDEHL			;2926
	jp	z,GRBPAS	;2927
	ld	a,(hl)		;292a
	inc	hl		;292b
	call	MOVRM		;292c
	push	hl		;292f
	add	hl,bc		;2930
	cp	$03		;2931
	jr	nz,ARYVA2	;2933
	ld	(TEMP3),hl	;2935
	pop	hl		;2938
	ld	c,(hl)		;2939 - Load C with num of subscripts for the array HL pointer
	ld	b,$00		;293a - Zero B so that BC holds the number of dimensions
	add	hl,bc		;293c
	add	hl,bc		;293d
	inc	hl		;293e
ARYSTR:	ex	de,hl		;293f
	ld	hl,(TEMP3)	;2940
	ex	de,hl		;2943
	CPDEHL			;2944
	jr	z,ARYVAR	;2945
	ld	bc,ARYSTR	;2947
DVAR2:	push	bc		;294a
DVAR:	xor	a		;294b
	or	(hl)		;294c
	inc	hl		;294d
	ld	e,(hl)		;294e
	inc	hl		;294f
	ld	d,(hl)		;2950
	inc	hl		;2951
	ret	z		;2952
	ld	b,h		;2953
	ld	c,l		;2954
	ld	hl,(FRETOP)	;2955
	CPDEHL			;2958
	ld	h,b		;2959
	ld	l,c		;295a
	ret	c		;295b
	pop	hl		;295c
	ex	(sp),hl		;295d
	CPDEHL			;295e
	ex	(sp),hl		;295f
	push	hl		;2960
	ld	h,b		;2961
	ld	l,c		;2962
	ret	nc		;2963
	pop	bc		;2964
	pop	af		;2965
	pop	af		;2966
	push	hl		;2967
	push	de		;2968
	push	bc		;2969
	ret			;296a
;
GRBPAS:	pop	de		;296b
	pop	hl		;296c
	ld	a,l		;296d
	or	h		;296e
	ret	z		;296f
	dec	hl		;2970
	ld	b,(hl)		;2971
	dec	hl		;2972
	ld	c,(hl)		;2973
	push	hl		;2974
	dec	hl		;2975
	ld	l,(hl)		;2976
	ld	h,$00		;2977
	add	hl,bc		;2979
	ld	d,b		;297a
	ld	e,c		;297b
	dec	hl		;297c
	ld	b,h		;297d
	ld	c,l		;297e
	ld	hl,(FRETOP)	;297f
	call	BLTUC		;2982
	pop	hl		;2985
	ld	(hl),c		;2986
	inc	hl		;2987
	ld	(hl),b		;2988
	ld	l,c		;2989
	ld	h,b		;298a
	dec	hl		;298b
	jp	FNVVAR		;298c
; ----------------------------------------------------------------------
; 298F-29C5 – STRING ADDITION ROUTINE – Concatenate two strings – “CAT”
; ----------------------------------------------------------------------
CAT:	push	bc		;298f
	push	hl		;2990
	ld	hl,(FACLO)	;2991
	ex	(sp),hl		;2994
	call	EVAL		;2995
	ex	(sp),hl		;2998
	call	CHKSTR		;2999
; ----------------------------------------------------------------------
; 299C - Concatenate 2 Strings (TAS)
;   On entry, the stack must be prepared as follows.
;   PUSH the return address on the stack, PUSH BC and HL
;   (BC and HL will be restored on exit from the routine).
;   The HL register must contain the VARPTR for string number 1, and
;   the ACCUM must contain the VARPTR for string number 2 (NTF must
;   contain the value of 3). Then jump to 299CH (don't CALL).
;   On exit, the VARPTR to the string created by this routine
;   will be found in the ACCUM, with the NTF set to 3.
; ----------------------------------------------------------------------
	ld	a,(hl)		;299c
	push	hl		;299d
	ld	hl,(FACLO)	;299e
	push	hl		;29a1
	add	a,(hl)		;29a2
	ld	e,ERRLS		;29a3
	jp	c,ERROR		;29a5
	call	STRINI		;29a8
	pop	de		;29ab
	call	FRETMP		;29ac
	ex	(sp),hl		;29af
	call	FRETM2		;29b0
	push	hl		;29b3
	ld	hl,(DSCTMP+1)	;29b4
	ex	de,hl		;29b7
	call	MOVINS		;29b8
	call	MOVINS		;29bb
	ld	hl,TSTOP	;29be
	ex	(sp),hl		;29c1
	push	hl		;29c2
	jp	PUTNEW		;29c3
; ----------------------------------------------------------------------
; 29C6 – STRING ROUTINE – This will move strings using the STACK – “MOVINS”
; ----------------------------------------------------------------------
MOVINS:	pop	hl		;29c6
	ex	(sp),hl		;29c7
; ----------------------------------------------------------------------
; 29C8-29D6 – STRING ROUTINE - This will move string using registers - 'MOVREG'
;   On entry HL points to the string control block for the string to be moved,
;   and DE contains the destination address. All registers are used.
;   The string length and address are not moved. String control blocks
;   have the format: X=String Length; ADDR = String Address.
; ----------------------------------------------------------------------
MOVREG:	ld	a,(hl)		;29c8
	inc	hl		;29c9
	ld	c,(hl)		;29ca
	inc	hl		;29cb
	ld	b,(hl)		;29cc
	ld	l,a		;29cd
MOVSTR:	inc	l		;29ce
MOVLP:	dec	l		;29cf
	ret	z		;29d0
	ld	a,(bc)		;29d1
	ld	(de),a		;29d2
	inc	bc		;29d3
	inc	de		;29d4
	jr	MOVLP		;29d5
; ----------------------------------------------------------------------
; 29D7-29F4 – STRING ROUTINE – “FRESTR”
;
;   This routine makes the HL register pair point to the first
;   of the three bytes containing string length followed by the string address
; ----------------------------------------------------------------------
FRESTR:	call	CHKSTR		;29d7
FREFAC:	ld	hl,(FACLO)	;29da
FRETM2:	ex	de,hl		;29dd
;
;   FRETMP is passed a pointer to a string descriptor in Register Pair DE
;   and is returned in Register Pair HL. All the other registers are modified.
;
FRETMP:	call	FRETMS		;29de
	ex	de,hl		;29e1
	ret	nz		;29e2
	push	de		;29e3
	ld	d,b		;29e4
	ld	e,c		;29e5
	dec	de		;29e6
	ld	c,(hl)		;29e7
	ld	hl,(FRETOP)	;29e8
	CPDEHL			;29eb
	jr	nz,NOTLST	;29ec
	ld	b,a		;29ee
	add	hl,bc		;29ef
	ld	(FRETOP),hl	;29f0
NOTLST:	pop	hl		;29f3
	ret			;29f4
; ----------------------------------------------------------------------
; ----------------------------------------------------------------------
FRETMS:	ld	hl,(TEMPPT)	;29f5
	dec	hl		;29f8
	ld	b,(hl)		;29f9
	dec	hl		;29fa
	ld	c,(hl)		;29fb
	dec	hl		;29fc
	CPDEHL			;29fd
	ret	nz		;29fe
	ld	(TEMPPT),hl	;29ff
	ret			;2a02
; ----------------------------------------------------------------------
; 2A03-2A0E – LEVEL II BASIC LEN ROUTINE– “FNLEN”
;   Get length (number of bytes) of a string to ACCUM
; ----------------------------------------------------------------------
FNLEN:	ld	bc,SNGFLT	;2a03
	push	bc		;2a06
LEN1:	call	FRESTR		;2a07
	xor	a		;2a0a
	ld	d,a		;2a0b
	ld	a,(hl)		;2a0c
	or	a		;2a0d
	ret			;2a0e
; ----------------------------------------------------------------------
; 2A0F-2A1E – LEVEL II BASIC ASC ROUTINE – “FNASC”
;   Get ASCII value of first character of string to ACCUM
; ----------------------------------------------------------------------
FNASC:	ld	bc,SNGFLT	;2a0f
	push	bc		;2a12
ASC2:	call	LEN1		;2a13
	jp	z,FCERR		;2a16
	inc	hl		;2a19
	ld	e,(hl)		;2a1a
	inc	hl		;2a1b
	ld	d,(hl)		;2a1c
	ld	a,(de)		;2a1d
	ret			;2a1e
; ----------------------------------------------------------------------
; 2A1F-2A2E – LEVEL II BASIC CHR$ ROUTINE – “FNCHR”
;   Make a one - character string - ASCII value in ACCUM
; ----------------------------------------------------------------------
FNCHR:	ld	a,$01		;2a1f
	call	STRINI		;2a21
	call	CONINT		;2a24
	ld	hl,(DSCTMP+1)	;2a27
	ld	(hl),e		;2a2a
FINBCK:	pop	bc		;2a2b
	jp	PUTNEW		;2a2c
; ----------------------------------------------------------------------
; 2A2F-2A60 – LEVEL II BASIC STRING$ ROUTINE – “STRNGS”
; ----------------------------------------------------------------------
STRNGS:	GETCHR			;2a2f - rst 10h
	SYNTAX	('(')		;2a30 - rst 08h
	call	GETBYT		;2a32
	push	de		;2a35
	SYNTAX	(',')		;2a36 - rst 08h
	call	FRMEVL		;2a38
	SYNTAX	(')')		;2a3b - rst 08h
; ----------------------------------------------------------------------
; 2A3D - Make a string of multiple bytes of one character (TAS)
; ----------------------------------------------------------------------
	ex	(sp),hl		;2a3d
	push	hl		;2a3e
	TSTDAT			;2a3f
	jr	z,STRSTR	;2a40
	call	CONINT		;2a42
	jr	CALSPA		;2a45
STRSTR:	call	ASC2		;2a47
CALSPA:	pop	de		;2a4a
	push	af		;2a4b
	push	af		;2a4c
	ld	a,e		;2a4d
	call	STRINI		;2a4e
	ld	e,a		;2a51
	pop	af		;2a52
	inc	e		;2a53
	dec	e		;2a54
	jr	z,FINBCK	;2a55
	ld	hl,(DSCTMP+1)	;2a57
SPLPS:	ld	(hl),a		;2a5a
	inc	hl		;2a5b
	dec	e		;2a5c
	jr	nz,SPLPS	;2a5d
	jr	FINBCK		;2a5f
; ----------------------------------------------------------------------
; 2A61-2A90 – LEVEL II BASIC LEFT$( ROUTINE – “FNLEFT”
; ----------------------------------------------------------------------
FNLEFT:	call	PREAM		;2a61
; ----------------------------------------------------------------------
; 2A64 - Make a string of the leftmost n characters of string (TAS)
; ----------------------------------------------------------------------
	xor	a		;2a64
LEFT3:	ex	(sp),hl		;2a65
	ld	c,a		;2a66
;
	.DB	LDANN		;2a67 - Z80 Trick - LD A,nn - skip next byte
;
LEFTUS:	push	hl		;2a68
LEFT2:	push	hl		;2a69
	ld	a,(hl)		;2a6a
	cp	b		;2a6b
	jr	c,ALLSTR	;2a6c
	ld	a,b		;2a6e
;
	.DB	LDDENN		;2a6f - Z80 Trick - LD DE,nnnn - skip next 2 bytes
;
ALLSTR:	ld	c,$00		;2a70
	push	bc		;2a72
	call	GETSPA		;2a73
	pop	bc		;2a76
	pop	hl		;2a77
	push	hl		;2a78
	inc	hl		;2a79
	ld	b,(hl)		;2a7a
	inc	hl		;2a7b
	ld	h,(hl)		;2a7c
	ld	l,b		;2a7d
	ld	b,$00		;2a7e
	add	hl,bc		;2a80
	ld	b,h		;2a81
	ld	c,l		;2a82
	call	STRAD2		;2a83
	ld	l,a		;2a86
	call	MOVSTR		;2a87
	pop	de		;2a8a
	call	FRETMP		;2a8b
	jp	PUTNEW		;2a8e
; ----------------------------------------------------------------------
; 2A91-2A99 – LEVEL II BASIC RIGHT$ ROUTINE – “FNRGT”
; ----------------------------------------------------------------------
FNRGT:	call	PREAM		;2a91
; ----------------------------------------------------------------------
; 2A94 - Make a string of the rightmost n characters of string (TAS)
; ----------------------------------------------------------------------
	pop	de		;2a94
	push	de		;2a95
	ld	a,(de)		;2a96
	sub	b		;2a97
	jr	LEFT3		;2a98
; ----------------------------------------------------------------------
; 2A9A-2AC4 – LEVEL II BASIC MID$ ROUTINE – “FNMID”
; ----------------------------------------------------------------------
FNMID:	ex	de,hl		;2a9a
	ld	a,(hl)		;2a9b
	call	PREAM2		;2a9c
	inc	b		;2a9f
	dec	b		;2aa0
	jp	z,FCERR		;2aa1
	push	bc		;2aa4
	ld	e,$FF		;2aa5
	cp	')'		;2aa7
	jr	z,MID2		;2aa9
	SYNTAX	(',')		;2aab - rst 08h
	call	GETBYT		;2aad
MID2:	SYNTAX	(')')		;2ab0 - rst 08h
	pop	af		;2ab2
; ----------------------------------------------------------------------
; 2AB3 - Make a string from a portion of another string (TAS)
; ----------------------------------------------------------------------
	ex	(sp),hl		;2ab3
	ld	bc,LEFT2	;2ab4
	push	bc		;2ab7
	dec	a		;2ab8
	cp	(hl)		;2ab9
	ld	b,$00		;2aba
	ret	nc		;2abc
	ld	c,a		;2abd
	ld	a,(hl)		;2abe
	sub	c		;2abf
	cp	e		;2ac0
	ld	b,a		;2ac1
	ret	c		;2ac2
	ld	b,e		;2ac3
	ret			;2ac4
; ----------------------------------------------------------------------
; 2AC5-2ADE – LEVEL II BASIC VAL ROUTINE – “FNVAL”
; ----------------------------------------------------------------------
FNVAL:	call	LEN1		;2ac5
	jp	z,SNGFLT	;2ac8
	ld	e,a		;2acb
	inc	hl		;2acc
	ld	a,(hl)		;2acd
	inc	hl		;2ace
	ld	h,(hl)		;2acf
	ld	l,a		;2ad0
	push	hl		;2ad1
	add	hl,de		;2ad2
	ld	b,(hl)		;2ad3
	ld	(hl),d		;2ad4
	ex	(sp),hl		;2ad5
	push	bc		;2ad6
	ld	a,(hl)		;2ad7
	call	FINDBL		;2ad8
	pop	bc		;2adb
	pop	hl		;2adc
	ld	(hl),b		;2add
	ret			;2ade
; ----------------------------------------------------------------------
; 2ADF-2A6 – STRING ROUTINE – “PREAM”
;   This is called by LEFT$, MID$, and RIGHT$ to test for the ending “)”
;   character. On entry, the STACK has the string address, byte count,
;   and return address. On exit the STACK has the string address,
;   DE and B each have the byte count.
; ----------------------------------------------------------------------
PREAM:	ex	de,hl		;2adf
	SYNTAX	(')')		;2ae0 - rst 08h
PREAM2:	pop	bc		;2ae2
	pop	de		;2ae3
	push	bc		;2ae4
	ld	b,e		;2ae5
	ret			;2ae6
; ----------------------------------------------------------------------
; 2AE7H-2AEE – Process a LEFT-HAND-SIDE MID$– “ISMID$”
;
; This routine is designed to handle a left-size MID$ call.
; So check to see if the character at the location of the current BASIC
; program pointer in Register A is trying to process a left hand side MID$.
; If they match, the Z FLAG is set, and otherwise the NZ FLAG is set.
; If A < the checked value, then the C FLAG is set.
; If A >= the checked value, the NC FLAG is set.
; ----------------------------------------------------------------------
ISMID:	cp	TKMID-TKOFF	;2ae7 - Check the Mid Token.
	jp	nz,SNERR	;2ae9
	jp	DLHSMD		;2aec JUMP to DOS to see if DOS wants to deal with this.
;
; ----------------------------------------------------------------------
; 2AEF-2AF7 – LEVEL II BASIC INP ROUTINE– “FNINP”
; ----------------------------------------------------------------------
FNINP:	call	CONINT		;2aef
	ld	(STAINP+1),a	;2af2
	call	STAINP		;2af5
	jp	SNGFLT		;2af8
;
; ----------------------------------------------------------------------
; 2AF8-2B00 – LEVEL II BASIC OUT ROUTINE– “FNOUT”
; ----------------------------------------------------------------------
FNOUT:	call	SETIO		;2afb
	jp	OUTWRD		;2afe
;
; ----------------------------------------------------------------------
; 2B01-2B0D – EVALUATE EXPRESSION ROUTINE “GETINT”
;   This evaluates an expression and leaves the result in DE as an integer.
; ----------------------------------------------------------------------
GETINT:	GETCHR			;2b01 - rst 10h
;
; ----------------------------------------------------------------------
; 2B02H - LOAD INTEGER EXPRESSION IN DE
;   Same as routine at 1E46H except allows negative argument.
;   Number must evaluate within range -32768 to 32767.
; ----------------------------------------------------------------------
GETIN2:	call	FRMEVL		;2b02
;
; ----------------------------------------------------------------------
; 2B05 – MATH CONVERSION ROUTINE - This routine converts value from the ACC to an
; integer value and places the result in the DE Register Pair. The Z flag will be
; set if the result in DE is smaller than or equal to 255 (FFH). (DE = INT (ACC)).
; ----------------------------------------------------------------------
INTFR2:	push	hl		;2b05
	call	FRCINT		;2b06
	ex	de,hl		;2b09
	pop	hl		;2b0a
	ld	a,d		;2b0b
	or	a		;2b0c
	ret			;2b0d
;
; ----------------------------------------------------------------------
; 2B0E-2B16 – EVALUATE EXPRESSION ROUTINE – OUT continues here – “SETIO”
; ----------------------------------------------------------------------
SETIO:	call	GETBYT		;2b0e
	ld	(STAINP+1),a	;2b11
	ld	(OUTWRD+1),a	;2b14
; ----------------------------------------------------------------------
; 2B17-2B1A – CHECK SYNTAX ROUTINE – This checks to see if the next character
; is a “ and contnues on to 2B1CH if it is, and errors out if it isn’t.
; ----------------------------------------------------------------------
	SYNTAX	(',')		;2b17 - rst 08h
	jr	GETBYT		;2b19
;
; ----------------------------------------------------------------------
; 2B1B-2B28 – EVALUATE EXPRESSION ROUTINE – This is called by PRINT TAB – “GTBYTC”.
; ----------------------------------------------------------------------
GTBYTC:	GETCHR			;2b1b - rst 10h
;
; ----------------------------------------------------------------------
; 2B1C – Common Conversion Routine – “GETBYT”
;   This routine converts a numeric ASCII string pointed to by the HL
;   into a hexadecimal value and places the result in the A register.
;   If the result is larger than 255 (FFH) then an FC ERROR (Illegal
;   function call) will be generated. After execution the HL will point
;   to the delimiter. If the delimiter is a zero byte or a colon (3AH)
;   then the Z flag will be set. Any other delimiter will cause the
;   Z flag to be reset.
; ----------------------------------------------------------------------
GETBYT:	call	FRMEVL		;2b1c
CONINT:	call	INTFR2		;2b1f
	jp	nz,FCERR	;2b22
	dec	hl		;2b25
	GETCHR			;2b26 - rst 10h
	ld	a,e		;2b27
	ret			;2b28
;
; ----------------------------------------------------------------------
; 2B29-2B2D – LEVEL II BASIC LLIST ROUTINE – “LLIST”
;   This routine sets the output device flag to PRINTER and then
;   flows through to the LIST command.
; ----------------------------------------------------------------------
LLIST:	ld	a,DEV1PRT	;2b29 - the output device code for the printer (1)
	ld	(PRTFLG),a	;2b2b - Save the current output device type number
; ----------------------------------------------------------------------
; 2B2E-2B74 – LEVEL II BASIC LIST ROUTINE – “LIST”
;   On entry the STACK has the return address, then the first basic line
;   number to be listed, then the last basic line number to be listed.
; ----------------------------------------------------------------------
LIST:	pop	bc		;2b2e
	call	SCNLINE		;2b2f
	push	bc		;2b32
LIST4:	ld	hl,$FFFF	;2b33
	ld	(CURLIN),hl	;2b36
	pop	hl		;2b39
	pop	de		;2b3a
	ld	c,(hl)		;2b3b
	inc	hl		;2b3c
	ld	b,(hl)		;2b3d
	inc	hl		;2b3e
	ld	a,b		;2b3f
	or	c		;2b40
	jp	z,READY		;2b41
	call	EXCHDS		;2b44
	call	ISCNTN		;2b47
	push	bc		;2b4a
	ld	c,(hl)		;2b4b
	inc	hl		;2b4c
	ld	b,(hl)		;2b4d
	inc	hl		;2b4e
	push	bc		;2b4f
	ex	(sp),hl		;2b50
	ex	de,hl		;2b51
	CPDEHL			;2b52
	pop	bc		;2b53
	jp	c,STPRDY	;2b54
	ex	(sp),hl		;2b57
	push	hl		;2b58
	push	bc		;2b59
	ex	de,hl		;2b5a
	ld	(DOT),hl	;2b5b
	call	LINPRT		;2b5e
	ld	a,SPACE		;2b61
	pop	hl		;2b63
	call	OUTDO		;2b64
	call	BUFLIN		;2b67
	ld	hl,(BUFPNT)	;2b6a
	call	LISPRT		;2b6d
	call	CRDO		;2b70
	jr	LIST4		;2b73
; ----------------------------------------------------------------------
; 2B75-2B7D – DISPLAY MESSAGE ROUTINE – “LISPRT”
;  Output a string to device indicated by device type flag stored
;  at 409CH. On entry, HL registers must point to address of start of string.
;  String must end with zero byte. Calls routine at 032AH
;  (note warning for that routine)
; ----------------------------------------------------------------------
LISPRT:	ld	a,(hl)		;2b75
	or	a		;2b76
	ret	z		;2b77
	call	OUTDO		;2b78
	inc	hl		;2b7b
	jr	LISPRT		;2b7c
; ----------------------------------------------------------------------
; 2B7E-2BC5 – UNTOKENIZE ROUTINE – “BUFLIN”
; ----------------------------------------------------------------------
BUFLIN:	push	hl		;2b7e
	ld	hl,(BUFPNT)	;2b7f
	ld	b,h		;2b82
	ld	c,l		;2b83
	pop	hl		;2b84
	ld	d,$FF		;2b85
	jr	PLOOP2		;2b87
PLOOP:	inc	bc		;2b89
	dec	d		;2b8a
	ret	z		;2b8b
PLOOP2:	ld	a,(hl)		;2b8c
	or	a		;2b8d
	inc	hl		;2b8e
	ld	(bc),a		;2b8f
	ret	z		;2b90
	jp	p,PLOOP		;2b91
	cp	TKSNQT		;2b94 - single quote token
	jr	nz,NRQTTK	;2b96
	dec	bc		;2b98
	dec	bc		;2b99
	dec	bc		;2b9a
	dec	bc		;2b9b
	inc	d		;2b9c
	inc	d		;2b9d
	inc	d		;2b9e
	inc	d		;2b9f
NRQTTK:	cp	TKELSE		;2ba0 - else token
	call	z,DCXBRT	;2ba2
	sub	$7F		;2ba5
	push	hl		;2ba7
	ld	e,a		;2ba8
	ld	hl,RESLST	;2ba9 - starting address of the reserved words list
LOPRES:	ld	a,(hl)		;2bac
	or	a		;2bad
	inc	hl		;2bae
	jp	p,LOPRES	;2baf
	dec	e		;2bb2
	jr	nz,LOPRES	;2bb3
	and	$7F		;2bb5
MORPUR:	ld	(bc),a		;2bb7
	inc	bc		;2bb8
	dec	d		;2bb9
	jp	z,PPSWRT	;2bba
	ld	a,(hl)		;2bbd
	inc	hl		;2bbe
	or	a		;2bbf
	jp	p,MORPUR	;2bc0
	pop	hl		;2bc3
	jr	PLOOP2		;2bc4
; ----------------------------------------------------------------------
; DELETE
; ----------------------------------------------------------------------
DELETE:	call	SCNLINE		;2bc6
	pop	de		;2bc9
	push	bc		;2bca
	push	bc		;2bcb
	call	FNDLIN		;2bcc
	jr	nc,FCERRG	;2bcf
	ld	d,h		;2bd1
	ld	e,l		;2bd2
	ex	(sp),hl		;2bd3
	push	hl		;2bd4
	CPDEHL			;2bd5
FCERRG:	jp	nc,FCERR	;2bd6
	ld	hl,m_REDDY	;2bd9
	call	STROUT		;2bdc
	pop	bc		;2bdf
	ld	hl,FINI		;2be0
	ex	(sp),hl		;2be3
DELDEL:	ex	de,hl		;2be4
	ld	hl,(VARTAB)	;2be5
MLOOP:	ld	a,(de)		;2be8
	ld	(bc),a		;2be9
	inc	bc		;2bea
	inc	de		;2beb
	CPDEHL			;2bec
	jr	nz,MLOOP	;2bed
	ld	h,b		;2bef
	ld	l,c		;2bf0
	ld	(VARTAB),hl	;2bf1
	ret			;2bf4
;
; ======================================================================
	.ECHO 	" ROM REGION - (2BF5 - 2CA4) - Cload Csave \n"
; ======================================================================
;
; ----------------------------------------------------------------------
; HDBOOT - FreHD HD bootup routine
; ----------------------------------------------------------------------
#IFDEF FREHDBT
;
HDBOOT:	call	CLS		;0069 - Clear Screen
	call	DELAY		;006c - pause for a few seconds
	ld	a,ROM_MODEL_1	;00ff - ROM parameter to FreHD. 1 for Model1.
        out	(WRITEROM),a	;0101 - write the value
        in	a,(READROM)	;0103 - read response
        cp	0FEh		;0105 - FE is FreHD present and valid code!
        ret	nz		;0107 - return if no FreHD or old firmware
        ld	hl,ROM_LOAD	;0108 - load more "rom" from FreHD
        ld	bc,READROM	;010b - port to read and size counter
        inir			;010e - bulk transfer
        jp	ROM_LOAD	;0110 - jump to loader in RAM
; ----------------------------------------------------------------------
	.ECHO	"  * FREHDBT uses "
	.ECHO	($ - HDBOOT)
	.ECHO	" bytes \n"
#ENDIF
;
; ----------------------------------------------------------------------
; KEYBOUNCE - Routine Added to V1.3 ROMS
; ----------------------------------------------------------------------
#IFDEF KEYBOUNCE
;
KEYBOU	push	bc		;011C Save Row Address in BC into the STACK
	ld 	bc,$0500	;011D the debounce delay
	call	DELAY		;0120 delay on delay count in BC (18.8 ms)
	pop	bc		;0123 Restore the Row Address back to BC
	ld	a,(bc)		;0124 Reload the original flags from active row
	and	e		;0125 Combine the current flag lists with the original flag bits
	ret	z		;0126 Return to caller if zero because the row was not active on the second test
	ld	a,d		;0127 Otherwise, we have a legitimate active row
	rlca			;0128 Multiply the row index by 2. twice.
	rlca			;0129 This code previously existed at the calling site
	jp	KYDRES		;012A Resume the keyboard driver routine
; ----------------------------------------------------------------------
	.ECHO	"  * KEYBOUNCE uses "
	.ECHO	($ - KEYBOU)
	.ECHO	" bytes \n"
#ENDIF
; ----------------------------------------------------------------------
;
MEMMSG:	.DB	"Memory Size",0			     ; RS Mem Size Message V1.2
; ----------------------------------------------------------------------
	.ECHO	"  * MEMMSG uses "
	.ECHO	($ - MEMMSG)
	.ECHO	" bytes \n"
;
; ======================================================================
R2FREE:	.EQU 	($2CA5 - $)
	.ECHO 	"  "
	.ECHO	R2FREE
	.ECHO   " of 176 bytes free \n"
	.FILL	R2FREE
; ======================================================================
;
; ----------------------------------------------------------------------
; 2CA5-2CA9 – MESSAGE STORAGE LOCATION – “NOOKCS”
; ----------------------------------------------------------------------
NOOKCS:	.DB	"BAD"		;2ca5
	.DB	ENTER , $00	;2ca8
;
; ----------------------------------------------------------------------
; 2CAA-2CB0 – LEVEL II BASIC PEEK ROUTINE – “PEEK”
;   The original ROM source code says that PEEK only accepts positive
;   numbers up to 32767 and POKE will only take an address up to 32767.
;   Negative numbers can be used to refer to locations higher than 32767,
;   the correspondence is given by subtracting 65536 from locations higher
;   than 32767 or by specifying a positive number up to 65535
; ----------------------------------------------------------------------
PEEK:	call	FRCINT		;2caa - convert Value to Integer, HL contains LSB
	ld	a,(hl)		;2cad - read memory location
	jp	SNGFLT		;2cae - reuse some code to assign this to an unsigned int
;
; ----------------------------------------------------------------------
; 2CB1-2CBC – LEVEL II BASIC POKE ROUTINE – “POKE”
; ----------------------------------------------------------------------
POKE:	call	GETIN2		;2cb1 - get integer address
	push	de		;2cb4 - save integer address
	SYNTAX	(',')		;2cb5 - rst 08h - check for comma
	call	GETBYT		;2cb7 - get byte value to write
	pop	de		;2cba - restore the address
	ld	(de),a		;2cbb - perform the write of value to memory location
	ret			;2cbc
;
; ----------------------------------------------------------------------
; 2CBD-2E52 – LEVEL II BASIC USING ROUTINE – “PRINUS”
;   The original ROM source code says that we wind up here after the “USING”
;   clause in a PRINT statement is recognized. The idea is to scan the using
;   string until the value list is exhausted, finding string and numeric
;   fields to print values out of the list in, and just outputing any
;   characters that aren’t part of a print field
; ----------------------------------------------------------------------
PRINUS:	call	FRMCHK		;2cbd
	call	CHKSTR		;2cc0
	SYNTAX	(SEMICO)	;2cc3 - rst 08h compare with semicolin ';'
	ex	de,hl		;2cc5
	ld	hl,(FACLO)	;2cc6
	jr	INIUS		;2cc9
REUSST:	ld	a,(FLGINP)	;2ccb
	or	a		;2cce
	jr	z,FCERR3	;2ccf
	pop	de		;2cd1
	ex	de,hl		;2cd2
INIUS:	push	hl		;2cd3
	xor	a		;2cd4
	ld	(FLGINP),a	;2cd5
	cp	d		;2cd8
	push	af		;2cd9
	push	de		;2cda
	ld	b,(hl)		;2cdb
	or	b		;2cdc
FCERR3:	jp	z,FCERR		;2cdd
	inc	hl		;2ce0
	ld	c,(hl)		;2ce1
	inc	hl		;2ce2
	ld	h,(hl)		;2ce3
	ld	l,c		;2ce4
	jr	PRCCHR		;2ce5
BGSTRF:	ld	e,b		;2ce7
	push	hl		;2ce8
	ld	c,$02		;2ce9
LPSTRF:	ld	a,(hl)		;2ceb
	inc	hl		;2cec
	cp	'%'		;2ced
	jp	z,ISSTRF	;2cef
	cp	SPACE		;2cf2
	jr	nz,NOSTRF	;2cf4
	inc	c		;2cf6
	djnz	LPSTRF		;2cf7
;
NOSTRF:	pop	hl		;2cf9
	ld	b,e		;2cfa
	ld	a,'%'		;2cfb
;
NEWUCH:	call	PLSPRT		;2cfd
	call	OUTDO		;2d00
PRCCHR:	xor	a		;2d03
	ld	e,a		;2d04
	ld	d,a		;2d05
PLSFIN:	call	PLSPRT		;2d06
	ld	d,a		;2d09
	ld	a,(hl)		;2d0a
	inc	hl		;2d0b
	cp	'!'		;2d0c
	jp	z,SMSTRF	;2d0e
	cp	'#'		;2d11
	jr	z,NUMNUM	;2d13
	dec	b		;2d15
	jp	z,REUSIN	;2d16
	cp	'+'		;2d19
	ld	a,$08		;2d1b
	jr	z,PLSFIN	;2d1d
	dec	hl		;2d1f
	ld	a,(hl)		;2d20
	inc	hl		;2d21
	cp	'.'		;2d22
	jr	z,DOTNUM	;2d24
	cp	'%'		;2d26
	jr	z,BGSTRF	;2d28
	cp	(hl)		;2d2a
	jr	nz,NEWUCH	;2d2b
	cp	'$'		;2d2d
	jr	z,DOLRNM	;2d2f
	cp	'*'		;2d31
	jr	nz,NEWUCH	;2d33
	ld	a,b		;2d35
	cp	$02		;2d36
	inc	hl		;2d38
	jr	c,NOTSPC	;2d39
	ld	a,(hl)		;2d3b
	cp	'$'		;2d3c
NOTSPC:	ld	a,$20		;2d3e
	jr	nz,SPCNUM	;2d40
	dec	b		;2d42
	inc	e		;2d43
;
	.DB	CPNN		;2d44 - Z80 Trick - CP nn - skipping next instruction
;
DOLRNM:	xor	a		;2d45
	add	a,$10		;2d46
	inc	hl		;2d48
SPCNUM:	inc	e		;2d49
	add	a,d		;2d4a
	ld	d,a		;2d4b
NUMNUM:	inc	e		;2d4c
	ld	c,$00		;2d4d
	dec	b		;2d4f
	jr	z,ENDNUS	;2d50
	ld	a,(hl)		;2d52
	inc	hl		;2d53
	cp	'.'		;2d54 - is a . (i.e., a trailing digit).
	jr	z,AFTDOT	;2d56
	cp	'#'		;2d58 - is a # (i.e., a leading digit).
	jr	z,NUMNUM	;2d5a
	cp	','		;2d5c
	jr	nz,FINNUM	;2d5e
	ld	a,d		;2d60
	or	$40		;2d61
	ld	d,a		;2d63
	jr	NUMNUM		;2d64
; ----------------------------------------------------------------------
; 2D66 – Part of the PRINT USING Routine – “DOTNUM”
; ----------------------------------------------------------------------
DOTNUM:	ld	a,(hl)		;2d66
	cp	'#'		;2d67
	ld	a,'.'		;2d69
	jr	nz,NEWUCH	;2d6b
	ld	c,$01		;2d6d
	inc	hl		;2d6f
AFTDOT:	inc	c		;2d70
	dec	b		;2d71
	jr	z,ENDNUS	;2d72
	ld	a,(hl)		;2d74
	inc	hl		;2d75
	cp	'#'		;2d76 - is a #; that there are more digits after the decimal point
	jr	z,AFTDOT	;2d78
; ----------------------------------------------------------------------
; 2D7A – Part of the PRINT USING Routine – “FINNUM”
; ----------------------------------------------------------------------
FINNUM:	push	de		;2d7a
	ld	de,NOTSCI	;2d7b
	push	de		;2d7e
	ld	d,h		;2d7f
	ld	e,l		;2d80
	cp	UPARRW		;2d81 - is an up arrow ↑
	ret	nz		;2d83
	cp	(hl)		;2d84
	ret	nz		;2d85
	inc	hl		;2d86
	cp	(hl)		;2d87
	ret	nz		;2d88
	inc	hl		;2d89
	cp	(hl)		;2d8a
	ret	nz		;2d8b
	inc	hl		;2d8c
	ld	a,b		;2d8d
	sub	$04		;2d8e
	ret	c		;2d90
	pop	de		;2d91
	pop	de		;2d92
	ld	b,a		;2d93
	inc	d		;2d94
	inc	hl		;2d95
;
	.DB	JPZNN		;2d96 Z80 Trick - JP Z,nnnn - skipping next 2 instructions
;
NOTSCI:	ex	de,hl		;2d97
	pop	de		;2d98
ENDNUS:	ld	a,d		;2d99
	dec	hl		;2d9a
	inc	e		;2d9b
	and	$08		;2d9c
	jr	nz,ENDNUM	;2d9e
	dec	e		;2da0
	ld	a,b		;2da1
	or	a		;2da2
	jr	z,ENDNUM	;2da3
	ld	a,(hl)		;2da5
	sub	$2D		;2da6
	jr	z,SGNTRL	;2da8
	cp	$FE		;2daa
	jr	nz,ENDNUM	;2dac
	ld	a,$08		;2dae
SGNTRL:	add	a,$04		;2db0
	add	a,d		;2db2
	ld	d,a		;2db3
	dec	b		;2db4
; ----------------------------------------------------------------------
; 2DB5 – Part of the PRINT USING Routine – “ENDNUM”
; ----------------------------------------------------------------------
ENDNUM:	pop	hl		;2db5
	pop	af		;2db6
	jr	z,FLDFIN	;2db7
	push	bc		;2db9
	push	de		;2dba
	call	FRMEVL		;2dbb
	pop	de		;2dbe
	pop	bc		;2dbf
	push	bc		;2dc0
	push	hl		;2dc1
	ld	b,e		;2dc2
	ld	a,b		;2dc3
	add	a,c		;2dc4
	cp	25		;2dc5 - total number of characters in Register A is greater than 24
	jp	nc,FCERR	;2dc7
	ld	a,d		;2dca
	or	$80		;2dcb - Turn on the “USING” bit in the flags
	call	PUFOUT		;2dcd
	call	STROUT		;2dd0
FNSTRF:	pop	hl		;2dd3
	dec	hl		;2dd4
	GETCHR			;2dd5 - rst 10h
	scf			;2dd6
	jr	z,CRDNUS	;2dd7
	ld	(FLGINP),a	;2dd9
	cp	SEMICO		;2ddc - compare with semicolon ';'
	jr	z,SEMUSN	;2dde
	cp	','		;2de0
	jp	nz,SNERR	;2de2
SEMUSN:	GETCHR			;2de5 - rst 10h
CRDNUS:	pop	bc		;2de6
	ex	de,hl		;2de7
	pop	hl		;2de8
	push	hl		;2de9
	push	af		;2dea
	push	de		;2deb
	ld	a,(hl)		;2dec
	sub	b		;2ded
	inc	hl		;2dee
	ld	c,(hl)		;2def
	inc	hl		;2df0
	ld	h,(hl)		;2df1
	ld	l,c		;2df2
	ld	d,$00		;2df3
	ld	e,a		;2df5
	add	hl,de		;2df6
	ld	a,b		;2df7
	or	a		;2df8
	jp	nz,PRCCHR	;2df9
	jr	FINUSI		;2dfc
; ----------------------------------------------------------------------
; 2DFE-2E00 – Part of the PRINT USING Routine – “REUSIN”
; ----------------------------------------------------------------------
REUSIN:	call	PLSPRT		;2dfe
	call	OUTDO		;2e01
FINUSI:	pop	hl		;2e04
	pop	af		;2e05
	jp	nz,REUSST	;2e06
FLDFIN:	call	c,CRDO		;2e09
	ex	(sp),hl		;2e0c
	call	FRETM2		;2e0d
	pop	hl		;2e10
	jp	FINPRT		;2e11
; ----------------------------------------------------------------------
; 2E14-2E15 – Part of the PRINT USING Routine – “SMSTRF”
; ----------------------------------------------------------------------
SMSTRF:	ld	c,$01		;2e14
;
	.DB	LDANN		;2e16 Z80 Trick - LD A,nn - skipping next instruction
;
ISSTRF:	pop	af		;2e17
	dec	b		;2e18
	call	PLSPRT		;2e19
	pop	hl		;2e1c
	pop	af		;2e1d
	jr	z,FLDFIN	;2e1e
	push	bc		;2e20
	call	FRMEVL		;2e21
	call	CHKSTR		;2e24
	pop	bc		;2e27
	push	bc		;2e28
	push	hl		;2e29
	ld	hl,(FACLO)	;2e2a
	ld	b,c		;2e2d
	ld	c,$00		;2e2e
	push	bc		;2e30
	call	LEFTUS		;2e31
	call	STRPRT		;2e34
	ld	hl,(FACLO)	;2e37
	pop	af		;2e3a
	sub	(hl)		;2e3b
	ld	b,a		;2e3c
	ld	a,SPACE		;2e3d
	inc	b		;2e3f
; ----------------------------------------------------------------------
; This loop will print all the spaces needed and then jump to 2DD3H.
; ----------------------------------------------------------------------
UPRTSP:	dec	b		;2e40
	jp	z,FNSTRF	;2e41
	call	OUTDO		;2e44
	jr	UPRTSP		;2e47
; ---------------------------------------------------------------------
; 2E49 – Part of the PRINT USING Routine – “PLSPRT”
;   When a “+” is detected in the “USING” string and a numeric field follows,
;   a bit in Register D should be set, otherwise + should be printed.
; ----------------------------------------------------------------------
PLSPRT:	push	af		;2e49
	ld	a,d		;2e4a
	or	a		;2e4b
	ld	a,'+'		;2e4c
	call	nz,OUTDO	;2e4e
	pop	af		;2e51
	ret			;2e52
;
; ----------------------------------------------------------------------
; enter EDIT if there was an error in a line number
; ----------------------------------------------------------------------
ERREDT:	ld	(ERRFLG),a	;2e53
	ld	hl,(ERRLIN)	;2e56
	or	h		;2e59
	and	l		;2e5a
	inc	a		;2e5b
	ex	de,hl		;2e5c
	ret	z		;2e5d
	jr	EREDIT		;2e5e
; ----------------------------------------------------------------------
; 2E60-2FFA – LEVEL II BASIC EDIT ROUTINE – “EDIT”
;
;   the EDIT command takes a single line number as its argument. If that
;   line doesn’t exist, and error is thrown. If the line does exist,
;   the line number is then typed, and the system waits for the user
;   to enter any of the valid commands.
; ----------------------------------------------------------------------
EDIT:	call	LINSPC		;2e60
	ret	nz		;2e63
EREDIT:	pop	hl		;2e64
EEDITS:	ex	de,hl		;2e65
	ld	(DOT),hl	;2e66
	ex	de,hl		;2e69
	call	FNDLIN		;2e6a
	jp	nc,USERR	;2e6d
	ld	h,b		;2e70
	ld	l,c		;2e71
	inc	hl		;2e72
	inc	hl		;2e73
	ld	c,(hl)		;2e74
	inc	hl		;2e75
	ld	b,(hl)		;2e76
	inc	hl		;2e77
	push	bc		;2e78
	call	BUFLIN		;2e79
LLED:	pop	hl		;2e7c
	push	hl		;2e7d
	call	LINPRT		;2e7e
	ld	a,SPACE		;2e81
	call	OUTDO		;2e83
	ld	hl,(BUFPNT)	;2e86
	ld	a,CURON		;2e89 -  the “turn on the cursor” character
	call	OUTDO		;2e8b
	push	hl		;2e8e
	ld	c,$FF		;2e8f
LENLP:	inc	c		;2e91
	ld	a,(hl)		;2e92
	or	a		;2e93
	inc	hl		;2e94
	jr	nz,LENLP	;2e95
	pop	hl		;2e97
	ld	b,a		;2e98
DISPED:	ld	d,$00		;2e99
DISPI:	call	INCHR		;2e9b
	sub	'0'		;2e9e - test to see if the character was alphabetic or alphanumeric
	jr	c,NOTDGI	;2ea0
	cp	$0A		;2ea2
	jr	nc,NOTDGI	;2ea4
	ld	e,a		;2ea6
	ld	a,d		;2ea7
	rlca			;2ea8
	rlca			;2ea9
	add	a,d		;2eaa
	rlca			;2eab
	add	a,e		;2eac
	ld	d,a		;2ead
	jr	DISPI		;2eae
;
; ----------------------------------------------------------------------
; 2EB0H – LEVEL II BASIC EDIT ROUTINE – “NOTDGI”
;
;  While getting user command input within an edit, we wind up here if
; the user enters a non-numeric character (i.e., the actual command,
; and not just the repetition number which precedes it)
; ----------------------------------------------------------------------
NOTDGI:	push	hl		;2eb0
	ld	hl,DISPED	;2eb1
	ex	(sp),hl		;2eb4
	dec	d		;2eb5
	inc	d		;2eb6
	jp	nz,NTZERD	;2eb7
	inc	d		;2eba
NTZERD:	cp	$D8		;2ebb - Check to see if the character is a BACKSPACE character
	jp	z,DELED		;2ebd
	cp	$DD		;2ec0 - Check to see if the character is a CARRIAGE RETURN.
	jp	z,CRED		;2ec2
	cp	$F0		;2ec5 - Check to see if the character is a SPACE.
	jr	z,SPED		;2ec7
	cp	$31		;2ec9 - Check to see if the character is lowercase
	jr	c,NOTLW4	;2ecb
	sub	$20		;2ecd - Convert the lowercase character to uppercase
NOTLW4:	cp	'Q'-$30		;2ecf - Check to see if the character is a Q (Quit)
	jp	z,QED		;2ed1
	cp	'L'-$30		;2ed4 - Check to see if the character is an L (Branch)
	jp	z,LED		;2ed6
	cp	'S'-$30		;2ed9 - Check to see if the character is an S (Search)
	jr	z,SED		;2edb
	cp	'I'-$30		;2edd - Check to see if the character is an I (Insert)
	jp	z,IED		;2edf
	cp	'D'-$30		;2ee2 - Check to see if the character is a D (Delete)
	jp	z,DED		;2ee4
	cp	'C'-$30		;2ee7 - Check to see if the character is a C (Change)
	jp	z,CED		;2ee9
	cp	'E'-$30		;2eec - Check to see if the character is an E (End)
	jp	z,EED		;2eee
	cp	'X'-$30		;2ef1 - Check to see if the character is an X (Extend)
	jp	z,XED		;2ef3
	cp	'K'-$30		;2ef6 - Check to see if the character is a K (Kill)
	jr	z,KED		;2ef8
	cp	'H'-$30		;2efa - Check to see if the character is an H (Hack)
	jp	z,HED		;2efc
	cp	'A'-$30		;2eff - Check to see if the character is an A (Again)
	ret	nz		;2f01
; ----------------------------------------------------------------------
; 2F02 – EDIT Command – Cancel and Restore Logic.
; ----------------------------------------------------------------------
	pop	bc		;2f02
	pop	de		;2f03
	call	CRDO		;2f04
	jp	EEDITS		;2f07
; ----------------------------------------------------------------------
; 2F0A – This routine prints a string of text to the display, printer or tape – “SPED”
;
;   This routine it uses 032AH to do this. HL must point to the first character of
;   the string. (409CH must be set before calling this routine, see 32AH).
;   String must be delimited with a zero byte.
;   409CH holds current output device flag: -1=cassette, 0=video and 1=printer
; ----------------------------------------------------------------------
SPED:	ld	a,(hl)		;2f0a
	or	a		;2f0b
	ret	z		;2f0c
	inc	b		;2f0d
	call	OUTDO		;2f0e
	inc	hl		;2f11
	dec	d		;2f12
	jr	nz,SPED		;2f13
	ret			;2f15
; ----------------------------------------------------------------------
; 2F16 – EDIT Command – KILL Logic – “KED”.
; ----------------------------------------------------------------------
KED:	push	hl		;2f16
	ld	hl,TYPSLH	;2f17
	ex	(sp),hl		;2f1a
	scf			;2f1b
SED:	push	af		;2f1c
	call	INCHR		;2f1d
	ld	e,a		;2f20
	pop	af		;2f21
	push	af		;2f22
	call	c,TYPSLH	;2f23
SRCALP:	ld	a,(hl)		;2f26
	or	a		;2f27
	jp	z,POPART	;2f28
	call	OUTDO		;2f2b
	pop	af		;2f2e
	push	af		;2f2f
	call	c,DELCHR	;2f30
	jr	c,NOTSRC	;2f33
	inc	hl		;2f35
	inc	b		;2f36
NOTSRC:	ld	a,(hl)		;2f37
	cp	e		;2f38
	jr	nz,SRCALP	;2f39
	dec	d		;2f3b
	jr	nz,SRCALP	;2f3c
POPART:	pop	af		;2f3e
	ret			;2f3f
; ----------------------------------------------------------------------
; 2F40 – EDIT Command – LIST Logic – “LED”.
; ----------------------------------------------------------------------
LED:	call	LISPRT		;2f40
	call	CRDO		;2f43
	pop	bc		;2f46
	jp	LLED		;2f47
; ----------------------------------------------------------------------
; 2F4A – EDIT Command – DELETE Logic – “DED”
; ----------------------------------------------------------------------
DED:	ld	a,(hl)		;2f4a
	or	a		;2f4b
	ret	z		;2f4c
	ld	a,'!'		;2f4d
	call	OUTDO		;2f4f
DELLP:	ld	a,(hl)		;2f52
	or	a		;2f53
	jr	z,TYPSLH	;2f54
	call	OUTDO		;2f56
	call	DELCHR		;2f59
	dec	d		;2f5c
	jr	nz,DELLP	;2f5d
TYPSLH:	ld	a,'!'		;2f5f
	call	OUTDO		;2f61
	ret			;2f64
; ----------------------------------------------------------------------
; 2F65 – EDIT Command – CHANGE Logic – “CED”.
; ----------------------------------------------------------------------
CED:	ld	a,(hl)		;2f65
	or	a		;2f66
	ret	z		;2f67
	call	INCHR		;2f68
	ld	(hl),a		;2f6b
	call	OUTDO		;2f6c
	inc	hl		;2f6f
	inc	b		;2f70
	dec	d		;2f71
	jr	nz,CED		;2f72
	ret			;2f74
; ----------------------------------------------------------------------
; 2F75 – EDIT Command – HACK/INSERT Logic – “HED”
; ----------------------------------------------------------------------
HED:	ld	(hl),$00	;2f75
	ld	c,b		;2f77
XED:	ld	d,$FF		;2f78
	call	SPED		;2f7a
IED:	call	INCHR		;2f7d
	or	a		;2f80
	jp	z,IED		;2f81
	cp	BACKS		;2f84
	jr	z,TYPARW	;2f86
	cp	ENTER		;2f88
	jp	z,CRED		;2f8a
	cp	ARUP		;2f8d - Up arrow
	ret	z		;2f8f
	jr	nz,NTARRW	;2f90
; ----------------------------------------------------------------------
; 2F92 – EDIT Command – BACKSPACE CURSOR Logic – “TYPARW”.
; ----------------------------------------------------------------------
TYPARW:	ld	a,BACKS		;2f92
	dec	b		;2f94
	inc	b		;2f95
	jr	z,DINGI		;2f96
	call	OUTDO		;2f98
	dec	hl		;2f9b
	dec	b		;2f9c
	ld	de,IED		;2f9d
	push	de		;2fa0
; ----------------------------------------------------------------------
; 2FA1 – LEVEL II BASIC EDIT ROUTINE – “DELCHR”
;   This subroutine will delete the character pointed to by HL
;   and will correct Register C
; ----------------------------------------------------------------------
DELCHR:	push	hl		;2fa1
	dec	c		;2fa2
CMPRSS:	ld	a,(hl)		;2fa3
	or	a		;2fa4
	scf			;2fa5
	jp	z,POPHRT	;2fa6
	inc	hl		;2fa9
	ld	a,(hl)		;2faa
	dec	hl		;2fab
	ld	(hl),a		;2fac
	inc	hl		;2fad
	jr	CMPRSS		;2fae
; ----------------------------------------------------------------------
; 2FB0 – EDIT Command – ADD A CHARACTER Logic – “NTARRW”.
; ----------------------------------------------------------------------
NTARRW:	push	af		;2fb0
	ld	a,c		;2fb1
	cp	$FF		;2fb2
	jr	c,OKINS		;2fb4
	pop	af		;2fb6
DINGI:	jr	IED		;2fb7
OKINS:	sub	b		;2fb9
	inc	c		;2fba
	inc	b		;2fbb
	push	bc		;2fbc
	ex	de,hl		;2fbd
	ld	l,a		;2fbe
	ld	h,$00		;2fbf
	add	hl,de		;2fc1
	ld	b,h		;2fc2
	ld	c,l		;2fc3
	inc	hl		;2fc4
	call	BLTUC		;2fc5
	pop	bc		;2fc8
	pop	af		;2fc9
	ld	(hl),a		;2fca
	call	OUTDO		;2fcb
	inc	hl		;2fce
	jp	IED		;2fcf
; ----------------------------------------------------------------------
; 2FD2 – EDIT Command – BACKSPACE Logic – “DELED”.
; ----------------------------------------------------------------------
DELED:	ld	a,b		;2fd2
	or	a		;2fd3
	ret	z		;2fd4
	dec	b		;2fd5
	dec	hl		;2fd6
	ld	a,BACKS		;2fd7
	call	OUTDO		;2fd9
	dec	d		;2fdc
	jr	nz,DELED	;2fdd
	ret			;2fdf
CRED:	call	LISPRT		;2fe0
EED:	call	CRDO		;2fe3
	pop	bc		;2fe6
	pop	de		;2fe7
	ld	a,d		;2fe8
	and	e		;2fe9
	inc	a		;2fea
EDITRT:	ld	hl,(BUFPNT)	;2feb
	dec	hl		;2fee
	ret	z		;2fef
	scf			;2ff0
	inc	hl		;2ff1
	push	af		;2ff2
	jp	EDENT		;2ff3
; ----------------------------------------------------------------------
; 2FF6 – EDIT Command – QUIT Logic – “QED”.
; ----------------------------------------------------------------------
QED:	pop	bc		;2ff6
	pop	de		;2ff7
	jp	READY		;2ff8
;
; ----------------------------------------------------------------------
; 2FFB - 2FFF - UNUSED bytes - serves no purpose used for checksum
	.DB	$DE, $C3, $C3, $44, $B2
;
; ======================================================================
; THE END OF THE LEVEL II BASIC ROMS
; ======================================================================
;                END OF CODE
; ======================================================================
;
;
; ----------------------------------------------------------------------
;  Input Output Map
; ----------------------------------------------------------------------
;
#IFDEF EACA80
;
; On Disk Smith System 80 (EACA) there are additional Hardware IO ports
prtport: .EQU	$FD		; Printer Port (replaces 37E8)
casport: .EQU	$FE		; Cassette Select Port (replaces 37E4)
;
#ENDIF
;
vidcmt:	 .EQU	$FF		; VIDEO I/O Mode select and Cassette Port
;
; ----------------------------------------------------------------------
;  Memory Mapped Hardware
; ----------------------------------------------------------------------
;
dskselect:	.EQU $37E1	; Disk Drive Select Latch Address
casselect:	.EQU $37E4	; Cassette Select Latch Address
prtstat:	.EQU $37E8	; Printer Status (Read) & Data (Write)
diskstat:	.EQU $37EC	; Disk controller status
disktrk:	.EQU $37ED	; Disk track select
disksect:	.EQU $37EE	; Disk sector select
diskdata:	.EQU $37EF	; Disk data byte
;
kbdmatrix:	.EQU $3800	; Keyboard matrix start (100H bytes)
vidmem:		.EQU $3C00	; Video RAM start (400H bytes)
vidlin:		.EQU 64 	; Video RAM line Size (64 characters)
;
; ----------------------------------------------------------------------
;  Memory Map
; ----------------------------------------------------------------------
;
mRST1:	.EQU	RAM+$00		; RST 08h (Syntax Check) Vector
mRST2:	.EQU	RAM+$03		; RST 10h (Get Next Character) Vector.
mRST3:	.EQU	RAM+$06		; RST 18h (Cp HL, DE) Vector.
mRST4:	.EQU	RAM+$09		; RST 20h (Get Current Type) Vector.
mRST5:	.EQU	RAM+$0C		; RST 28h (Break Key Vector) Vector.
mRST6:	.EQU	RAM+$0F		; RST 30h (DOS DEBUG entry point) Vector.
mRST7:	.EQU	RAM+$12		; RST 38h (Interrupt Service) Vector.
;
mKDCB:	.EQU	RAM+$15		; Keyboard Device Block
;
mDDCB:	.EQU	RAM+$1D		; Video Device Block
CURSOR:	.EQU	RAM+$20		; Video Device Block - CURSOR
;
mPDCB:	.EQU	RAM+$25		; Printer Device Block
;
CIOSS:	.EQU	RAM+$33		; call device driver ala dos - CIO$
KYBTSS:	.EQU	RAM+$36		; Keyboard driver work area (to 403C) - KYB$
				; Stores contents of keyboard rows to see if key just
				; pressed or if it was pressed previously.
CAST:	.EQU	RAM+$3D		; Video Display Control Attributes (shadow IO Port $FF)
;
CAST32	.EQU	$08		; Cassette 32 Character Mode Bit
;
TMPSTK:	.EQU	RAM+$7D		; Stack pointer for initial DISK, bootstrap.
;
FDIVC:	.EQU	RAM+$80		; Subtraction routine used by division code...
FDIVB:	.EQU	RAM+$84		; These offests are used to set argumnets...
FDIVA:	.EQU	RAM+$88		; into the routine before calling it...
FDIVG:	.EQU	RAM+$8B		; hence why the code is copied into RAM.
;
USRTAB:	.EQU	RAM+$8E		; Contains address of user subroutine
;
MULTR:	.EQU	RAM+$90		; Random number seed
STAINP:	.EQU	RAM+$93		; Input  port routine IN  A,(00)
OUTWRD:	.EQU	RAM+$96		; Output port routine OUT A,(00)
CHARC:	.EQU	RAM+$99		; Last key pressed on the keyboard
ERRFLG:	.EQU	RAM+$9A		; Current Error Code. See ERR function
LPTPOS:	.EQU	RAM+$9B		; No. Of chars. In current print line
PRTFLG:	.EQU	RAM+$9C		; Current output device flag. -VE=CAS, 0=vid, 1=print
LINLEN:	.EQU	RAM+$9D		; Number of chars on video display line.
CLMLST:	.EQU	RAM+$9E		; Number of chars on printed line.
PARQTD:	.EQU	RAM+$9F		; String Parser: "Quoted" (Bit 0), REM (Bit 2), or DATA (Bit 1).
;
STKTOP:	.EQU	RAM+$A0		; Start of String Storage Area (Stack). initial MEMSIZE-32
CURLIN:	.EQU	RAM+$A2		; Current Line Number in a BASIC Program
TXTTAB:	.EQU	RAM+$A4		; Start of Basic Program Storage. Pointer
TTYPOS:	.EQU	RAM+$A6		; Cursor pos on VDU line. See POS function.
BUFPNT:	.EQU	RAM+$A7		; Keyboard Input buffer. Pointer typically to
CASFLG:	.EQU	RAM+$A9		; contains 00H if INPUT from cassette
RNDX:	.EQU	RAM+$AA		; Random number seed
DIMFLG:	.EQU	RAM+$AE		; locate or create variable routine flag
VALTYP:	.EQU	RAM+$AF		; Work Register Value Type flag
;
; bitmask $08 in (??) which indicates 32bit mode
VTINT:	.EQU	$02		; Integer - Value Types stored in VALTYP
VTSTR	.EQU	$03		; String - These numbers indicate the number
VTSNG	.EQU	$04		; Single Precision - of bytes used to store value
VTDBL	.EQU	$08		; Double Precision
;
DORES:	.EQU	RAM+$B0		; Intermediate value during expression eval
MEMSIZ:	.EQU	RAM+$B1		; Top of memory pointer
TEMPPT:	.EQU	RAM+$B3		; next location for three-byte string variable
TEMPST:	.EQU	RAM+$B5		; String variable VARPTR storage area
;
DSCTMP:	.EQU	RAM+$D3		; VARPTR storage area for string being created
DSCPTR:	.EQU	RAM+$D4		; 2byte address to buffer where ASCII decimal written.
FRETOP:	.EQU	RAM+$D6		; Pointer to next free byte in string storage area
TEMP3:	.EQU	RAM+$D8		; temporary storage location by multiple routines
DATLIN:	.EQU	RAM+$DA		; Line number of last DATA item read
SUBFLG:	.EQU	RAM+$DC		; If 64 a FOR-NEXT loop is being processed
BFKLFL:	.EQU	RAM+$DD		; Flag indicates whether inputing text
FLGINP:	.EQU	RAM+$DE		; Flags whether READ or INPUT, and PRINT USING
TEMP:	.EQU	RAM+$DF		; temporary storage location
;
AUTFLG:	.EQU	RAM+$E1		; AUTO on or off flag. 0=AUTO is off.
AUTLIN:	.EQU	RAM+$E2		; Current line number for the AUTO command.
AUTINC:	.EQU	RAM+$E4		; AUTO command increment value
SAVTXT:	.EQU	RAM+$E6		; During input: addr of code string for current statement
SAVSTK:	.EQU	RAM+$E8		; During execution: holds stack pointer value when statement execution begins
ERRLIN:	.EQU	RAM+$EA		; Line no. In which error occurred
DOT:	.EQU	RAM+$EC		; Stores the current line number.
ERRTXT:	.EQU	RAM+$EE		; Pointer to last byte executed when error occured. Used by RESUME command.
;
ONELIN:	.EQU	RAM+$F0		; Line Number: ON ERROR location for ON ERROR GOTO
ONEFLG:	.EQU	RAM+$F2		; Flag to indicate whether an error has occured
TEMP2:	.EQU	RAM+$F3		; Addr of decimal point in pbuff
OLDLIN:	.EQU	RAM+$F5		; Last line number executed prior to execution of STOP or END
OLDTXT:	.EQU	RAM+$F7		; Pointer to end of last statement executed. Used by CONT command.
VARTAB:	.EQU	RAM+$F9		; Starting address of the simple variables list table
ARYTAB:	.EQU	RAM+$FB		; Starting address of the ARRAY VARIABLE TABLE
STREND:	.EQU	RAM+$FD		; Pointer to the END of array variables, start of free memory
DATPTR:	.EQU	RAM+$FF		; ‘DATA’ Pointer (2 Byte Address; LSB, MSB).
;
DEFTBL:	.EQU	RAM+$101	; Variable declaration list. 1 entry for each letter A-Z (4101-411A)
;
TRCFLG:	.EQU	RAM+$11B	; Trace flag: 0=off (TROFF), non-zero=on (TRON)
;
DFACLO:	.EQU	RAM+$11D	; REG 1  - Double Precision (Reg 1 411D-4124)
FACLO:	.EQU	RAM+$121	; REG 1  - Single Precision
FAC:	.EQU	RAM+$124	; REG 1  - Exponent
FACSGN:	.EQU	RAM+$125	; Result - Sign  of result for math ops (FAC+1)
FACFLG:	.EQU	RAM+$126	; Result - Flags of result for math ops (FAC+2)
ARGLO:	.EQU	RAM+$127	; REG 2  - Double Precision (Reg 2 4127-412E)
ARG:	.EQU	RAM+$12E	; REG 2  - Exponent
;
FBUFFR:	.EQU	RAM+$130	; Print buffer used for print processing  (4130-4149)
FMLTT0:	.EQU	RAM+$14A	; Workspace For Double Precision Division (414A-4151)
FMLTT1:	.EQU	RAM+$14F	; continued.
FMLTT2:	.EQU	RAM+$150	; continued.
;
; Disk BASIC Function Exits - Basic Functions (4152-41A5)
; initially these are all populated with JP L3ERR statements by code at (008E)
ERCALL:	.EQU	RAM+$152	; Base Address for Disk Basic Functions
DVCVI:	.EQU	ERCALL+0	; CVI - $4152
DVFN:	.EQU	ERCALL+3	; FN  - $4155
DVCVS:	.EQU	ERCALL+6	; CVS - $4158
DVDEF:	.EQU	ERCALL+9	; DEF - $415B
DVCVD:	.EQU	ERCALL+12	; CVD - $415E
DVEOF:	.EQU	ERCALL+15	; EOF - $4161
DVLOC:	.EQU	ERCALL+18	; LOC - $4164
DVLOF:	.EQU	ERCALL+21	; LOF - $4167
DVMKI:	.EQU	ERCALL+24	; MKI - $416A
DVMKS:	.EQU	ERCALL+27	; MKS - $417D
DVMKD:	.EQU	ERCALL+30	; MKD - $4170
DVCMD:	.EQU	ERCALL+33	; CMD . $4173
DVTIME:	.EQU	ERCALL+36	; TIME$ $4176
DVOPEN:	.EQU	ERCALL+39	; OPEN  $4179
DVFIEL:	.EQU	ERCALL+42	; FIELD $417C
DVGET:	.EQU	ERCALL+45	; GET - $417F
DVPUT:	.EQU	ERCALL+48	; PUT - $4182
DVCLOS:	.EQU	ERCALL+51	; CLOSE $4185
DVLOAD:	.EQU	ERCALL+54	; LOAD  $4188
DVMERG:	.EQU	ERCALL+57	; MERGE $418B
DVNAME:	.EQU	ERCALL+60	; NAME  $418E
DVKILL:	.EQU	ERCALL+63	; KILL  $4191
DVAND:	.EQU	ERCALL+66	; &   - $4194
DVLSET:	.EQU	ERCALL+69	; LSET  $4197
DVREST:	.EQU	ERCALL+72	; RSET  $419A
DVINST:	.EQU	ERCALL+75	; INSTR $419D
DVSAVE:	.EQU	ERCALL+78	; SAVE  $41A0
DVLINE:	.EQU	ERCALL+81	; LINE  $41A3
;
; DOS Exits, Pass control between Level II BASIC and Disk BASIC (41A6-41E2)
; initially these are all populated with RET statements by code at (009F)
DEXT:	.EQU	RAM+$1A6	; Base Address for DOS Exits
EXDSKR:	.EQU	DEXT+0		; (19EC) Disk Basic ERROR handling (41A6)
USROUT:	.EQU	DEXT+3		; (27FE) USR N - to expand function to provide up to ten USR calls (41A9)
PRGFIN:	.EQU	DEXT+6		; (1A1C) BASIC start up. Just before BASIC's 'READY' message (41AC)
INLINE:	.EQU	DEXT+9		; (0368) At start of keyboard input (41AF)
DIRDO:	.EQU	DEXT+12		; (1AA1) Input scanner after tokenizing current statement (41B2)
EXFIND:	.EQU	DEXT+15		; (1AEC) Input scanner after updating program statement table (41B5)
EXFIN2:	.EQU	DEXT+18		; (1AF2) Input scanner after reinitializing BASIC. (41B8)
CLSALL:	.EQU	DEXT+21		; (1D**) Initializing BASIC for new routine. During END processing (41BB)
FINDRT:	.EQU	DEXT+24		; (2174) During initializing of system output device (41BE)
EXOUTC:	.EQU	DEXT+27		; (032C) During writing to system output device. (41C1)
EXINC:	.EQU	DEXT+30		; (0358) When scanning keyboard. (41C4)
LRUN:	.EQU	DEXT+33		; (1EA6) At start of RUN NNN processing. (41C7)
FILGET:	.EQU	DEXT+36		; (206F) At beginning of PRINT processing. (41CA)
EXDSKL:	.EQU	DEXT+39		; (20C6) During PRINT # or PRINT item processing. (41CD)
EXDSCR:	.EQU	DEXT+42		; (2103) When skipping to next line on video during a output op (41D0)
EXPDOS:	.EQU	DEXT+45		; (21**) At start of PRINT on cassette and during PRINT TAB. (41D3)
EXUNKN:	.EQU	DEXT+48		; (219E) At beginning of INPUT processing (41D6)
DLHSMD:	.EQU	DEXT+51		; (2AEC) MID$ function DOS EXIT (41D9)
FILIND:	.EQU	DEXT+54		; (222D) During READ processing when a variable has been read. (41DC)
EXCHDS:	.EQU	DEXT+57		; (2***) From List, At end of READ processing (41DF)
SYSOUT:	.EQU	DEXT+60		; (02B2) During SYSTEM command operation (41E2)
;
BUFINI:	.EQU	RAM+$1E5	; String Buffer initialised with -> colon null comma (M1)
SMPSTK:	.EQU	RAM+$1F8	; Initial Stack address (M1)
;
MEMEND:	.EQU	RAM+$200	; End of Reserved RAM Communications area
;
SYSSTK:	.EQU	MEMEND+$88	; Stack address usd by SYSTEM command
;
; ======================================================================
; Report Free Memory
	.ECHO 	" "
	.ECHO	R1FREE + R2FREE
	.ECHO   " TOTAL bytes free \n"
; ======================================================================
;
; PADDING to create 16KB ROM Image, to allow append multiple
; versions into a larger (modern) paged ROM file.
;
#IFDEF	SIZE16K
	.FILL	$4000 - $
#ENDIF
; ======================================================================
;
; If this file is being #Included from another assembly file
; we may want to disable the END directive
;
#IFNDEF DONTEND
	.END
#ENDIF
; ======================================================================
